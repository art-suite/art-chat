module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 176);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var ref, ref1;

module.exports = (ref = typeof Neptune !== "undefined" && Neptune !== null ? (ref1 = Neptune.Art) != null ? ref1.StandardLib : void 0 : void 0) != null ? ref : __webpack_require__(269);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(250);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(203);


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var Core, Types, isFunction, isJsonAtomicType, isObject, isPlainArray, isPlainObject, isString, mergeInto, ref;

ref = Core = __webpack_require__(7), isPlainObject = ref.isPlainObject, mergeInto = ref.mergeInto, isString = ref.isString, isFunction = ref.isFunction, isObject = ref.isObject, isPlainArray = ref.isPlainArray, isJsonAtomicType = ref.isJsonAtomicType;

module.exports = Types = (function() {
  var cloneObjectUpToKey, deepEach, deepEachAll, deepMap, deepMapArray, deepMapObject, functionName, noopMapper, objectName, toJsonStructure, toPostMessageStructure;

  function Types() {}

  mergeInto(Types, Core.Types);

  Types.gt = function(a, b) {
    if (isFunction(a.gt)) {
      return a.gt(b);
    } else {
      return a > b;
    }
  };

  Types.lt = function(a, b) {
    if (isFunction(a.lt)) {
      return a.lt(b);
    } else {
      return a < b;
    }
  };

  Types.gte = function(a, b) {
    if (isFunction(a.gte)) {
      return a.gte(b);
    } else {
      return a >= b;
    }
  };

  Types.lte = function(a, b) {
    if (isFunction(a.lte)) {
      return a.lte(b);
    } else {
      return a <= b;
    }
  };


  /*
  like RubyOnRails#present:
    "An object is present if it's not blank."
  
  basic:
    present null, undefined or "" returns false (or whatever returnIfNotPresent is set to)
    all other values return something truish - generally themselves
  
  custom:
    for bar where isFunction bar.present
      present bar returns bar.present()
  
  special-case truish results:
    present 0 or false returns true
  
  for any other value foo,
    present foo returns foo
  
  IN:
    obj:
      object tested for presence
    returnIfNotPresent: [false]
      what to return if not present
  
  OUT:
    returnIfNotPresent, true, or the value passed in
  
  If 'obj' has method: obj.present() => obj.present()
   */

  Types.present = function(obj, returnIfNotPresent) {
    var present;
    if (returnIfNotPresent == null) {
      returnIfNotPresent = false;
    }
    present = isFunction(obj != null ? obj.getPresent : void 0) ? obj.getPresent() : isFunction(obj != null ? obj.present : void 0) ? obj.present() : isString(obj) ? !obj.match(/^\s*$/) : obj !== void 0 && obj !== null;
    if (present) {
      return obj || true;
    } else {
      return returnIfNotPresent;
    }
  };

  Types.functionName = functionName = function(f) {
    var matched;
    return f.name || ((matched = ("" + f).match(/function ([a-zA-Z]+)\(/)) && matched[1]) || "function";
  };

  Types.objectName = objectName = function(obj) {
    var a, name, ref1;
    if (!obj) {
      return "" + obj;
    } else if (a = typeof obj.getNamespacePath === "function" ? obj.getNamespacePath() : void 0) {
      return a;
    } else if (a = obj.classPathName) {
      return a;
    } else if (obj.constructor === Object) {
      return "Object";
    } else if (isFunction(obj)) {
      return functionName(obj);
    } else if (isString(name = (ref1 = obj.constructor) != null ? ref1.name : void 0) && name.length > 0) {
      return name;
    } else if (obj instanceof Object) {
      return "(anonymous instanceof Object)";
    } else {
      return "(objectName unknown)";
    }
  };

  Types.isBrowserObject = function(obj) {
    var name;
    if (!Types.isObject(obj)) {
      return false;
    }
    name = Types.objectName(obj);
    return name.slice(0, 4) === "HTML" || name.slice(0, 22) === "CanvasRenderingContext";
  };


  /*
  IN:
    f: (value, [key]) ->
      f is called on every non-plainObject and non-plainArray reachable by traversing
      the plainObject/plainArray structure
      If f is called on a propery of a plainObject, the key for that property is also passed in.
  OUT: value
   */

  Types.deepEach = deepEach = function(v, f, key) {
    var j, k, len, subV;
    if (isPlainArray(v)) {
      for (j = 0, len = v.length; j < len; j++) {
        subV = v[j];
        deepEach(subV, f);
      }
    } else if (isPlainObject(v)) {
      for (k in v) {
        subV = v[k];
        deepEach(subV, f, k);
      }
    } else {
      f(v, key);
    }
    return v;
  };


  /*
  deepEachAll: just like deepEach except 'f' gets called on every value found including the initial value.
   */

  Types.deepEachAll = deepEachAll = function(v, f, key) {
    var j, k, len, subV;
    f(v, key);
    if (isPlainArray(v)) {
      for (j = 0, len = v.length; j < len; j++) {
        subV = v[j];
        deepEachAll(subV, f);
      }
    } else if (isPlainObject(v)) {
      for (k in v) {
        subV = v[k];
        deepEachAll(subV, f, k);
      }
    } else {

    }
    return v;
  };


  /*
  only creates a new array if the children changed
   */

  deepMapArray = function(array, mapper, options) {
    var i, j, len, r, res, v;
    res = null;
    for (i = j = 0, len = array.length; j < len; i = ++j) {
      v = array[i];
      r = deepMap(v, mapper, options);
      if (r !== v) {
        res || (res = array.slice());
        res[i] = r;
      }
    }
    return res || array;
  };

  cloneObjectUpToKey = function(obj, k) {
    var k2, res, v;
    res = {};
    for (k2 in obj) {
      v = obj[k2];
      if (k2 === k) {
        break;
      }
      res[k2] = v;
    }
    return res;
  };

  deepMapObject = function(obj, mapper, options) {
    var k, r, res, v;
    res = null;
    for (k in obj) {
      v = obj[k];
      r = deepMap(v, mapper, options);
      if (r !== v || res) {
        res || (res = cloneObjectUpToKey(obj, k));
        res[k] = r;
      }
    }
    return res || obj;
  };

  noopMapper = function(v) {
    return v;
  };


  /*
  Applies "f" to every -value- in a nested structure of plain arrays and objects.
  Pure functional efficient:
    If an array or object, and all its sub values, didn't change, the original array/object is reused.
  
  NOTE: deepMap only yields values to 'mapper' which are NOT plain arrays nor plain objects.
   */

  Types.deepMap = deepMap = function(v, mapper, options) {
    var arrayMapper, objectMapper;
    arrayMapper = (options != null ? options.arrays : void 0) || noopMapper;
    objectMapper = (options != null ? options.objects : void 0) || noopMapper;
    mapper || (mapper = noopMapper);
    if (isPlainArray(v)) {
      return deepMapArray(arrayMapper(v), mapper, options);
    } else if (isPlainObject(v)) {
      return deepMapObject(objectMapper(v), mapper, options);
    } else {
      return mapper(v);
    }
  };

  Types.toPlainStructure = function(o) {
    return deepMap(o, function(o) {
      if (isObject(o)) {
        if (o.toPlainStructure) {
          return o.toPlainStructure();
        } else {
          return objectName(o);
        }
      } else {
        return o;
      }
    });
  };


  /*
  similar to toPlainStructure, except all non-JSON types are converted to strings
   */

  Types.toJsonStructure = toJsonStructure = function(o) {
    return deepMap(o, function(o) {
      if (isObject(o)) {
        if (o.toJsonStructure) {
          return o.toJsonStructure();
        } else {
          return toJsonStructure(o.toPlainStructure ? o.toPlainStructure() : "" + o);
        }
      } else if (isJsonAtomicType(o)) {
        return o;
      } else {
        return "" + o;
      }
    });
  };

  Types.toPostMessageStructure = toPostMessageStructure = function(o) {
    return deepMap(o, function(o) {
      switch (o.constructor) {
        case ArrayBuffer:
        case Date:
        case RegExp:
        case Blob:
        case File:
        case FileList:
        case ImageData:
        case Boolean:
        case String:
          return o;
        default:
          if (isObject(o)) {
            if (o.toPostMessageStructure) {
              return o.toPostMessageStructure();
            } else {
              if (o.toPlainStructure) {
                return toPostMessageStructure(o.toPlainStructure());
              } else {
                return "" + o;
              }
            }
          } else {
            return "" + o;
          }
      }
    });
  };

  return Types;

})();


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(281);


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(280);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(140);

module.exports.includeInNamespace(__webpack_require__(260)).addModules({
  ArrayCompactFlatten: __webpack_require__(43),
  Merge: __webpack_require__(138),
  StringCase: __webpack_require__(139),
  Types: __webpack_require__(26)
});


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var ref, ref1;

module.exports = (ref = typeof Neptune !== "undefined" && Neptune !== null ? (ref1 = Neptune.Art) != null ? ref1.CommunicationStatus : void 0 : void 0) != null ? ref : __webpack_require__(206);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Filter, Foundation, Promise, Request, Response, Validator, config, defineModule, getInspectedObjects, isPlainObject, log, merge, mergeInto, normalizeFields, shallowClone, success, toInspectedObjects, toPlainObjects,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Request = __webpack_require__(37);

Response = __webpack_require__(62);

config = __webpack_require__(11).config;

toPlainObjects = Foundation.toPlainObjects, Validator = Foundation.Validator, toInspectedObjects = Foundation.toInspectedObjects, getInspectedObjects = Foundation.getInspectedObjects, defineModule = Foundation.defineModule, BaseObject = Foundation.BaseObject, Promise = Foundation.Promise, log = Foundation.log, isPlainObject = Foundation.isPlainObject, mergeInto = Foundation.mergeInto, merge = Foundation.merge, shallowClone = Foundation.shallowClone, CommunicationStatus = Foundation.CommunicationStatus;

success = CommunicationStatus.success;

normalizeFields = Validator.normalizeFields;


/*
TODO

Filters should be able to detect if they are being run server-side or client-side.
  This is a simple global value, since the entire code-base is either running in Node or in the Browser.
  It doesn't change at runtime - duh!
  So, I think we should have a value like: Art.Ery.location, which is set at init-time
  to the code-base's running location.

  WHY do we need this? Filters may want to run on both AND run a little differently on both.

    LinkFieldsFilter, for example, would translate a linked field {foo: id: 123} to {fooId: 123} and not need
    to transmit the whole foo-record over the wire. BUT, if the data was {foo: username: "hi"}, that indicates
    a new foo-record should be created, and that should be done server-side.

    IT's a little thing right now, so I'm not implementing it... yet

  WHY PART 2

    This may be the solution to Filters which are not symmetrical. It's possible the before-part should be
    client-side-only, but the after-part should be server-side-only (for example).

    We could add @beforeLocation and @afterLocation props, but maybe this one solution is "good enough" for everything.
    The only down-side is it isn't as clear in the ArtEry-Pipeline report, but that may be OK since it doesn't seem like
    it'll be used that much.

Art.Ery.location values:
  "server"
  "client"
  "both" - this is the "serverless" mode, it's all run client-side, but it includes both client-side and server-side filters.

SBD:
  location: 'client' filters WILL run server-side for server-initiated requests.
  Maybe 'client' should be 'requester' instead of 'client'? 'requester' and 'server'?
 */

defineModule(module, Filter = (function(superClass) {
  var locationNames;

  extend(Filter, superClass);

  Filter.extendableProperty({

    /*
    @after: foo: (request) ->
      IN: Request instance
      OUT: return a Promise returning one of the list below OR just return one of the list below:
        Request instance
        Response instance
        anythingElse -> toResponse anythingElse
    
      To reject a request:
      - throw an error
      - return a rejected promise
      - or create a Response object with the appropriate fields
     */
    before: {},

    /*
    @before: foo: (response) ->
      IN: Request instance
      OUT: return a Promise returning one of the list below OR just return one of the list below:
        Request instance
        Response instance
        anythingElse -> toResponse anythingElse
    
      To reject a request:
      - throw an error
      - return a rejected promise
      - or create a Response object with the appropriate fields
     */
    after: {}
  });


  /*
  fields
   */

  Filter.extendableProperty({
    fields: {}
  }, {
    extend: function(oldFields, addFields) {
      return merge(oldFields, normalizeFields(addFields));
    }
  });

  Filter.extendableProperty({
    filterFailures: false

    /*
    location: determine if the filter will run on the 'server', 'client' or 'both'.
     */
  });

  Filter.locationNames = locationNames = {
    server: true,
    client: true,
    both: true
  };

  Filter.extendableProperty({
    location: "server"
  }, {
    extend: function(__, v) {
      if (!locationNames[v]) {
        throw new Error("invalid location: " + v);
      }
      return v;
    }

    /*
    Filter Groups: default: "middle"
    
    Filter sequence, based on groups:
      loggers beforeFilter
        outter beforeFilter
          middle beforeFilter
            inner beforeFilter
              handler
            inner afterFilter
          middle afterFilter
        outter afterFilter
      loggers afterFilter
     */
  });

  Filter.groupNames = {
    loggers: 2,
    outter: 1,
    middle: 0,
    inner: -1
  };

  Filter.extendableProperty({
    group: Filter.groupNames.middle
  }, {
    extend: function(__, v) {
      var value;
      if (v != null) {
        if ((value = Filter.groupNames[v]) == null) {
          throw new Error("invalid Filter group: " + v);
        }
        return value;
      } else {
        return 0;
      }
    }
  });

  function Filter(options) {
    var ref;
    if (options == null) {
      options = {};
    }
    Filter.__super__.constructor.apply(this, arguments);
    this.serverSideOnly = options.serverSideOnly, this.clientSideOnly = options.clientSideOnly, this.name = (ref = options.name) != null ? ref : this["class"].getName(), this.location = options.location, this.fields = options.fields, this.group = options.group, this.filterFailures = options.filterFailures, this.after = options.after, this.before = options.before;
    this._nextHandler = null;
  }

  Filter.property("name");

  Filter.getter("nextHandler");

  Filter.setter({
    nextHandler: function(v) {
      if (this._nextHandler !== null) {
        throw new Error;
      }
      return this._nextHandler = v;
    }
  });

  Filter.prototype.shouldFilter = function(processingLocation) {
    switch (this.location) {
      case "server":
        return processingLocation !== "client";
      case "client":
        return processingLocation !== "server";
      case "both":
        return true;
      default:
        throw new Error("Filter " + (this.getName()) + ": invalid filter location: " + location);
    }
  };

  Filter.prototype.toString = function() {
    return this.getName();
  };

  Filter.prototype.getBeforeFilter = function(arg) {
    var location, requestType;
    requestType = arg.requestType, location = arg.location;
    return this.shouldFilter(location) && (this.before[requestType] || this.before.all);
  };

  Filter.prototype.getAfterFilter = function(arg) {
    var location, requestType;
    requestType = arg.requestType, location = arg.location;
    return this.shouldFilter(location) && (this.after[requestType] || this.after.all);
  };

  Filter.prototype.processBefore = function(request) {
    return this.applyHandler(request, this.getBeforeFilter(request));
  };

  Filter.prototype.processAfter = function(request) {
    return this.applyHandler(request, this.getAfterFilter(request));
  };

  Filter.prototype.handleRequest = function(request) {
    return this.processBefore(request).then((function(_this) {
      return function(request) {
        var ref;
        if (request.isResponse) {
          return request;
        } else {
          return (((ref = _this.nextHandler) != null ? ref.handleRequest(request) : void 0) || request.missing("no Handler for request type: " + request.type)).then(function(response) {
            if (response.isSuccessful || _this.filterFailures) {
              return _this.processAfter(response);
            } else {
              return response;
            }
          });
        }
      };
    })(this));
  };

  Filter.getter({
    logName: function() {
      return this.getName();
    },
    inspectedObjects: function() {
      var obj;
      return (
        obj = {},
        obj[(this.getNamespacePath()) + "(" + this.name + ")"] = toInspectedObjects(this.props),
        obj
      );
    },
    props: function() {
      return {
        location: this.location
      };
    }
  });

  return Filter;

})(__webpack_require__(61)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Config, Configurable, defineModule, formattedInspect, log, merge, mergeInto, newObjectFromEach, objectHasKeys, ref, select,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), merge = ref.merge, log = ref.log, objectHasKeys = ref.objectHasKeys, formattedInspect = ref.formattedInspect, defineModule = ref.defineModule, select = ref.select, newObjectFromEach = ref.newObjectFromEach, mergeInto = ref.mergeInto, Configurable = ref.Configurable;

defineModule(module, Config = (function(superClass) {
  var awsServiceToConfigNameMap;

  extend(Config, superClass);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }

  Config.defaults({
    credentials: {
      accessKeyId: 'blah',
      secretAccessKey: 'blah'
    },
    region: 'us-east-1',
    s3Buckets: {},
    dynamoDb: {
      maxRetries: 5
    },
    sqs: {
      queueUrlPrefix: null
    }
  });

  Config.awsServiceToConfigNameMap = awsServiceToConfigNameMap = {
    es: "elasticsearch"
  };


  /*
  Search order:
    @config[service].credentials
    @config[awsServiceToConfigNameMap[service]].credentials
    @config.credentials
   */

  Config.getAwsCredentials = function(service) {
    var ref1;
    return ((ref1 = Config.getAwsServiceConfig(service)) != null ? ref1.credentials : void 0) || Config.config.credentials;
  };

  Config.getAwsServiceConfig = function(service) {
    return Config.config[service] || Config.config[awsServiceToConfigNameMap[service]];
  };

  Config.getNormalizedConfig = function(forService, options) {
    var config, defaultCredentials, rawServiceConfig;
    defaultCredentials = Config.getDefaultConfig().credentials;
    rawServiceConfig = Config.getAwsServiceConfig(forService);
    config = merge({
      accessKeyId: Config.config.credentials.accessKeyId,
      secretAccessKey: Config.config.credentials.secretAccessKey,
      region: Config.config.region,
      maxRetries: 5
    }, rawServiceConfig != null ? rawServiceConfig.credentials : void 0, rawServiceConfig, options);
    if (config.accessKeyId === defaultCredentials.accessKeyId && !config.endpoint) {
      log.error("Art.Aws invalid configuration for " + forService + ".\n\nPlease set one of:\n- Art.Aws.credentails for connection to AWS\n- Art.Aws." + forService + ".endpoint for connection to a local server.\n\n" + (options && objectHasKeys(options) ? formattedInspect({
        "Art.Aws.config": Config.config,
        options: options,
        "merged config": config
      }) : formattedInspect({
        "Art.Aws.config": Config.config,
        "merged config": config
      })) + "\n");
      throw new Error("invalid config options");
    }
    return config;
  };

  return Config;

})(Configurable));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Config, Configurable, Validator, defineModule, mergeInto, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), w = ref.w, Validator = ref.Validator, defineModule = ref.defineModule, mergeInto = ref.mergeInto, BaseObject = ref.BaseObject, Configurable = ref.Configurable;

defineModule(module, Config = (function(superClass) {
  extend(Config, superClass);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }

  Config.defaults({
    tableNamePrefix: "",
    location: "both",
    apiRoot: "api",

    /*
    remoteServer examples:
      "http://localhost:8085"
      "http://domain.com"
      "https://domain.com"
      "//domain.com"  # this ensures the request stays HTTP or HTTPS based on the original html request
      true
    
    If remoteServer is true
      requests will still go to the remote server
      The remote URL, though, will just be "#{apiRoot}/..."
    
      This is a good setting for apps loaded from an HTML page on the same
      server as the remote-API.
     */
    remoteServer: null,
    verbose: false,
    returnProcessingInfoToClient: false,

    /*
      generating a secury HMAC privateSessionKey:
    
      in short, run: openssl rand -base64 16
    
      http://security.stackexchange.com/questions/95972/what-are-requirements-for-hmac-secret-key
      Recommends 128bit string generated with a "cryptographically
      secure pseudo random number generator (CSPRNG)."
    
      http://osxdaily.com/2011/05/10/generate-random-passwords-command-line/
       * 128 bits:
      > openssl rand -base64 16
    
       * 256 bits:
      > openssl rand -base64 32
     */
    server: {
      privateSessionKey: "todo+generate+your+one+unique+key"
    }
  });

  Config.getPrefixedTableName = function(tableName) {
    return "" + Config.config.tableNamePrefix + tableName;
  };

  return Config;

})(Configurable));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, TableApiBaseClass, apiConstantsMap, compact, inspect, isBoolean, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, upperCamelCase, wordsArray;

Foundation = __webpack_require__(2);

log = Foundation.log, lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isString = Foundation.isString, isPlainArray = Foundation.isPlainArray, isPlainObject = Foundation.isPlainObject, isNumber = Foundation.isNumber, isBoolean = Foundation.isBoolean, inspect = Foundation.inspect, upperCamelCase = Foundation.upperCamelCase, compact = Foundation.compact;

apiConstantsMap = __webpack_require__(53).apiConstantsMap;

module.exports = TableApiBaseClass = (function() {
  var decodeDynamoData;

  function TableApiBaseClass() {
    this._uniqueExpressionAttributeId = 0;
    this._target = {};
  }


  /*
  IN: params: plain object
    if params.TableName is set, assume it is the standard DynamoDb API - pass directly through.
   */

  TableApiBaseClass.prototype.translateParams = function(params) {
    if (params.TableName) {
      return params;
    }
    this._translateTableName(params);
    this._translateParams(params);
    return this._target;
  };

  TableApiBaseClass.translateParams = function(params) {
    return new this().translateParams(params);
  };

  TableApiBaseClass.decodeDynamoData = decodeDynamoData = function(data) {
    var array, bool, i, k, len, map, number, out, results, string, v;
    if (map = data.M) {
      out = {};
      for (k in map) {
        v = map[k];
        out[k] = decodeDynamoData(v);
      }
      return out;
    } else if (array = data.L) {
      results = [];
      for (i = 0, len = array.length; i < len; i++) {
        v = array[i];
        results.push(decodeDynamoData(v));
      }
      return results;
    } else if (string = data.S) {
      return string;
    } else if ((number = data.N) != null) {
      return parseFloat(number);
    } else if ((bool = data.BOOL) != null) {
      return !!bool;
    } else if (data.NULL) {
      return null;
    } else {
      throw new Error("unknown dynamo data type: " + (inspect(data)));
    }
  };

  TableApiBaseClass.decodeDynamoItem = function(item) {
    var k, out, v;
    out = {};
    for (k in item) {
      v = item[k];
      out[k] = decodeDynamoData(v);
    }
    return out;
  };

  TableApiBaseClass.prototype._translateParams = function() {};

  TableApiBaseClass.prototype._encodeDynamoData = function(data) {
    var k, ret, v, values;
    return ret = (function() {
      if (isPlainObject(data)) {
        values = {};
        for (k in data) {
          v = data[k];
          if (v !== void 0) {
            values[k] = this._encodeDynamoData(v);
          }
        }
        return {
          M: values
        };
      } else if (isPlainArray(data)) {
        return {
          L: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = data.length; i < len; i++) {
              v = data[i];
              if (v !== void 0) {
                results.push(this._encodeDynamoData(v));
              }
            }
            return results;
          }).call(this)
        };
      } else if (isBoolean(data)) {
        return {
          BOOL: data
        };
      } else if (isString(data)) {
        return {
          S: data
        };
      } else if (isNumber(data)) {
        return {
          N: data.toString()
        };
      } else if (data === null) {
        return {
          NULL: true
        };
      } else {
        throw new Error("invalid data type: " + (inspect(data)));
      }
    }).call(this);
  };

  TableApiBaseClass.prototype._decodeDynamoData = decodeDynamoData;

  TableApiBaseClass.prototype._encodeItem = function(item) {
    return this._encodeDynamoData(item).M;
  };

  TableApiBaseClass.prototype._addExpressionAttributeValue = function(key, value) {
    var base;
    return ((base = this._target).ExpressionAttributeValues || (base.ExpressionAttributeValues = {}))[key] = this._encodeDynamoData(value);
  };

  TableApiBaseClass.prototype._addExpressionAttributeName = function(attributeAlias, attributeName) {
    var base;
    return ((base = this._target).ExpressionAttributeNames || (base.ExpressionAttributeNames = {}))[attributeAlias] = attributeName;
  };

  TableApiBaseClass.prototype._getNextUniqueExpressionAttributeId = function() {
    return this._uniqueExpressionAttributeId = (this._uniqueExpressionAttributeId || 0) + 1;
  };

  TableApiBaseClass.prototype._translateConsistentRead = function(params) {
    if (params.consistentRead) {
      return this._target.ConsistentRead = true;
    }
  };

  TableApiBaseClass.prototype._translateConsumedCapacity = function(params) {
    return this._translateConstantParam(params, "returnConsumedCapacity");
  };

  TableApiBaseClass.prototype._translateSelect = function(params) {
    var select;
    select = params.select;
    if (!select) {
      return this._target;
    }
    switch (select) {
      case "*":
        this._target.Select = "ALL_ATTRIBUTES";
        break;
      case "count(*)":
        this._target.Select = "COUNT";
        break;
      default:
        if (isString(select)) {
          select = select.match(/[a-z0-9\[\].]+/gi);
        }
        this._target.ProjectionExpression = select.join(', ');
        "SPECIFIC_ATTRIBUTES";
    }
    return this._target;
  };

  TableApiBaseClass.prototype._translateConditionExpression = function(conditionExpression) {
    var attributeAlias, attributeName, expressions, ret, subExpression, test, uniqueId;
    ret = isPlainArray(conditionExpression) ? (expressions = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = conditionExpression.length; i < len; i++) {
        subExpression = conditionExpression[i];
        if (isString(subExpression)) {
          results.push(subExpression);
        } else {
          results.push(this._translateConditionExpression(subExpression));
        }
      }
      return results;
    }).call(this), compact(expressions).join(' ')) : (expressions = (function() {
      var results;
      results = [];
      for (attributeName in conditionExpression) {
        test = conditionExpression[attributeName];
        uniqueId = this._getNextUniqueExpressionAttributeId(this._target);
        attributeAlias = "#attr" + uniqueId;
        this._addExpressionAttributeName(attributeAlias, attributeName);
        results.push(this._translateConditionExpressionField(attributeAlias, test, uniqueId));
      }
      return results;
    }).call(this), expressions.join(' AND '));
    if ("()" === (ret = "(" + ret + ")")) {
      return null;
    } else {
      return ret;
    }
  };

  TableApiBaseClass.prototype._translateConditionExpressionField = function(attributeAlias, test, uniqueId) {
    var expression, gte, gteAlias, lte, lteAlias, value, valueAlias;
    valueAlias = ":val" + uniqueId;
    if (test && (gte = test.gte) && (lte = test.lte)) {
      this._addExpressionAttributeValue((gteAlias = valueAlias + "Gte"), gte);
      this._addExpressionAttributeValue((lteAlias = valueAlias + "Lte"), lte);
      return attributeAlias + " BETWEEN " + gteAlias + " AND " + lteAlias;
    } else {
      expression = (function() {
        if (!isPlainObject(value = test)) {
          return attributeAlias + " = " + valueAlias;
        } else if ((value = test.eq) != null) {
          return attributeAlias + " = " + valueAlias;
        } else if ((value = test.lt) != null) {
          return attributeAlias + " < " + valueAlias;
        } else if ((value = test.gt) != null) {
          return attributeAlias + " > " + valueAlias;
        } else if ((value = test.lte) != null) {
          return attributeAlias + " <= " + valueAlias;
        } else if ((value = test.gte) != null) {
          return attributeAlias + " >= " + valueAlias;
        } else if ((value = test.beginsWith) != null) {
          return "begines_with(" + attributeAlias + ", " + valueAlias + ")";
        } else {
          throw new Error("no valid test detected in: " + attributeAlias + ": " + (inspect(test)));
        }
      })();
      this._addExpressionAttributeValue(valueAlias, value);
      return expression;
    }
  };

  TableApiBaseClass.prototype._translateConditionExpressionParam = function(params) {
    var conditionExpression, expr;
    conditionExpression = params.conditionExpression;
    if (!conditionExpression) {
      return this._target;
    }
    if (expr = this._translateConditionExpression(conditionExpression)) {
      this._target.ConditionExpression = expr;
    }
    return this._target;
  };

  TableApiBaseClass.prototype._translateKey = function(params) {
    var k, key, out, v;
    key = params.key;
    if (!key) {
      throw new Error("key required");
    }
    out = {};
    if (isString(key)) {
      key = {
        id: key
      };
    }
    for (k in key) {
      v = key[k];
      out[k] = this._encodeDynamoData(v);
    }
    return this._target.Key = out;
  };

  TableApiBaseClass.prototype._translateTableName = function(arg) {
    var table, tableName;
    table = arg.table, tableName = arg.tableName;
    if (!(table || tableName)) {
      throw new Error("table or tableName required");
    }
    return this._target.TableName = tableName || table;
  };

  TableApiBaseClass.prototype._translateIndexName = function(params) {
    if (params.index) {
      return this._target.IndexName = params.index;
    }
  };

  TableApiBaseClass.prototype._normalizeConstant = function(constant, _default) {
    var ret;
    if (!(ret = apiConstantsMap[constant] || _default)) {
      throw new Error("constant '" + constant + "' not found/supported");
    }
    return ret;
  };

  TableApiBaseClass.prototype._translateConstantParam = function(params, paramName, _default) {
    var dynamoDbName, value;
    dynamoDbName = upperCamelCase(paramName);
    value = params[paramName] || _default;
    if (value) {
      return this._target[dynamoDbName] = this._normalizeConstant(value);
    }
  };

  return TableApiBaseClass;

})();


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(113);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, Binary, BinaryString, ClassSystem, InspectedObjectLiteral, Promise, StandardLib, Utf8, compactFlatten, encodings, inspect, isFunction, isPlainArray, isString, log, min, pad, readFileAsArrayBuffer, readFileAsDataUrl,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Binary = __webpack_require__(39);

Utf8 = __webpack_require__(123);

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

isString = StandardLib.isString, isFunction = StandardLib.isFunction, isPlainArray = StandardLib.isPlainArray, log = StandardLib.log, min = StandardLib.min, inspect = StandardLib.inspect, readFileAsDataUrl = StandardLib.readFileAsDataUrl, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, compactFlatten = StandardLib.compactFlatten, pad = StandardLib.pad, InspectedObjectLiteral = StandardLib.InspectedObjectLiteral, Promise = StandardLib.Promise;

BaseObject = ClassSystem.BaseObject, inspect = ClassSystem.inspect;

encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

module.exports = BinaryString = (function(superClass) {
  var binary;

  extend(BinaryString, superClass);

  BinaryString.isBinary = function(arg) {
    var ref;
    return arg && ((arg instanceof BinaryString) || arg.constructor === ArrayBuffer || ((ref = arg.buffer) != null ? ref.constructor : void 0) === ArrayBuffer);
  };

  BinaryString.binary = binary = function(arg) {
    if (arg instanceof BinaryString) {
      return arg;
    } else {
      return new BinaryString(arg);
    }
  };

  BinaryString.binaryFromBlob = function(blob) {
    return readFileAsArrayBuffer(blob).then(function(ab) {
      return binary(ab);
    });
  };

  BinaryString.cloneUint8Array = function(srcU8A) {
    var dstU8A;
    dstU8A = new Uint8Array(new ArrayBuffer(src.length));
    dstU8A.set(srcU8A);
    return dstU8A;
  };

  function BinaryString(arg) {
    this.bytes = (function() {
      if (arg == null) {
        return new Uint8Array;
      } else if (arg instanceof BinaryString) {
        return BinaryString.cloneUint8Array(arg.bytes);
      } else if (isFunction(arg != null ? arg.uint8Array : void 0)) {
        return arg.uint8Array();
      } else if (isPlainArray(arg)) {
        return new Uint8Array(arg);
      } else if (arg instanceof ArrayBuffer) {
        return new Uint8Array(arg);
      } else if (arg instanceof Uint8Array) {
        return arg;
      } else if (isString(arg)) {
        return Utf8.toBuffer(arg);
      } else if (isFunction(arg.toString)) {
        return Utf8.toBuffer(arg.toString());
      } else {
        throw new Error("invalid Binary string constructor argument: " + (inspect(arg)));
      }
    })();
    this.length = this.bytes.length;
  }

  BinaryString.prototype.slice = function(a, b) {
    return new BinaryString(this.bytes.slice(a, b));
  };

  BinaryString.fromBase64 = function(base64encoding) {
    var byteString, i, j, len, ref, uint8Array;
    byteString = atob(base64encoding);
    len = byteString.length;
    uint8Array = new Uint8Array(new ArrayBuffer(len));
    for (i = j = 0, ref = len; j < ref; i = j += 1) {
      uint8Array[i] = byteString.charCodeAt(i);
    }
    return new BinaryString(uint8Array);
  };

  BinaryString.prototype.toDataUri = function() {
    return readFileAsDataUrl(new Blob([this.bytes]));
  };

  BinaryString.fromDataUri = function(dataURI) {
    var base64encoding, splitDataURI;
    splitDataURI = dataURI.split(',');
    base64encoding = splitDataURI[1];
    return this.fromBase64(base64encoding);
  };

  BinaryString.prototype.toString = function() {
    return Utf8.toString(this.bytes);
  };

  BinaryString.prototype.getString = function() {
    return this.toString();
  };

  BinaryString.prototype.toArrayBuffer = function() {
    return this.bytes.buffer;
  };

  BinaryString.prototype.toBlob = function() {
    return new Blob([this.bytes]);
  };

  BinaryString.prototype.eq = function(b) {
    return this.compare(b) === 0;
  };

  BinaryString.prototype.compare = function(b) {
    var bytesA, bytesB, diff, i, j, ref;
    bytesA = this.bytes;
    bytesB = b.bytes;
    for (i = j = 0, ref = min(this.length, b.length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (0 !== (diff = bytesA[i] - bytesB[i])) {
        return diff;
      }
    }
    return this.length - b.length;
  };

  BinaryString.prototype.inspect = function() {
    return this.getInspectedString();
  };

  BinaryString.getter({
    uint8Array: function() {
      return this.bytes;
    },
    arrayBuffer: function() {
      return this.bytes.buffer;
    },
    nodeBuffer: function() {
      return new Buffer(this.bytes);
    },
    blob: function() {
      return new Blob([this.bytes]);
    },
    plainArray: function() {
      var b, j, len1, ref, results;
      ref = this.bytes;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        b = ref[j];
        results.push(b);
      }
      return results;
    },
    byteLength: function() {
      return this.length;
    },
    inspectedObjects: function() {
      var lenStr;
      lenStr = this.length >= 10 * 1024 * 1024 ? (Math.floor(this.length / 1024 * 1024)) + "m" : this.length >= 10 * 1024 ? (Math.floor(this.length / 1024)) + "k" : this.length + "b";
      return new InspectedObjectLiteral("<BinaryString length: " + lenStr + ">");
    },
    inspectedString: function(stride, maxBytes) {
      var characters, count, line, offset;
      if (stride == null) {
        stride = 8;
      }
      if (maxBytes == null) {
        maxBytes = 64;
      }
      count = 0;
      characters = [];
      if (this.length < maxBytes) {
        maxBytes = this.length;
      }
      line = new Array(stride);
      return compactFlatten([
        "BinaryString length: " + this.length + " bytes", maxBytes < this.length ? "First " + maxBytes + " bytes:" : void 0, (function() {
          var j, ref, ref1, results;
          results = [];
          for (offset = j = 0, ref = maxBytes, ref1 = stride; ref1 > 0 ? j < ref : j > ref; offset = j += ref1) {
            results.push(this._inspectLine(offset, stride, maxBytes));
          }
          return results;
        }).call(this)
      ]).join('\n');
    }
  });

  BinaryString.prototype._inspectLine = function(offset, length, maxBytes) {
    var b, characters, end, hexCharacters, i, y;
    end = min(this.length, offset + length);
    if (maxBytes >= 0) {
      end = min(end, maxBytes);
    }
    characters = (function() {
      var j, ref, ref1, results;
      results = [];
      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
        b = this.bytes[i];
        if (b >= 31 && b <= 127) {
          results.push(String.fromCharCode(b));
        } else {
          results.push('â€¢');
        }
      }
      return results;
    }).call(this);
    hexCharacters = (function() {
      var j, ref, ref1, results;
      results = [];
      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
        b = this.bytes[i];
        y = b.toString(16);
        if (y.length < 2) {
          y = "0" + y;
        }
        results.push(y);
      }
      return results;
    }).call(this);
    return (pad(hexCharacters.join(' '), length * 3)) + " '" + (characters.join('')) + "'";
  };


  /*
  toBase64 performance
  see: http://localhost:8080/webpack-dev-server/perf?grep=BinaryString
  as-of 2016-02-14, the manual string manipulation version is surprisingly the best on average for FF, Chrome and Safari
    For shorter lengths, toBase64Custom is by far the fastest, but
    toBase64ToDataUri starts to be faster at longer lengths.
   */

  BinaryString.prototype.toBase64 = function() {
    if (this.length > 16 * 1024) {
      return this.toBase64ToDataUri();
    } else {
      return this.toBase64Custom();
    }
  };

  BinaryString.prototype.toBase64ToDataUri = function() {
    return this.toDataUri().then(function(dataUri) {
      return dataUri.split(',')[1];
    });
  };

  BinaryString.prototype.toBase64Custom = function() {
    var a, b, base64, byteLength, byteRemainder, bytes, c, chunk, d, i, j, mainLength, ref;
    bytes = this.bytes;
    base64 = '';
    byteLength = bytes.byteLength;
    byteRemainder = byteLength % 3;
    mainLength = byteLength - byteRemainder;
    for (i = j = 0, ref = mainLength - 1; j <= ref; i = j += 3) {
      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
      a = (chunk & 16515072) >> 18;
      b = (chunk & 258048) >> 12;
      c = (chunk & 4032) >> 6;
      d = chunk & 63;
      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    }
    return Promise.resolve((function() {
      switch (byteRemainder) {
        case 0:
          return base64;
        case 1:
          chunk = bytes[mainLength];
          a = (chunk & 252) >> 2;
          b = (chunk & 3) << 4;
          return base64 + encodings[a] + encodings[b] + '==';
        case 2:
          chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
          a = (chunk & 64512) >> 10;
          b = (chunk & 1008) >> 4;
          c = (chunk & 15) << 2;
          return base64 + encodings[a] + encodings[b] + encodings[c] + '=';
      }
    })());
  };

  return BinaryString;

})(BaseObject);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var MinimalBaseObject, capitalize, isFunction, isPlainObject, isString, ref;

capitalize = __webpack_require__(7).capitalize;

ref = __webpack_require__(4), isFunction = ref.isFunction, isString = ref.isString, isPlainObject = ref.isPlainObject;

module.exports = MinimalBaseObject = (function() {
  var addGetter, addGetters, addProperties, addSetter, addSetters, defProperties, defProperty, propGetterName, propInternalName, propListStringToArray, propSetterName;

  function MinimalBaseObject() {}

  MinimalBaseObject.propInternalName = propInternalName = function(prop) {
    return "_" + prop;
  };


  /*
  IN: arguments is a list of strings or objects
    strings: are just the names of the properties
    objects: map from prop names to getter/setter functions
   */

  MinimalBaseObject.getter = function() {
    return defProperties(this.prototype, arguments, true, false);
  };

  MinimalBaseObject.setter = function() {
    return defProperties(this.prototype, arguments, false, true);
  };

  MinimalBaseObject.addGetter = function(prop, getter) {
    return this._addGetter(this.prototype, prop, getter);
  };

  MinimalBaseObject.addSetter = function(prop, setter) {
    return this._addSetter(this.prototype, prop, setter);
  };

  MinimalBaseObject.addClassGetter = function(prop, getter) {
    return this._addGetter(this, prop, getter);
  };

  MinimalBaseObject.addClassSetter = function(prop, setter) {
    return this._addSetter(this, prop, setter);
  };


  /*
  IN: arguments is a list of strings or objects
    strings: are just the names of the properties
    objects: map from prop names to initializers
   */

  MinimalBaseObject.property = function() {
    return defProperties(this.prototype, arguments, true, true);
  };

  MinimalBaseObject.classGetter = function() {
    return defProperties(this, arguments, true, false);
  };

  MinimalBaseObject.classSetter = function() {
    return defProperties(this, arguments, false, true);
  };

  MinimalBaseObject.classProperty = function() {
    return defProperties(this, arguments, true, true);
  };

  MinimalBaseObject._propGetterName = propGetterName = function(prop) {
    return "get" + capitalize(prop);
  };

  MinimalBaseObject._propSetterName = propSetterName = function(prop) {
    return "set" + capitalize(prop);
  };

  MinimalBaseObject._addGetter = addGetter = function(obj, prop, getter) {
    obj[propGetterName(prop)] = getter;
    if (!isFunction(getter)) {
      getter = (function() {
        return getter;
      });
    }
    Object.defineProperty(obj, prop, {
      get: getter,
      configurable: true
    });
    return prop;
  };

  MinimalBaseObject._addSetter = addSetter = function(obj, prop, setter) {
    obj[propSetterName(prop)] = setter;
    Object.defineProperty(obj, prop, {
      set: setter,
      configurable: true
    });
    return prop;
  };

  MinimalBaseObject._addGetters = addGetters = function(obj, map) {
    var getter, prop;
    for (prop in map) {
      getter = map[prop];
      addGetter(obj, prop, getter);
    }
    return map;
  };

  MinimalBaseObject._addSetters = addSetters = function(obj, map) {
    var prop, setter;
    for (prop in map) {
      setter = map[prop];
      addSetter(obj, prop, setter);
    }
    return map;
  };

  MinimalBaseObject._addProperties = addProperties = function(obj, map) {
    var initializer, prop;
    for (prop in map) {
      initializer = map[prop];
      defProperty(obj, prop, true, true, initializer);
    }
    return map;
  };

  MinimalBaseObject._defProperty = defProperty = function(obj, prop, defineGetter, defineSetter, initializer) {
    var propName;
    propName = propInternalName(prop);
    if (defineGetter) {
      addGetter(obj, prop, obj[propGetterName(prop)] = isFunction(initializer) ? function() {
        if (this[propName] != null) {
          return this[propName];
        } else {
          return this[propName] = initializer();
        }
      } : initializer != null ? function() {
        if (this[propName] != null) {
          return this[propName];
        } else {
          return this[propName] = initializer;
        }
      } : function() {
        return this[propName];
      });
    }
    if (defineSetter) {
      return addSetter(obj, prop, function(v) {
        return this[propName] = v;
      });
    }
  };

  MinimalBaseObject._defProperties = defProperties = function(obj, props, defineGetter, defineSetter) {
    var i, len, prop, propFromString, propMap, results;
    results = [];
    for (i = 0, len = props.length; i < len; i++) {
      prop = props[i];
      if (isPlainObject(propMap = prop)) {
        if (defineGetter && defineSetter) {
          results.push(addProperties(obj, propMap));
        } else if (defineGetter) {
          results.push(addGetters(obj, propMap));
        } else {
          results.push(addSetters(obj, propMap));
        }
      } else if (isString(prop)) {
        results.push((function() {
          var j, len1, ref1, results1;
          ref1 = propListStringToArray(prop);
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            propFromString = ref1[j];
            results1.push(defProperty(obj, propFromString, defineGetter, defineSetter, null));
          }
          return results1;
        })());
      } else {
        throw new Error("invalid value. Expected string or plain-object:", prop);
      }
    }
    return results;
  };

  MinimalBaseObject._propListStringToArray = propListStringToArray = function(propList) {
    return propList.match(/[_a-z][_a-z0-9]*/gi);
  };

  return MinimalBaseObject;

})();


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var FoundationMath, StringExtensions, Types, compactFlatten, escapedDoubleQuoteRegex, floor, intRand, isArray, isBrowser, isNumber, isPlainObject, isString, wordsRegex;

FoundationMath = __webpack_require__(24);

Types = __webpack_require__(4);

wordsRegex = __webpack_require__(30).wordsRegex;

intRand = FoundationMath.intRand;

isString = Types.isString, isNumber = Types.isNumber, isPlainObject = Types.isPlainObject, isArray = Types.isArray;

compactFlatten = __webpack_require__(7).compactFlatten;

isBrowser = __webpack_require__(27).isBrowser;

escapedDoubleQuoteRegex = /[\\]["]/g;

floor = Math.floor;

module.exports = StringExtensions = (function() {
  var base62Characters, consistentJsonStringify, crypto, escapeDoubleQuoteJavascriptString, escapeJavascriptString, getPadding, jsStringifyR, pluralize, randomString, repeat, standardIndent;

  function StringExtensions() {}


  /*
  IN: an array and optionally a string, in any order
    joiner: the string
    array-to-flatten-and-join: the array
  
  OUT:
    compactFlatten(array).join joiner || ""
  
  NOTE: this uses Ruby's default value for joining - the empty array, not ',' which is JavaScripts
   */

  StringExtensions.compactFlattenJoin = function(a, b) {
    var array, joiner;
    array = null;
    joiner = isString(a) ? (array = b, a) : (array = a, b || "");
    return compactFlatten(array).join(joiner);
  };

  StringExtensions.base62Characters = base62Characters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

  StringExtensions.randomString = randomString = function(length, chars, randomNumbers) {
    var charsLength, i, result;
    if (length == null) {
      length = 32;
    }
    if (chars == null) {
      chars = base62Characters;
    }
    result = '';
    charsLength = chars.length;
    if (randomNumbers) {
      return ((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = length; j < ref; i = j += 1) {
          results.push(chars[randomNumbers[i] % charsLength]);
        }
        return results;
      })()).join('');
    } else {
      return ((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = length; j < ref; i = j += 1) {
          results.push(chars[intRand(charsLength)]);
        }
        return results;
      })()).join('');
    }
  };

  StringExtensions.cryptoRandomString = isBrowser ? ((crypto = global.crypto, global), crypto ? function(l, c) {
    return randomString(l, c, crypto.getRandomValues(new Uint8Array(l)));
  } : (console.warn("window.crypto not available, using standard random for cryptoRandomString"), function(l, c) {
    return randomString(l, c);
  })) : (crypto = __webpack_require__(166), function(l, c) {
    return randomString(l, c, crypto.randomBytes(l));
  });

  StringExtensions.randomBase62Character = function() {
    return base62Characters[intRand(62)];
  };


  /*
  should really use: https://www.npmjs.org/package/pluralize
    pluralize "food" >> "foods"
    pluralize 1, "food" -> "1 food"
    pluralize 0, "food" -> "0 foods"
    pluralize 2, "food" -> "2 foods"
    pluralize 3, "person", people" -> "2 people"
   */

  StringExtensions.pluralize = pluralize = function(a, b, pluralForm) {
    if (isNumber(a)) {
      return a + " " + (a === 1 ? b : pluralForm || pluralize(b));
    } else if (isString(a || (a = b))) {
      return a + "s";
    }
  };

  StringExtensions.replaceLast = function(str, find, replaceWith) {
    var index;
    index = str.lastIndexOf(find);
    if (index >= 0) {
      return str.substring(0, index) + replaceWith + str.substring(index + find.length);
    } else {
      return str.toString();
    }
  };

  StringExtensions.getPadding = getPadding = function(length, padding) {
    if (padding == null) {
      padding = " ";
    }
    return Array(length).join(padding);
  };

  StringExtensions.pad = function(str, length, padding, alignRight) {
    var exactPadding;
    str = String(str);
    if (str.length >= length) {
      return str;
    }
    exactPadding = getPadding(Math.max(length - str.length + 1, 0), padding);
    if (alignRight) {
      return exactPadding + str;
    } else {
      return str + exactPadding;
    }
  };

  StringExtensions.escapeDoubleQuoteJavascriptString = escapeDoubleQuoteJavascriptString = function(str) {
    var s;
    s = String(str).replace(/[\\"]/g, "\\$&").replace(/[\0\b\f\n\r\t\v\u2028\u2029]/g, function(x) {
      switch (x) {
        case '\0':
          return "\\0";
        case '\b':
          return "\\b";
        case '\f':
          return "\\f";
        case '\n':
          return "\\n";
        case '\r':
          return "\\r";
        case '\t':
          return "\\t";
        case '\v':
          return "\\v";
        case '\u2028':
          return "\\u2028";
        case '\u2029':
          return "\\u2029";
      }
    });
    return s = '"' + s + '"';
  };


  /*
  SBD for a while I only had JSON.stringify here, but I hate seeing: "I said, \"hello.\""
  when I could be seeing: 'I said, "hello."'
  
  Is this going to break anything? I figure if you really need "" only, just use stringify.
   */

  StringExtensions.escapeJavascriptString = escapeJavascriptString = function(str) {
    var s;
    s = JSON.stringify(str);
    if (s.match(escapedDoubleQuoteRegex)) {
      return "'" + (s.replace(escapedDoubleQuoteRegex, '"').replace(/'/g, "\\'").slice(1, -1)) + "'";
    } else {
      return s;
    }
  };

  StringExtensions.allIndexes = function(str, regex) {
    var indexes, lastIndex, result;
    indexes = [];
    if (!((regex instanceof RegExp) && regex.global)) {
      throw new Error("regex must be a global RegExp");
    }
    regex.lastIndex = 0;
    while (result = regex.exec(str)) {
      indexes.push(result.index);
      lastIndex = result;
    }
    return indexes;
  };

  StringExtensions.repeat = repeat = " ".repeat ? function(str, times) {
    return str.repeat(times);
  } : function(str, count) {
    var result;
    count === floor(count);
    result = '';
    if (count > 0 && str.length > 0) {
      while (true) {
        if ((count & 1) === 1) {
          result += str;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        str += str;
      }
    }
    return result;
  };

  StringExtensions.rightAlign = function(str, width) {
    if (str.length >= width) {
      return str;
    } else {
      return repeat(" ", width - str.length) + str;
    }
  };

  StringExtensions.eachMatch = function(str, regex, f) {
    var result;
    regex.lastIndex = 0;
    while (result = regex.exec(str)) {
      f(result);
    }
    return null;
  };

  standardIndent = {
    joiner: ', ',
    openObject: '{',
    openArray: '[',
    closeObject: "}",
    closeArray: "]"
  };

  StringExtensions.jsStringify = function(obj) {
    return jsStringifyR(obj, "");
  };

  jsStringifyR = function(o, s) {
    var el, first, j, k, len, v;
    if (isPlainObject(o)) {
      s += "{";
      first = true;
      for (k in o) {
        v = o[k];
        if (first) {
          first = false;
        } else {
          s += ",";
        }
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k)) {
          s += k;
        } else {
          s += JSON.stringify(k);
        }
        s += ":";
        s = jsStringifyR(v, s);
      }
      return s + "}";
    } else if (isArray(o)) {
      s += "[";
      first = true;
      for (j = 0, len = o.length; j < len; j++) {
        el = o[j];
        if (first) {
          first = false;
        } else {
          s += ",";
        }
        s = jsStringifyR(el, s);
      }
      return s + "]";
    } else {
      return s + JSON.stringify(o);
    }
  };

  StringExtensions.consistentJsonStringify = consistentJsonStringify = function(object, indent) {
    var closeArray, closeObject, error, indentObject, joiner, k, lastTotalIndent, openArray, openObject, out, totalIndent, v;
    return out = (function() {
      var ref;
      if (object === false || object === true || object === null || isNumber(object)) {
        return "" + object;
      } else if (isString(object)) {
        return JSON.stringify(object);
      } else {
        indentObject = indent ? typeof indent === "string" ? {
          joiner: ",\n" + indent,
          openObject: "{\n" + indent,
          openArray: "[\n" + indent,
          closeObject: "\n}",
          closeArray: "\n]",
          totalIndent: indent,
          indent: indent
        } : {
          totalIndent: totalIndent = indent.indent + (lastTotalIndent = indent.totalIndent),
          joiner: ",\n" + totalIndent,
          openObject: "{\n" + totalIndent,
          openArray: "[\n" + totalIndent,
          closeObject: "\n" + lastTotalIndent + "}",
          closeArray: "\n" + lastTotalIndent + "]",
          indent: indent.indent
        } : void 0;
        ref = indentObject || standardIndent, joiner = ref.joiner, openObject = ref.openObject, openArray = ref.openArray, closeObject = ref.closeObject, closeArray = ref.closeArray;
        if (isPlainObject(object)) {
          return openObject + ((function() {
            var j, len, ref1, results;
            ref1 = (Object.keys(object)).sort();
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              k = ref1[j];
              if (object[k] !== void 0) {
                results.push(JSON.stringify(k) + ": " + consistentJsonStringify(object[k], indentObject));
              }
            }
            return results;
          })()).join(joiner) + closeObject;
        } else if (isArray(object)) {
          return openArray + ((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = object.length; j < len; j++) {
              v = object[j];
              results.push(consistentJsonStringify(v, indentObject));
            }
            return results;
          })()).join(joiner) + closeArray;
        } else {
          Neptine.Art.StandardLib.log.error(error = "invalid object type for Json. Expecting: null, false, true, number, string, plain-object or array", object);
          throw new Error(error);
        }
      }
    })();
  };

  StringExtensions.splitRuns = function(str) {
    var ch, chCount, i, j, lastCh, ref, result;
    if (str.length === 0) {
      return [];
    }
    lastCh = str[0];
    chCount = 1;
    result = [];
    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
      ch = str[i];
      if (ch === lastCh) {
        chCount++;
      } else {
        result.push([lastCh, chCount]);
        chCount = 1;
      }
      lastCh = ch;
    }
    result.push([lastCh, chCount]);
    return result;
  };

  StringExtensions.eachRunAsCharCodes = function(str, f) {
    var ch, chCount, i, j, lastCh, ref;
    lastCh = str.charCodeAt(0);
    chCount = 1;
    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
      ch = str.charCodeAt(i);
      if (ch === lastCh) {
        chCount++;
      } else {
        f(lastCh, chCount);
        chCount = 1;
      }
      lastCh = ch;
    }
    f(lastCh, chCount);
    return null;
  };


  /*
  TODO: I think this can be generalized to cover most all ellipsies and word-wrap scenarios:
    a) have an options object with options:
      maxLength: number         # similar to current maxLength
      minLength: number         # currently implied to be maxLength / 2, in additional customizable, it would also be optional
      brokenWordEllipsis: "â€¦"   # used when only part of a word is included
      moreWordsEllipsis: "â€¦"    # used when there are more words, but the last word is whole
      wordLengthFunction: (string) -> string.length
         * can be replaced with, say, the font pixel-width for a string
         * in this way, this function can be used by text-layout
         * minLength and maxLength would then be in pixels
      breakWords: false         # currently, this is effectively true - will break the last word on line in most situations
      breakOnlyWord: true       # even if breakWords is false, if this is the only word on the line and it doesn't fit, should we break it?
                                 * should this even be an option?
       * future:
      wordBreakFunction: (word, maxLength) -> shorterWord
         * given a word and the maximum length of that word, returns
         * a word <= maxLength according to wordLengthFunction
  
    b) Use cases
      - TextLayout - uses pixels for length rather than characters
      - Art.Engine.Element 'flow' layout
        - if the input was an array of "words" and
        - wordLengthFunction returns the Element's width...
        I think this works. We'd need a way to handle margins though. I think this works:
          spaceLength: (leftWord, rightWord) -> 1
      - Shortend user display names:
        Options:
          wordBreakFunction: (word, maxLength) -> word[0]
          brokenWordEllipsis: "." or ""
        Example Output:
          "Shane Delamore", 10 > "Shane D." or
          "Shane Delamore", 10 > "Shane D"
        Or, just leave breakwords: false and get:
          "Shane Delamore", 10 > "Shane"
  
    c) returns both the output string and the "string remaining" - everything not included
    d) alternate input: an array of strings already broken up by words - the "remainging" return value would then also be an array of "words"
      (this would be for efficiency when doing multi-line layout)
  
  Right now, it works as follows:
  The output string is guaranteed to be:
    <= maxLength
    >= maxLength / 2 in almost all secenarios as long as inputString is >= maxLength / 2
   */

  StringExtensions.humanFriendlyShorten = function(inputString, maxLength) {
    var j, len, minLength, part, string, stringParts;
    if (!(maxLength > 0)) {
      throw new error("maxLength must be > 0");
    }
    inputString = inputString.trim();
    if (!(inputString.length > maxLength)) {
      return inputString;
    }
    minLength = maxLength / 2;
    stringParts = inputString.split(/\s+/);
    string = "";
    for (j = 0, len = stringParts.length; j < len; j++) {
      part = stringParts[j];
      if (string.length === 0) {
        string = part;
      } else if ((string.length < minLength) || string.length + part.length + 2 <= maxLength) {
        string += " " + part;
      } else {
        break;
      }
    }
    if (string.length > maxLength) {
      string = string.slice(0, maxLength - 1).trim();
    }
    return string + "â€¦";
  };

  StringExtensions.stripTrailingWhitespace = function(a) {
    return a.split(/[ ]*\n/).join("\n").split(/[ ]*$/)[0].replace(/\n+$/, '');
  };

  return StringExtensions;

})();


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(276);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  return __webpack_require__(0).merge(
    __webpack_require__(0),
    __webpack_require__(8),
    __webpack_require__(113)
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var Base, BaseObject, floatEq, inspect, inspectedObjectLiteral, isFunction, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, ref, stringToNumberArray, upperCamelCase, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), inspect = ref.inspect, log = ref.log, isNumber = ref.isNumber, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isString = ref.isString, isFunction = ref.isFunction, stringToNumberArray = ref.stringToNumberArray, BaseObject = ref.BaseObject, lowerCamelCase = ref.lowerCamelCase, upperCamelCase = ref.upperCamelCase, inspectedObjectLiteral = ref.inspectedObjectLiteral, floatEq = ref.floatEq, wordsArray = ref.wordsArray, inspect = ref.inspect;

module.exports = Base = (function(superClass) {
  var letterFieldNames, reservedWords;

  extend(Base, superClass);


  /*
  TODO
  
  All Atomics follow the same pattern:
  
    A fixed, ordered set of fields
    with fixed names
    and fixed defaults
  
  Most functions could be automatically defined given:
  
    An array of field-names
    An array of default values
    NOTE: I wish we could just use an object to specifiy those, but
      the order is not guaranteed, and we need a fixed order.
  
  The field-names could be defined with a string.
  Zero (0) can be the default default-value
  
  Point:      @defineAtomic fieldNames: "x y"
  Matrix:     @defineAtomic fieldNames: "sx shy tx shx sy ty", defaults: [1, 1]
  Rectangle:  @defineAtomic fieldNames: "x y w h"
  Perimeter:  @defineAtomic fieldNames: "left right top bottom"
  
  nonStandardInitializes
    Initializing with 1 arg or fields.length args is usually the same for all atomics
    But, intializing with a number of args in between tends to vary.
    I suggest overrides:
    _init0: -> defaults
    _init1: (a) -> all fields = a
    _init2:
    _init3:
    _init4:
    _init#{n}: -> each field gets set individually
  
  @defineAtomicClass: ({fieldNames, defaults, aliases}) ->
    fields = wordsArray fields if isString fields
    @defineSetAll()           # uses fieldNames
    @defineInit0()            # uses fieldNames and defaults
    @defineInit1()            # uses fieldNames
    @defineInterpolate()      # uses fieldNames
    @defineComparisonOperators()  # uses fieldNames, defines: eq, gt, lt, gte, lte
    @defineMathOperators()        # uses fieldNames, defines: add, sub, mul, div
    @defineToArray()          # uses fieldNames
    @defineInitFromObject()   # uses fieldNames and aliases
    @defineToObject()         # uses fieldNames
    @defineGetters()          # uses fieldNames and aliases
    @defineInto()             # uses fieldNames
    @defineToString()
    @defineInspect()
    @defineToInspectedObjects()
   */

  Base.prototype._initFromString = function(string) {
    return this._init.apply(this, stringToNumberArray(string));
  };

  function Base(a, b, c, d, e, f, g) {
    Base.__super__.constructor.apply(this, arguments);
    if (isPlainArray(a)) {
      this._init.apply(this, a);
    } else if (isString(a)) {
      this._initFromString(a);
    } else if (isPlainObject(a)) {
      this._initFromObject(a);
    } else if ((a != null) && !isNumber(a) && !(a instanceof Base) && isFunction(a.toString)) {
      this._initFromString(a.toString());
    } else {
      this._init(a, b, c, d, e, f, g);
    }
  }

  Base.prototype.compare = function(b) {
    if (this.eq(b)) {
      return 0;
    }
    if (this.lte(b)) {
      return -1;
    }
    if (this.gte(b)) {
      return 1;
    }
    return 0/0;
  };

  Base.getConstructorFunctionName = function() {
    return this.constructorFunctionName || (this.constructorFunctionName = lowerCamelCase(this.getName()));
  };

  Base.getter({
    plainObjects: function() {
      return this.toObject();
    },
    inspectedObjects: function() {
      return inspectedObjectLiteral(this["class"].getConstructorFunctionName() + ("(" + (this.toArray().join(', ')) + ")"));
    },
    array: function() {
      return this.toArray();
    }
  });

  Base.prototype.toPlainStructure = function() {
    return this.getPlainObjects();
  };

  Base.prototype.toPlainEvalString = function() {
    return inspect(this.getPlainObjects());
  };

  Base.prototype.inspect = function() {
    return (this["class"].getConstructorFunctionName()) + "(" + (this.toArray().join(', ')) + ")";
  };

  Base.prototype.toJson = function() {
    return this.toString();
  };

  Base.prototype.toString = function(precision) {
    var a;
    if (precision) {
      return "[" + (((function() {
        var j, len, ref1, results;
        ref1 = this.toArray();
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          a = ref1[j];
          results.push(a.toPrecision(precision));
        }
        return results;
      }).call(this)).join(', ')) + "]";
    } else {
      return "[" + (this.toArray().join(', ')) + "]";
    }
  };

  Base.prototype.neq = function(b) {
    return !this.eq(b);
  };

  Base.prototype.between = function(a, b) {
    return this.gte(a) && this.lte(b);
  };

  Base.prototype.floatEq = floatEq;

  Base.prototype.isNumber = isNumber;


  /*
  for use by extending children classes
   */

  Base.defineAtomicClass = function(arg) {
    this.fieldNames = arg.fieldNames, this.constructorFunctionName = arg.constructorFunctionName;
    if (isString(this.fieldNames)) {
      this.fieldNames = wordsArray(this.fieldNames);
    }
    this.getConstructorFunctionName();
    this._defineCore(this.fieldNames);
    this._defineComparisonOperators(this.fieldNames);
    return this._defineMathOperators(this.fieldNames);

    /*
    TODO: more standard methods to add:
    
     * most init can be standardized
    _init*
    
     * more math methods
    min max floor ceil average bound round
    
     * class methods
    @isPoint
     */
  };

  reservedWords = {
    "with": true
  };

  Base._definePrototypeMethodViaEval = function(name, paramsList, body) {
    var nameInEval;
    nameInEval = reservedWords[name] ? "" : name;
    return this.prototype[name] = eval(body = "(\nfunction " + nameInEval + "(" + paramsList + ") {\n" + body + "\n}\n)");
  };


  /*
  define: eq, lt, gt, lte, gt
  With these signatures:
  
     * provide numbers for all fields to compare
    myColor.eq r, g, b, a
  
     * provide another instance of @class to compare against
    myColor.eq myOtherColor
   */

  letterFieldNames = wordsArray("a b c d e f");

  Base._defineComparisonOperators = function(fieldNames) {
    var comparisonOperators, f, functionName, i, operator, params, paramsList, results;
    params = letterFieldNames.slice(0, fieldNames.length);
    paramsList = params.join(', ');
    this._definePrototypeMethodViaEval("eq", paramsList, "if (this === a) return true;\nif (this.isNumber(a)) {\n  return\n  " + (((function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
        f = fieldNames[i];
        results.push("this.floatEq(this." + f + ", " + params[i] + ")");
      }
      return results;
    })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = fieldNames.length; j < len; j++) {
        f = fieldNames[j];
        results.push("this.floatEq(this." + f + ", a." + f + ")");
      }
      return results;
    })()).join(" &&\n  ")) + ";\n}");
    comparisonOperators = {
      lt: "<",
      gt: ">",
      lte: "<=",
      gte: ">="
    };
    results = [];
    for (functionName in comparisonOperators) {
      operator = comparisonOperators[functionName];
      results.push(this._definePrototypeMethodViaEval(functionName, paramsList, "if (this.isNumber(a)) {\n  return\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
          f = fieldNames[i];
          results1.push("this." + f + " " + operator + " " + params[i]);
        }
        return results1;
      })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = fieldNames.length; j < len; j++) {
          f = fieldNames[j];
          results1.push("this." + f + " " + operator + " a." + f);
        }
        return results1;
      })()).join(" &&\n  ")) + ";\n}"));
    }
    return results;
  };


  /*
  define: add, sub, mul and div
  With these signatures:
  
    myColor.add r, g, b, a   # 4 numbers
  
    myColor.add myOtherColor, into # add by component
    myColor.add v, into            # one number to add to all
  
    into is optional. if set:
      it should be an instance of @class
      into is what is returned; a new instance of @class is not created
      into's field are set to the result
      NOTE: Atomic classes are designed to be used Pure-Functionally!
        SO, only use this if you created 'into' and you are not using it ANYWHERE else.
   */

  Base._defineMathOperators = function(fieldNames) {
    var f, functionName, i, mathOperators, operator, params, results;
    mathOperators = {
      add: "+",
      sub: "-",
      mul: "*",
      div: "/"
    };
    params = letterFieldNames.slice(0, fieldNames.length);
    results = [];
    for (functionName in mathOperators) {
      operator = mathOperators[functionName];
      results.push(this._definePrototypeMethodViaEval(functionName, params.join(', '), "if (this.isNumber(b)) {\n  return this._into(\n  null,\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
          f = fieldNames[i];
          results1.push("this." + f + " " + operator + " " + params[i]);
        }
        return results1;
      })()).join(",\n  ")) + "\n  );\n} else if (this.isNumber(a)) {\n  return this._into(\n  b,\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = fieldNames.length; j < len; j++) {
          f = fieldNames[j];
          results1.push("this." + f + " " + operator + " a");
        }
        return results1;
      })()).join(",\n  ")) + "\n  );\n} else {\n  return this._into(\n  b,\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = fieldNames.length; j < len; j++) {
          f = fieldNames[j];
          results1.push("this." + f + " " + operator + " a." + f);
        }
        return results1;
      })()).join(",\n  ")) + "\n  );\n}"));
    }
    return results;
  };

  Base._defineCore = function(fields) {
    var f, field, fieldList, j, len;
    fieldList = fields.join(', ');
    this._definePrototypeMethodViaEval("_into", "into, " + fieldList, "if (into === true)\n  into = this;\nelse\n  into = into || new this.class;\nreturn into._setAll(" + fieldList + ");");
    this._definePrototypeMethodViaEval("_setAll", fieldList, (((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = fields.length; j < len; j++) {
        f = fields[j];
        results.push("this." + f + " = " + f);
      }
      return results;
    })()).join(";\n")) + ";\nreturn this;");
    this._definePrototypeMethodViaEval("with", fieldList, "if (this.eq(" + fieldList + "))\n  return this;\nelse\n  return new this.class(" + fieldList + ");");
    this._definePrototypeMethodViaEval("clone", '', "return new this.class(" + (((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = fields.length; j < len; j++) {
        field = fields[j];
        results.push("this." + field);
      }
      return results;
    })()).join(',')) + ");");
    for (j = 0, len = fields.length; j < len; j++) {
      field = fields[j];
      this._definePrototypeMethodViaEval("with" + (upperCamelCase(field)), field, "return this.with(\n  " + (((function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = fields.length; k < len1; k++) {
          f = fields[k];
          results.push(f === field ? f : "this." + f);
        }
        return results;
      })()).join(",\n  ")) + "\n);");
    }
    this._definePrototypeMethodViaEval("interpolate", "b, p, into", "var oneMinusP = 1 - p;\nreturn this._into(\ninto,\n" + (((function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = fields.length; k < len1; k++) {
        f = fields[k];
        results.push("b." + f + " * p + this." + f + " * oneMinusP");
      }
      return results;
    })()).join(",\n")) + "\n);");
    this._definePrototypeMethodViaEval("toArray", "", "return [" + (((function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = fields.length; k < len1; k++) {
        f = fields[k];
        results.push("this." + f);
      }
      return results;
    })()).join(", ")) + "];");
    return this._definePrototypeMethodViaEval("toObject", "", "return {" + (((function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = fields.length; k < len1; k++) {
        f = fields[k];
        results.push(f + ": this." + f);
      }
      return results;
    })()).join(", ")) + "};");
  };

  return Base;

})(BaseObject);


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var Ery,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.Ery', Ery = (function(superClass) {
  extend(Ery, superClass);

  function Ery() {
    return Ery.__super__.constructor.apply(this, arguments);
  }

  Ery.version = __webpack_require__(163).version;

  return Ery;

})(Neptune.PackageNamespace));

__webpack_require__(109);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(256);


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var CommonJs, isClass, isFunction, ref;

ref = __webpack_require__(4), isClass = ref.isClass, isFunction = ref.isFunction;

module.exports = CommonJs = (function() {
  var definingModule;

  function CommonJs() {}

  definingModule = null;

  CommonJs.getModuleBeingDefined = function() {
    return definingModule;
  };


  /*
  IN:
    defineFunciton ||
   */

  CommonJs.defineModule = function(_module, a) {
    var lastModule, mod, result;
    lastModule = definingModule;
    definingModule = _module;
    mod = isFunction(a) ? isClass(a) ? a : a() : a;
    result = _module.exports = (mod != null ? typeof mod.createWithPostCreate === "function" ? mod.createWithPostCreate(mod) : void 0 : void 0) || mod;
    definingModule = lastModule;
    return result;
  };

  return CommonJs;

})();


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(45);

module.exports.includeInNamespace(__webpack_require__(261)).addModules({
  FormattedInspect: __webpack_require__(144),
  InspectedObjectLiteral: __webpack_require__(44),
  InspectedObjects: __webpack_require__(68),
  Inspector: __webpack_require__(69),
  Inspector2: __webpack_require__(266),
  PlainObjects: __webpack_require__(147)
});

__webpack_require__(145);


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var MathExtensions, RegExpExtensions, abs, ceil, float32Precision, float64Precision, floor, inverseFloat64Precision, inverstFlaot32Precision, max, min, numberRegexp, pow, random, ref, round;

RegExpExtensions = __webpack_require__(30);

numberRegexp = RegExpExtensions.numberRegexp;

float64Precision = 0.0000000001;

float32Precision = 0.0000001;

inverseFloat64Precision = 1 / float64Precision;

inverstFlaot32Precision = 1 / float32Precision;

ref = self.Math, abs = ref.abs, min = ref.min, max = ref.max, ceil = ref.ceil, floor = ref.floor, round = ref.round, random = ref.random, pow = ref.pow;

module.exports = MathExtensions = (function() {
  var bound;

  function MathExtensions() {}

  MathExtensions.nearInfinity = pow(10, 100);

  MathExtensions.nearInfinityResult = pow(10, 50);

  MathExtensions.float32Precision = float32Precision;

  MathExtensions.float64Precision = float64Precision;

  MathExtensions.modulo = function(a, b) {
    var r;
    r = a % b;
    if (r < 0) {
      return r + b;
    } else {
      return r;
    }
  };

  MathExtensions.stringToNumberArray = function(string) {
    var a, i, j, len, match, v;
    a = string.split(",");
    for (i = j = 0, len = a.length; j < len; i = ++j) {
      v = a[i];
      match = v.match(numberRegexp);
      a[i] = match != null ? match[0] - 0 : 0;
    }
    return a;
  };

  MathExtensions.minMagnitude = function(a, magnitude) {
    if (a < 0) {
      return min(a, -magnitude);
    } else {
      return max(a, magnitude);
    }
  };

  MathExtensions.maxMagnitude = function(a, magnitude) {
    return bound(-magnitude, a, magnitude);
  };

  MathExtensions.maxChange = function(newValue, oldValue, maxChangeV) {
    return bound(oldValue - maxChangeV, newValue, oldValue + maxChangeV);
  };

  MathExtensions.bound = bound = function(a, b, c) {
    if (isNaN(b)) {
      return a;
    }
    if (b < a) {
      return a;
    } else if (b > c) {
      return c;
    } else {
      return b;
    }
  };

  MathExtensions.absGt = function(a, b) {
    return abs(a) > abs(b);
  };

  MathExtensions.absLt = function(a, b) {
    return abs(a) < abs(b);
  };

  MathExtensions.absGte = function(a, b) {
    return abs(a) >= abs(b);
  };

  MathExtensions.absLte = function(a, b) {
    return abs(a) <= abs(b);
  };

  MathExtensions.abs = abs;

  MathExtensions.min = min;

  MathExtensions.max = max;

  MathExtensions.round = round;

  MathExtensions.ceil = function(v, m) {
    if (m == null) {
      m = 1;
    }
    return ceil(v / m) * m;
  };

  MathExtensions.floor = function(v, m) {
    if (m == null) {
      m = 1;
    }
    return floor(v / m) * m;
  };

  MathExtensions.round = function(v, m) {
    if (m == null) {
      m = 1;
    }
    return round(v / m) * m;
  };

  MathExtensions.simplifyNum = function(num) {
    return round(num * inverseFloat64Precision) * float64Precision;
  };

  MathExtensions.floatEq = function(n1, n2) {
    return n1 === n2 || float64Precision > abs(n1 - n2);
  };

  MathExtensions.float32Eq = function(n1, n2) {
    return n1 === n2 || float32Precision > abs(n1 - n2);
  };

  MathExtensions.floatEq0 = function(n) {
    return n === 0 || float64Precision > abs(n);
  };

  MathExtensions.float32Eq0 = function(n) {
    return n === 0 || float32Precision > abs(n);
  };

  MathExtensions.floatTrue0 = function(n) {
    if (n === 0 || float64Precision > abs(n)) {
      return 0;
    } else {
      return n;
    }
  };

  MathExtensions.float32True0 = function(n) {
    if (n === 0 || float32Precision > abs(n)) {
      return 0;
    } else {
      return n;
    }
  };

  MathExtensions.random = random;

  MathExtensions.intRand = function(max) {
    return random() * max | 0;
  };

  MathExtensions.iPart = function(v) {
    return v - (v % 1);
  };

  MathExtensions.fPart = function(v) {
    return v % 1;
  };

  MathExtensions.commaize = function(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  };

  MathExtensions.cyclingSequenceFunction = function(sequence) {
    var sequencePos;
    sequencePos = sequence.length;
    return function() {
      sequencePos++;
      if (sequencePos >= sequence.length) {
        sequencePos = 0;
      }
      return sequence[sequencePos];
    };
  };

  return MathExtensions;

})();


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var AtomicBase, Foundation, Namespace, PI, Point, abs, atan, bound, ceil, floatEq, floor, inspect, inspectedObjectLiteral, isArray, isFunction, isNumber, isString, log, max, min, nearInfinity, round, sqrt, stringToNumberArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(19);

Namespace = __webpack_require__(31);

inspect = Foundation.inspect, bound = Foundation.bound, floatEq = Foundation.floatEq, log = Foundation.log, isNumber = Foundation.isNumber, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, stringToNumberArray = Foundation.stringToNumberArray, nearInfinity = Foundation.nearInfinity, inspectedObjectLiteral = Foundation.inspectedObjectLiteral;

abs = Math.abs, sqrt = Math.sqrt, atan = Math.atan, PI = Math.PI, floor = Math.floor, ceil = Math.ceil, round = Math.round, min = Math.min, max = Math.max;


/*
point() general point constructor

IN: (p:Point)
OUT: p

IN: ()
IN: ([])
OUT: point 0, 0

IN: (string)
OUT: Point.namedPoints[string] || Point.parse string

IN: (s:number)
IN: ([s:number])
OUT: new Point s, s

IN: (x:number, y:number)
IN: ([x:number, y:number])
OUT: new Point x, y

IN: ({x:number, y:number})
OUT: new Point x || 0, y || 0

IN: ({aspectRatio: number, area: number})
  aspectRatio: number representing: width / height
  area: number representing the square-area desired
OUT:
  a point, p, with:
    p.area == o.area
    p.aspectRatio == o.aspectRatio
 */

module.exports = Point = (function(superClass) {
  var bottomLeft, centerCenter, centerLeft, k, namedPoints, point, point0, point1, pointWithAspectRatioAndArea, ref, topCenter, topRight, v;

  extend(Point, superClass);

  function Point() {
    return Point.__super__.constructor.apply(this, arguments);
  }

  Point.defineAtomicClass({
    fieldNames: "x y"
  });

  Point.isPoint = function(v) {
    return (v != null ? v.constuctor : void 0) === Point;
  };

  pointWithAspectRatioAndArea = function(arg) {
    var area, aspectRatio, sqrtArea;
    aspectRatio = arg.aspectRatio, area = arg.area;
    sqrtArea = Math.sqrt(area / aspectRatio);
    return point(sqrtArea * aspectRatio, sqrtArea);
  };

  Point.point = point = function(a, b) {
    var p, x, y;
    if (a instanceof Point) {
      return a;
    }
    if (isString(a) && (p = namedPoints[a])) {
      return p;
    }
    if ((a != null ? a.aspectRatio : void 0) && a.area >= 0) {
      return pointWithAspectRatioAndArea(a);
    }
    x = a || 0;
    y = b != null ? b : a;
    if (point0.eq(x, y)) {
      return point0;
    }
    if (point1.eq(x, y)) {
      return point1;
    }
    return new Point(a, b);
  };

  Point.parse = function(string, existing) {
    if (existing) {
      throw new Error("existing feature is no longer supported");
    }
    return new Point(string);
  };

  Point.prototype._init = function(x, y) {
    x || (x = 0);
    if (y == null) {
      y = x;
    }
    this.x = x - 0;
    return this.y = y - 0;
  };

  Point.prototype._initFromObject = function(o) {
    this.x = o.x || 0;
    return this.y = o.y || 0;
  };

  Point.getter({
    exportedValue: function() {
      var out, ref, x, y;
      ref = this, x = ref.x, y = ref.y;
      if (x === y) {
        return x;
      } else {
        out = {};
        if (x !== 0) {
          out.x = x;
        }
        if (y !== 0) {
          out.y = y;
        }
        return out;
      }
    },
    top: function() {
      return 0;
    },
    left: function() {
      return 0;
    },
    right: function() {
      return this.x;
    },
    bottom: function() {
      return this.y;
    },
    centerX: function() {
      return this.x * .5;
    },
    centerY: function() {
      return this.y * .5;
    },
    hCenter: function() {
      return this.getCenterX();
    },
    vCenter: function() {
      return this.getCenterY();
    },
    tl: function() {
      return point0;
    },
    tc: function() {
      return this.mul(0.5, 0);
    },
    tr: function() {
      return this.mul(1, 0);
    },
    lc: function() {
      return this.mul(0, 0.5);
    },
    cc: function() {
      return this.mul(0.5, 0.5);
    },
    rc: function() {
      return this.mul(1, 0.5);
    },
    bl: function() {
      return this.mul(0, 1);
    },
    bc: function() {
      return this.mul(0.5, 1);
    },
    br: function() {
      return this;
    },
    ccNeg: function() {
      return this.mul(-0.5);
    },
    topLeft: function() {
      return point0;
    },
    topCenter: function() {
      return this.mul(0.5, 0);
    },
    topRight: function() {
      return this.mul(1, 0);
    },
    centerLeft: function() {
      return this.mul(0, 0.5);
    },
    centerCenter: function() {
      return this.mul(0.5, 0.5);
    },
    centerRight: function() {
      return this.mul(1, 0.5);
    },
    bottomLeft: function() {
      return this.mul(0, 1);
    },
    bottomCenter: function() {
      return this.mul(0.5, 1);
    },
    bottomRight: function() {
      return this;
    },
    w: function() {
      return this.x;
    },
    width: function() {
      return this.x;
    },
    h: function() {
      return this.y;
    },
    height: function() {
      return this.y;
    },
    neg: function() {
      return new Point(-this.x, -this.y);
    },
    inv: function() {
      return new Point(1.0 / this.x, 1.0 / this.y);
    },
    vector: function() {
      return [this.x, this.y];
    },
    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y;
    },
    magnitude: function() {
      return sqrt(this.x * this.x + this.y * this.y);
    },
    aspectRatio: function() {
      return this.x / this.y;
    },
    absoluteAspectRatio: function() {
      return abs(this.x / this.y);
    },
    swapped: function() {
      return point(this.y, this.x);
    },
    rounded: function() {
      return this.round();
    },
    floored: function() {
      return this.floor();
    },
    ceiled: function() {
      return this.ceil();
    },
    area: function() {
      return this.x * this.y;
    },
    sum: function() {
      return this.x + this.y;
    },
    size: function() {
      return this;
    },
    location: function() {
      return point0;
    },
    abs: function() {
      return this["with"](abs(this.x), abs(this.y));
    },
    unitVector: function() {
      var m;
      m = 1 / this.magnitude;
      return new Point(this.x * m, this.y * m);
    },
    perpendicularVector: function() {
      return new Point(this.y, -this.x);
    },
    unitPerpendicularVector: function() {
      var m;
      m = 1 / this.magnitude;
      return new Point(this.y * m, -this.x * m);
    },
    angle: function() {
      if (this.x === 0) {
        return PI * (this.y > 0 ? .5 : 1.5);
      } else {
        if (this.x > 0) {
          return atan(this.y / this.x);
        } else {
          return atan(this.y / this.x) + PI;
        }
      }
    },
    isInteger: function() {
      return floatEq(this.x, this.x | 0) && floatEq(this.y, this.y | 0);
    }
  });

  Point.prototype.distance = function(p2) {
    return sqrt(this.distanceSquared(p2));
  };

  Point.prototype.distanceSquared = function(p2) {
    var x, y;
    x = this.x - p2.x;
    y = this.y - p2.y;
    return x * x + y * y;
  };

  Point.prototype.withArea = function(newArea) {
    var area;
    area = this.area;
    if (!(area > 0 && newArea >= 0)) {
      throw new Error("area must be > 0");
    }
    return this.mul(Math.sqrt(newArea / area));
  };

  Point.prototype.vectorLength = 2;

  Point.prototype.toIndex = function(lineStride) {
    return ~~this.y * lineStride + ~~this.x;
  };

  Point.prototype.contains = function(p) {
    return p.x >= 0 && p.y >= 0 && p.x < this.x & p.y < this.y;
  };

  Point.prototype.nearestInsidePoint = function(p) {
    return this["with"](bound(0, p.x, this.x), bound(0, p.y, this.y));
  };

  Point.prototype.appendToVector = function(vector) {
    var l;
    l = vector.length;
    vector[l + 1] = this.y;
    return vector[l] = this.x;
  };

  Point.prototype.dot = function(p) {
    return this.x * p.x + this.y * p.y;
  };

  Point.prototype.cross = function(p) {
    return this.x * p.y - this.y * p.x;
  };

  Point.prototype.floor = function() {
    return this["with"](floor(this.x), floor(this.y));
  };

  Point.prototype.ceil = function() {
    return this["with"](ceil(this.x), ceil(this.y));
  };

  Point.prototype.union = function(b) {
    if (b instanceof Point) {
      return this.max(b);
    } else {
      return b.union(this);
    }
  };

  Point.prototype.intersection = function(b) {
    if (b instanceof Point) {
      return this.min(b);
    } else {
      return b.intersection(this);
    }
  };

  Point.prototype.min = function(b) {
    if (b == null) {
      b = null;
    }
    if (b) {
      return this["with"](min(this.x, b.x), min(this.y, b.y));
    } else {
      return min(this.x, this.y);
    }
  };

  Point.prototype.max = function(b) {
    if (b == null) {
      b = null;
    }
    if (b) {
      return this["with"](max(this.x, b.x), max(this.y, b.y));
    } else {
      return max(this.x, this.y);
    }
  };

  Point.prototype.average = function(b) {
    if (b == null) {
      b = null;
    }
    if (b) {
      return this["with"]((this.x + b.x) / 2, (this.y + b.y) / 2);
    } else {
      return (this.x + this.y) / 2;
    }
  };

  Point.prototype.bound = function(a, b) {
    return this["with"](bound(a.x, this.x, b.x), bound(a.y, this.y, b.y));
  };

  Point.prototype.round = function(m) {
    if (m == null) {
      m = 1;
    }
    return this["with"](round(this.x / m) * m, round(this.y / m) * m);
  };

  Point.prototype.roundOut = function() {
    return this.ceil();
  };


  /*
  OUT:
    out.aspectRatio == @aspectRatio
    out <= into
    out.x == into.x or out.y == into.y
  proposed rename: scaledJustLte
   */

  Point.prototype.fitInto = function(into) {
    var x, xr, y, yr;
    if (into == null) {
      return this;
    }
    if (isNumber(into)) {
      x = y = into;
    } else {
      x = into.x, y = into.y;
    }
    xr = x / this.x;
    yr = y / this.y;
    return this.mul(min(xr, yr));
  };


  /*
  OUT:
    out.aspectRatio == @aspectRatio
    out >= into
    out.x == into.x or out.y == into.y
  
  KEYWORD: I used to call this 'zoom'
  proposed rename: scaledJustGte
   */

  Point.prototype.fill = function(into) {
    var x, xr, y, yr;
    if (isNumber(into)) {
      x = y = into;
    } else {
      x = into.x, y = into.y;
    }
    xr = x / this.x;
    yr = y / this.y;
    return this.mul(max(xr, yr));
  };


  /*
  OUT:
    out.aspectRatio == @aspectRatio
    out.area == p.area
   */

  Point.prototype.withSameAreaAs = function(p) {
    return this.mul(Math.sqrt(p.area / this.area));
  };

  Point.prototype.withAspectRatio = function(aspectRatio) {
    if (floatEq(aspectRatio, this.aspectRatio)) {
      return this;
    }
    return point({
      aspectRatio: aspectRatio,
      area: this.area
    });
  };

  Point.prototype.withRect = function(a, b, c, d) {
    if ((d != null) && a === 0 && b === 0) {
      return this["with"](c, d);
    } else {
      return Namespace.rect(a, b, c, d);
    }
  };

  point0 = Object.freeze(new Point(0));

  point1 = Object.freeze(new Point(1));

  topRight = Object.freeze(new Point(1, 0));

  topCenter = Object.freeze(new Point(0.5, 0));

  centerLeft = Object.freeze(new Point(0, 0.5));

  centerCenter = Object.freeze(new Point(0.5));

  bottomLeft = Object.freeze(new Point(0, 1));

  Point.namedPoints = namedPoints = {
    point0: point0,
    point1: point1,
    topLeft: point0,
    topCenter: topCenter,
    topRight: topRight,
    centerLeft: centerLeft,
    centerCenter: centerCenter,
    centerRight: Object.freeze(new Point(1, 0.5)),
    bottomLeft: bottomLeft,
    bottomCenter: Object.freeze(new Point(0.5, 1)),
    bottomRight: point1,
    pointNearInfinity: Object.freeze(new Point(nearInfinity)),
    left: point0,
    center: topCenter,
    right: topRight,
    top: point0,
    bottom: bottomLeft
  };

  ref = Point.namedPoints;
  for (k in ref) {
    v = ref[k];
    Point[k] = v;
  }

  return Point;

})(AtomicBase);


/***/ }),
/* 26 */
/***/ (function(module, exports) {


/*
Set: global.ArtStandardLibMultipleContextTypeSupport = true
Before the first time you require this file if you need to be able to test objects
from multiple contexts.

When do you need this?
  - when working with iFrames
  - when working with Node's 'repl' or 'vm'

What is the differences?
  With: slower, but other-wise the same
  Without: plain-arrays and plain-objects from other contexts
    are not detected with isArray, isPlainArray, isPlainObject
 */
var ArtStandardLibMultipleContextTypeSupport, Types;

ArtStandardLibMultipleContextTypeSupport = global.ArtStandardLibMultipleContextTypeSupport;

module.exports = Types = (function() {
  var _functionsPrototype, hasOwnProperties, hasProperties, isArray, isClass, isDirectPrototypeOf, isExtendedClass, isFunction, isJsonAtomicType, isNonNegativeInt, isNumber, isObject, isPlainObject, isString;

  function Types() {}

  Types.isPromise = function(obj) {
    return isFunction(obj != null ? obj.then : void 0);
  };

  Types.isRegExp = ArtStandardLibMultipleContextTypeSupport ? function(obj) {
    return obj.constructor.name === "RegExp";
  } : function(obj) {
    return obj.constructor === RegExp;
  };

  Types.isNumber = isNumber = function(obj) {
    return typeof obj === "number";
  };

  Types.prototype.isNonNegativeInt = function(x) {
    return ((x | 0) === x) && x >= 0;
  };

  Types.isDate = function(obj) {
    return obj && obj.constructor === Date;
  };

  Types.isString = isString = function(obj) {
    return typeof obj === "string";
  };

  Types.isFunction = isFunction = function(obj) {
    return typeof obj === "function";
  };

  Types.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };

  Types.isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  _functionsPrototype = Object.getPrototypeOf(function() {});

  Types.isClass = isClass = function(obj) {
    var prototype;
    return !!(typeof obj === "function" && ((typeof obj.__super__ === "object") || ((typeof (prototype = Object.getPrototypeOf(obj)) === "function") && prototype !== _functionsPrototype) || (hasOwnProperties(obj)) || (obj.prototype && hasProperties(obj.prototype))));
  };

  Types.isExtendedClass = isExtendedClass = function(obj) {
    var prototype;
    return !!(typeof obj === "function" && ((typeof obj.__super__ === "object") || ((typeof (prototype = Object.getPrototypeOf(obj)) === "function") && prototype !== _functionsPrototype)));
  };

  Types.isArrayUniversal = Array.isArray;

  Types.isArray = isArray = ArtStandardLibMultipleContextTypeSupport ? Types.isArrayUniversal : function(o) {
    return (o != null) && o.constructor === Array;
  };

  Types.isPlainArray = isArray;

  Types.isNonNegativeInt = isNonNegativeInt = function(x) {
    return (x | 0 === x) && x >= 0;
  };

  Types.isArrayIterable = function(source) {
    return !!(source && isNonNegativeInt(source.length));
  };

  Types.isJsonAtomicType = isJsonAtomicType = function(a) {
    return isString(a) || isNumber(a) || a === true || a === false || a === null;
  };

  Types.isJsonType = function(a) {
    return isJsonAtomicType(a) || isPlainObject(a) || isArray(a);
  };

  Types.isObject = isObject = function(obj) {
    return !!obj && typeof obj === "object" && !isArray(obj);
  };

  Types.isDirectPrototypeOf = isDirectPrototypeOf = function(o, prototype) {
    return !isFunction(o) && prototype.constructor === o.constructor;
  };


  /*
  NOTE:
    getSuper doesn't work in CoffeeScript classes objects, but it does on ES6 classes.
    getSuper does work on CoffeeScript class instance objects.
  
  All about getSuper in ES6 land:
  
    class A {}
    class B extends A {}
    class C extends B {}
  
    a = new A
    b = new B
    c = new C
  
    getSuper(B) == A
    getSuper(C) == B
  
    getSuper(A.prototype) == Object.prototype
    getSuper(B.prototype) == A.prototype
    getSuper(C.prototype) == B.prototype
  
    getSuper(b) == A.prototype
    getSuper(c) == B.prototype
  
  prototype map:
  
  KEY:
    <->
       <-- .constructor
       --> .prototype
    ^  Object.getPrototypeOf
  
  MAP:
    A <-> aPrototype
  
    ^     ^     ^
    |     |     a
    |     |
  
    B <-> bPrototype
  
    ^     ^     ^
    |     |     b
    |     |
  
    C <-> cPrototype
  
                ^
                c
  
  Definition of super:
  
    if instance then prototype's prototype
    else prototype
   */

  Types.getSuper = function(o) {
    var _super;
    if (!((typeof o === "object") || (typeof o === "function"))) {
      throw new Error("getSuper expecting an object");
    }
    _super = Object.getPrototypeOf(o);
    if (isDirectPrototypeOf(o, _super)) {
      _super = Object.getPrototypeOf(_super);
    }
    return _super;
  };

  Types.isPlainObjectUniversal = function(v) {
    return (v != null) && null === Object.getPrototypeOf(Object.getPrototypeOf(v));
  };

  Types.isPlainObject = isPlainObject = ArtStandardLibMultipleContextTypeSupport ? Types.isPlainObjectUniversal : function(v) {
    return (v != null) && v.constructor === Object;
  };

  Types.hasProperties = hasProperties = function(o) {
    var k;
    if (o == null) {
      return false;
    }
    for (k in o) {
      return true;
    }
    return false;
  };

  Types.hasOwnProperties = hasOwnProperties = function(o) {
    var k;
    if (o == null) {
      return false;
    }
    for (k in o) {
      if (o.hasOwnProperty(k)) {
        return true;
      }
    }
    return false;
  };

  return Types;

})();


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Environment, ParseUrl, defineModule, isNode;

defineModule = __webpack_require__(22).defineModule;

ParseUrl = __webpack_require__(47);

isNode = __webpack_require__(167);

defineModule(module, Environment = (function() {
  function Environment() {}

  Environment.getEnv = function() {
    var ref, ref1, ret;
    ret = ((ref = global.location) != null ? ref.search : void 0) ? ParseUrl.parseQuery() : (ref1 = global.process) != null ? ref1.env : void 0;
    return ret || {};
  };

  Environment.isBrowser = !!(global.window && global.navigator && global.document);

  Environment.isWebWorker = !!(!Environment.isBrowser && global.importScripts);

  Environment.isNode = !!isNode;

  return Environment;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var ObjectExtensions, compactFlatten, deepArrayEach, isArrayOrArguments, isFunction, isObject, isPlainArray, isPlainObject, mergeInto, object, present, ref, ref1,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(7), compactFlatten = ref.compactFlatten, deepArrayEach = ref.deepArrayEach, isArrayOrArguments = ref.isArrayOrArguments, mergeInto = ref.mergeInto;

ref1 = __webpack_require__(4), isPlainObject = ref1.isPlainObject, isObject = ref1.isObject, isFunction = ref1.isFunction, isPlainArray = ref1.isPlainArray, present = ref1.present;

object = __webpack_require__(70).object;

module.exports = ObjectExtensions = (function() {
  var expandPathedProperties, objectKeyCount, propertyIsPathed, setPathedProperty, toObjectInternal, withPropertyPath;

  function ObjectExtensions() {}

  ObjectExtensions.countKeys = function(o) {
    return Object.keys(o).length;
  };

  ObjectExtensions.objectKeyCount = objectKeyCount = function(o) {
    var count, k, v;
    count = 0;
    for (k in o) {
      v = o[k];
      count++;
    }
    return count;
  };

  ObjectExtensions.objectHasKeys = function(o) {
    var b, k;
    for (k in o) {
      b = o[k];
      return true;
    }
    return false;
  };

  ObjectExtensions.objectLength = objectKeyCount;


  /*
  NOTE:
    null and undefined keys are NOT SUPPORTED
  
    They should be converted to strings, first,
    which is what they would become anyway.
  
  IN: 0 or more arguments
    out = {}
    list = arguments
  
    for element in list
      objects: merge into out
      arrays or argument lists: recurse using element as the list
      null or undefined: skip
      else out[element] = next element (or undefined if none)
  
  OUT: plain object
   */

  toObjectInternal = function(list, out) {
    var element, j, key, len;
    key = null;
    for (j = 0, len = list.length; j < len; j++) {
      element = list[j];
      if (key) {
        out[key] = element;
        key = null;
      } else if (isPlainObject(element)) {
        mergeInto(out, element);
      } else if (isArrayOrArguments(element)) {
        toObjectInternal(element, out);
      } else if (element != null) {
        key = element;
      }
    }
    if (key) {
      return out[key] = void 0;
    }
  };

  ObjectExtensions.toObject = function() {
    var out;
    out = {};
    toObjectInternal(arguments, out);
    return out;
  };


  /*
  IN:
    inputArray: any array
    transformFunction: (element) -> [key, value]
      default: transforms an array of the form: [[key1, value1], [key2, value2], etc...]
   */

  ObjectExtensions.arrayToMap = function(inputArray, transformFunction) {
    var element, j, key, len, outputMap, ref2, value;
    if (transformFunction == null) {
      transformFunction = function(element) {
        return element;
      };
    }
    outputMap = {};
    for (j = 0, len = inputArray.length; j < len; j++) {
      element = inputArray[j];
      ref2 = transformFunction(element), key = ref2[0], value = ref2[1];
      outputMap[key] = value;
    }
    return outputMap;
  };


  /*
  IN:
    obj: the object to select fields from
  
    2nd argument can be:
      selectFunction: (value, key) -> true / false
  
    OR obj can be followed by any number of strings or arrays in any nesting, possibly with null fields
   */

  ObjectExtensions.select = function(obj, a) {
    var j, k, len, prop, properties, result, v;
    if (!obj) {
      return {};
    }
    result = {};
    if (isFunction(a)) {
      if (a.length === 1) {
        for (k in obj) {
          v = obj[k];
          if (a(v)) {
            result[k] = v;
          }
        }
      } else {
        for (k in obj) {
          v = obj[k];
          if (a(k, v)) {
            result[k] = v;
          }
        }
      }
    } else {
      properties = compactFlatten(Array.prototype.slice.call(arguments, 1));
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        if (((v = obj[prop]) != null) || obj.hasOwnProperty(prop)) {
          result[prop] = v;
        }
      }
    }
    return result;
  };

  ObjectExtensions.selectAll = function() {
    var j, len, obj, prop, properties, ref2, result;
    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!obj) {
      return {};
    }
    result = {};
    ref2 = compactFlatten(properties);
    for (j = 0, len = ref2.length; j < len; j++) {
      prop = ref2[j];
      result[prop] = obj[prop];
    }
    return result;
  };

  ObjectExtensions.objectWithDefinedValues = function(obj) {
    return object(obj, {
      when: function(v) {
        return v !== void 0;
      }
    });
  };

  ObjectExtensions.objectWithExistingValues = function(obj) {
    return object(obj, {
      when: function(v) {
        return v != null;
      }
    });
  };

  ObjectExtensions.objectWithPresentValues = function(obj) {
    return object(obj, {
      when: function(v) {
        return present(v);
      }
    });
  };

  ObjectExtensions.objectWithout = function() {
    var anythingToDo, j, len, obj, prop, properties, result, v;
    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!obj) {
      return {};
    }
    if (properties.length === 1 && !(typeof properties[0] === "string")) {
      properties = properties[0];
    }
    anythingToDo = false;
    for (j = 0, len = properties.length; j < len; j++) {
      prop = properties[j];
      if (obj.hasOwnProperty(prop)) {
        anythingToDo = true;
        break;
      }
    }
    if (anythingToDo) {
      result = {};
      for (prop in obj) {
        v = obj[prop];
        if (indexOf.call(properties, prop) < 0) {
          result[prop] = v;
        }
      }
      return result;
    } else {
      return obj;
    }
  };

  ObjectExtensions.propertyIsPathed = propertyIsPathed = function(key) {
    return !!key.match(/[\s\.\/]/);
  };

  ObjectExtensions.withPropertyPath = withPropertyPath = function(obj, propertyPath, action) {
    var i, j, key, len;
    propertyPath = propertyPath.match(/[^\s\.\/]+/g);
    for (i = j = 0, len = propertyPath.length; j < len; i = ++j) {
      key = propertyPath[i];
      if (i === propertyPath.length - 1) {
        action(obj, key);
      } else {
        obj = obj[key] || (obj[key] = {});
      }
    }
    return obj;
  };

  ObjectExtensions.setPathedProperty = setPathedProperty = function(obj, propertyPath, value) {
    withPropertyPath(obj, propertyPath, function(o, k) {
      return o[k] = value;
    });
    return obj;
  };

  ObjectExtensions.expandPathedProperties = expandPathedProperties = function(obj, into, pathExpansionEnabled) {
    var k, v;
    if (into == null) {
      into = {};
    }
    if (pathExpansionEnabled == null) {
      pathExpansionEnabled = true;
    }
    for (k in obj) {
      v = obj[k];
      if (pathExpansionEnabled && propertyIsPathed(k)) {
        withPropertyPath(into, k, function(o, finalKey) {
          if (isPlainObject(v)) {
            return expandPathedProperties(v, o[finalKey] || (o[finalKey] = {}), true);
          } else {
            return o[finalKey] = v;
          }
        });
      } else if (isPlainObject(v)) {
        expandPathedProperties(v, into[k] || (into[k] = {}), false);
      } else {
        into[k] = v;
      }
    }
    return into;
  };

  return ObjectExtensions;

})();


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BlueBirdPromise, ErrorWithInfo, Promise, deepEach, deepMap, defineModule, getEnv, isFunction, isPlainObject, promiseDebug, ref;

Promise = BlueBirdPromise = __webpack_require__(300);

ref = __webpack_require__(4), deepMap = ref.deepMap, deepEach = ref.deepEach, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

defineModule = __webpack_require__(22).defineModule;

getEnv = __webpack_require__(27).getEnv;

if (promiseDebug = getEnv().artPromiseDebug) {
  console.log("Art.StandardLib.Promise: BlueBirdPromise debug ENABLED");
}

BlueBirdPromise.config({
  warnings: promiseDebug,
  longStackTraces: promiseDebug,
  cancellation: promiseDebug,
  monitoring: promiseDebug
});

ErrorWithInfo = __webpack_require__(142);


/*
ArtPromise extends ES6 Promises in the following ways:

- constructing a promise with no parameters is allowed
- promise.resolve and promise.reject are supported as
  alternative ways to resolve or reject a promise

If native promises are supported, they are used,
otherwise a polyfill is used.

TODO:
  ES6 says Promises are designed to be extensible:
  http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects

  If I properly extend Promise, will my new methods be available on all promise objects... ???
    At least all promises chained off of one created using my Promise class... ???

  But I had problems doing that. Maybe it's how CoffeeScript extends things?

TODO:
  I want a way to do 'then' and 'catch' without effecting any following 'thens' or 'caches'

  It's easy to implement, but what to call it? Leaning towards tapThen. If I had Ruby's 'tap', then
  I could do this effectively with:

    .tap (a) -> a.then ->
    but
    .tapThen ->
    is even nicer

  Will it be available on returned promises?
    (see ES6 Promise extension above)

  tapThen: (successF, failF) ->
    @then successF, failF
    @ # return the current promise, not the one returned from the then-call above
 */

defineModule(module, function() {
  var ArtPromise, k, v;
  ArtPromise = (function() {
    var deepAll, isPromise, noop;

    function ArtPromise() {}

    ArtPromise.isPromise = isPromise = function(f) {
      return isFunction(f != null ? f.then : void 0);
    };

    ArtPromise.testPromise = function(promise) {
      promise.then(function(v) {
        return console.log("promise.resolve", v);
      });
      return promise["catch"](function(v) {
        return console.log("promise.reject", v);
      });
    };

    ArtPromise.mapAll = function(map) {
      var key, keys;
      keys = Object.keys(map);
      return Promise.all((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = keys.length; j < len; j++) {
          key = keys[j];
          results.push(map[key]);
        }
        return results;
      })()).then(function(values) {
        var i, j, key, len, out;
        out = {};
        for (i = j = 0, len = keys.length; j < len; i = ++j) {
          key = keys[i];
          out[key] = values[i];
        }
        return out;
      });
    };

    ArtPromise.containsPromises = function(plainStructure) {
      var containsPromises;
      containsPromises = false;
      deepEach(plainStructure, function(v) {
        return containsPromises || (containsPromises = isPromise(v));
      });
      return containsPromises;
    };


    /*
    For use with Node-style callbacks:
      IN: (error, data) ->
        error: null or set if there was an error
        data: set if error is null
    
    Example:
      Promise.withCallback (callback) ->
        doAsyncStuff -> callback()
     */

    ArtPromise.withCallback = function(startPromiseBodyFunction) {
      return new BlueBirdPromise(function(resolve, reject) {
        var callback;
        callback = function(err, data) {
          if (err) {
            return reject(new Error(err));
          }
          return resolve(data);
        };
        return startPromiseBodyFunction(callback);
      });
    };

    ArtPromise.newExternallyResolvable = function() {
      var out, p;
      out = {};
      p = new BlueBirdPromise(function(resolve, reject) {
        out.resolve = resolve;
        return out.reject = reject;
      });
      p.resolve = out.resolve;
      p.reject = out.reject;
      return p;
    };

    noop = function(a) {
      return a;
    };

    ArtPromise.deepAll = deepAll = function(plainStructure, resolvedResultPreprocessor) {
      var promises;
      if (resolvedResultPreprocessor == null) {
        resolvedResultPreprocessor = noop;
      }
      promises = [];
      deepEach(plainStructure, function(v) {
        if (isPromise(v)) {
          return promises.push(v);
        }
      });
      return Promise.all(promises).then(function(resolved) {
        var i;
        i = 0;
        return deepMap(plainStructure, function(v) {
          if (isPromise(v)) {
            return resolvedResultPreprocessor(resolved[i++]);
          } else {
            return v;
          }
        });
      });
    };

    ArtPromise.deepResolve = deepAll;


    /*
    Serializer makes it easy to ensure promise-returning functions are invoked in order, after each
    promise is resolved.
    
    USAGE:
    
       * EXAMPLE 1: Basic - not too different from normal Promise sequences
      serializer = new ArtPromise.Serializer
      serializer.then -> doA()
    
       * then execute sometime later, possbly asynchronously:
      serializer.then -> doB()
    
       * then execute sometime later, possbly asynchronously:
      serializer.then (doBResult) ->
         * doA and doB have completed and any returning promises resolved
         * the result of the last 'then' is passed in
    
       * EXAMPLE 2: apply the same async function serially to each element in list
       * - list's order is preserved
       * - each invocation waits for the previous one to complete
      serializer = new ArtPromise.Serializer
      list.forEach serializer.serialize f = (element) -> # do something with element, possibly returning a promise
      serializer.then (lastFResult) ->
         * do something after the last invocation of f completes
         * the result of the last invocation of 'f' is passed in
    
       * EXAMPLE 3: mix multiple serialized functions and manual @then invocations
       * - invocation order is perserved
      serializer = new ArtPromise.Serializer
      serializedA = serializer.serialize aFunction
      serializedB = serializer.serialize bFunction
    
      serializedB()
      serializer.then -> @cFunction()
      serializedB()
      serializedA()
      serializedB()
    
      serializer.then (lastBFunctionResult) ->
         * this is invoked AFTER:
         * evaluating, in order, waiting for any promises:
         *   bFunction, cFunction, bFunction, aFunction, bFunction
     */

    ArtPromise.Serializer = (function() {
      function Serializer() {
        this._lastPromise = BlueBirdPromise.resolve();
      }


      /*
      Returns a new function, serializedF, that acts just like 'f'
        - f is forced to be async:
          - if f doesn't return a promise, a promise wrapping f's result is returned
        - invoking serializedF queues f in this serializer instance's sequence via @then
      IN: any function with any signature
      OUT: (f's signature) -> promise.then (fResult) ->
      
      Example with Comparison:
      
         * all asyncActionReturningPromise(element)s get called immediately
         * and may complete randomly at some later event
        myArray.forEach (element) ->
          asyncActionReturningPromise element
      
         * VS
      
         * asyncActionReturningPromise(element) only gets called
         * after the previous call completes.
         * If a previous call failes, the remaining calls never happen.
        serializer = new Promise.Serializer
        myArray.forEach serializer.serialize (element) ->
          asyncActionReturningPromise element
      
         * bonus, you can do things when all the promises complete:
        serializer.then =>
      
         * or if anything fails
        serializer.catch =>
      
         * VS - shortcut
      
         * Just insert "Promise.serialize" before your forEach function to ensure serial invocations.
         * However, you don't get the full functionality of the previous example.
        myArray.forEach Promise.serialize (element) ->
          asyncActionReturningPromise element
       */

      Serializer.prototype.serialize = function(f) {
        return (function(_this) {
          return function() {
            var args;
            args = arguments;
            return _this.then(function() {
              return f.apply(null, args);
            });
          };
        })(this);
      };

      Serializer.prototype.then = function(resolved, rejected) {
        return this._lastPromise = this._lastPromise.then(resolved, rejected);
      };

      Serializer.prototype["catch"] = function(rejected) {
        return this._lastPromise = this._lastPromise["catch"](rejected);
      };

      Serializer.prototype.always = function(f) {
        return this._lastPromise = this._lastPromise["catch"]((function(_this) {
          return function() {
            return null;
          };
        })(this)).then(f);
      };


      /*
      OUT: promise that resolves / rejects only when there are no more
        pending tasks queued with the serializer.
      
        .then (lastResult) ->
        .catch (lastError) ->
      
      NOTE: allDonePromise could complete, then more tasks could be queued with the serializer.
        Promises can't be resolved/rejected twice, so when the more-tasks complete, the first
        allDonePromise won't do anything.
        However, you can call allDonePromise again once the tasks are queued and get notified
        when THEY are done.
       */

      Serializer.prototype.allDonePromise = function() {
        var currentLastPromise;
        currentLastPromise = this._lastPromise;
        return currentLastPromise.then((function(_this) {
          return function(lastResult) {
            if (currentLastPromise === _this._lastPromise) {
              return lastResult;
            } else {
              return _this.allDonePromise();
            }
          };
        })(this))["catch"]((function(_this) {
          return function(lastError) {
            if (currentLastPromise === _this._lastPromise) {
              throw lastError;
            } else {
              return _this.allDonePromise();
            }
          };
        })(this));
      };

      return Serializer;

    })();


    /*
    OUT: serializedF = -> Promise.resolve f arguments...
      IN: any arguments
      EFFECT: f is invoked with arguments passed in AFTER the last invocation of serializedF completes.
      OUT: promise.then -> results from f
    
    NOTE: 'f' can return a promise, but it doesn't have to. If it does return a promise, the next
      'f' invocation will not start until and if the previous one's promise completes.
    
    USAGE:
      serializedF = Promise.serialize f = -> # do something, possibly returning a promise
      serializedF()
      serializedF()
      serializedF()
      .then (resultOfLastF)->
         * executed after f was executed and any returned promises resolved, 3 times, sequentially
    
    OR
      serializedF = Promise.serialize f = (element) -> # do something with element, possibly returning a promise
      Promise.all (serializedF item for item in list)
      .then (results) ->
         * f was excuted list.length times sequentially
         * results contains the result values from each execution, in order
     */

    ArtPromise.serialize = function(f) {
      return new ArtPromise.Serializer().serialize(f);
    };

    ArtPromise.invert = function(promise) {
      return promise.then(function(e) {
        throw new ErrorWithInfo("" + e, e);
      }, function(v) {
        return v;
      });
    };

    ArtPromise["finally"] = function(promise, action) {
      return BlueBirdPromise.resolve(promise)["finally"](action);
    };

    ArtPromise.then = BlueBirdPromise["try"];

    return ArtPromise;

  })();
  for (k in ArtPromise) {
    v = ArtPromise[k];
    BlueBirdPromise[k] || (BlueBirdPromise[k] = v);
  }
  return BlueBirdPromise;
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 30 */
/***/ (function(module, exports) {

var RegExpExtensions;

module.exports = RegExpExtensions = (function() {
  var k, lc, ref, v;

  function RegExpExtensions() {}

  RegExpExtensions.escapeRegExp = function(string) {
    return string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  RegExpExtensions.findUrlProtocolRegExp = /([\w-]+)(:\/\/)/;

  RegExpExtensions.findDomainRegExp = /localhost|[\w]+(?:-[\w]+)*(?:\.[\w]+(?:-[\w]+)*)*(?:\.[a-z]{2,20})/;

  RegExpExtensions.urlQueryParamsRegExp = /(?:[-+=&*._\w]|%[a-f\d]{2})*(?!\.)(?:[-+=&*._\w]|%[a-f\d]{2})/i;

  RegExpExtensions.findLegalUrlCharacterRegExp = /[-._~!$&'()*+,;=:@\w]|%[a-f\d]{2}/;

  RegExpExtensions.findUrlPathRegExp = RegExp("(?:\\/(?:(?:" + RegExpExtensions.findLegalUrlCharacterRegExp.source + ")*(?!\\.)(?:" + RegExpExtensions.findLegalUrlCharacterRegExp.source + "))?)*");

  RegExpExtensions.findUrlPortRegExp = /(\:)(\d+)/;

  RegExpExtensions.findUrlFragmentRegExp = RegExp("(\\#)((?:(?:\\?|" + RegExpExtensions.findLegalUrlCharacterRegExp.source + ")*(?!\\.)" + RegExpExtensions.findLegalUrlCharacterRegExp.source + "|))");

  RegExpExtensions.findEmailRegExp = RegExp("([_\\w-]+(?:\\.[_\\w]+)*)@(" + RegExpExtensions.findDomainRegExp.source + ")", "i");

  RegExpExtensions.emailRegExp = RegExp("^" + RegExpExtensions.findEmailRegExp.source + "$", "i");

  RegExpExtensions.numberRegExp = /([-]?\.[0-9]+)|([-]?[0-9]+(\.[0-9]+)?)/;

  RegExpExtensions.urlProtocolRegExp = RegExp("^" + RegExpExtensions.findUrlProtocolRegExp.source + "$", "i");

  RegExpExtensions.domainRegExp = RegExp("^" + RegExpExtensions.findDomainRegExp.source + "$", "i");

  RegExpExtensions.urlPathRegExp = RegExp("^" + RegExpExtensions.findUrlPathRegExp.source + "$", "i");

  RegExpExtensions.urlQueryRegExp = RegExp("^" + RegExpExtensions.urlQueryParamsRegExp.source + "$", "i");

  RegExpExtensions.isoDateRegExp = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;

  RegExpExtensions.hex16ColorRegExp = /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i;

  RegExpExtensions.hex256ColorRegExp = /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i;

  RegExpExtensions.rgbColorRegExp = /rgb *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *\)/;

  RegExpExtensions.rgbaColorRegExp = /rgba *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *, *(\d*\.?\d*)\)/;

  RegExpExtensions.colorRegExp = new RegExp("(" + RegExpExtensions.hex16ColorRegExp.source + ")|(" + RegExpExtensions.hex256ColorRegExp.source + ")|(" + RegExpExtensions.rgbColorRegExp.source + ")|(" + RegExpExtensions.rgbaColorRegExp.source + ")");

  RegExpExtensions.findColorRegExp = /\#[a-f0-9]{8}\b|\#[a-f0-9]{6}\b|\#[a-f0-9]{3,4}\b|rgba? *\( *\d+%? *, *\d+%? *, *\d+%?(?: *,(?:\d+)|(?:\d*\.?\d+)) *\)/i;

  RegExpExtensions.wordsRegExp = /[^\s]+/g;

  RegExpExtensions.exactlyOneWordRegExp = /^[^\s]+$/;


  /*
  match OUTPUT: [url, protocol, '://', domain, ':', port, path, '?', query]
  
  USAGE:
    [__, protocol, __, domain, __, port, path, __, query, __, fragment] = str.match findUrlRegExp
  
  DESIGN NOTE:
    The reason why I included the fixed strings ('://', ':' and '?') was so that
    you can take the matchResult, alter individual elements and create a value url easily by:
  
      matchResult.slice(1).join ''
   */

  RegExpExtensions.findUrlRegExp = RegExp("(?:" + RegExpExtensions.findUrlProtocolRegExp.source + ")(" + RegExpExtensions.findDomainRegExp.source + ")(?:" + RegExpExtensions.findUrlPortRegExp.source + ")?(" + RegExpExtensions.findUrlPathRegExp.source + ")?(?:(\\?)(" + RegExpExtensions.urlQueryParamsRegExp.source + ")?)?(?:" + RegExpExtensions.findUrlFragmentRegExp.source + ")?", "i");

  RegExpExtensions.findUrlWithOptionalProtocolRegExp = RegExp("(?:" + RegExpExtensions.findUrlProtocolRegExp.source + ")?(" + RegExpExtensions.findDomainRegExp.source + ")(?:" + RegExpExtensions.findUrlPortRegExp.source + ")?(" + RegExpExtensions.findUrlPathRegExp.source + ")?(?:(\\?)(" + RegExpExtensions.urlQueryParamsRegExp.source + ")?)?(?:" + RegExpExtensions.findUrlFragmentRegExp.source + ")?", "i");

  RegExpExtensions.findAllUrlsRegExp = RegExp("" + RegExpExtensions.findUrlRegExp.source, "ig");

  RegExpExtensions.findAllUrlsWithOptionalProtocolRegExp = RegExp("" + RegExpExtensions.findUrlWithOptionalProtocolRegExp.source, "ig");

  RegExpExtensions.findSourceReferenceUrlRegExp = RegExp("(" + RegExpExtensions.findUrlProtocolRegExp.source + ")(" + RegExpExtensions.findDomainRegExp.source + ")?(?:" + RegExpExtensions.findUrlPortRegExp.source + ")?(" + RegExpExtensions.findUrlPathRegExp.source + ")?(?:(\\?)(" + RegExpExtensions.urlQueryParamsRegExp.source + ")?)?(?:\\:(\\d+))?(?:\\:(\\d+))?", "i");

  RegExpExtensions.urlRegExp = RegExp("^" + RegExpExtensions.findUrlRegExp.source + "$", "i");

  RegExpExtensions.urlWithOptionalProtocolRegExp = RegExp("^" + RegExpExtensions.findUrlWithOptionalProtocolRegExp.source + "$", "i");

  ref = RegExpExtensions;
  for (k in ref) {
    v = ref[k];
    if (!(/RegExp$/.test(k))) {
      continue;
    }
    RegExpExtensions[k.replace(/RegExp/, "Regexp")] = v;
    RegExpExtensions[k.replace(/RegExp/, "Regex")] = v;
  }

  lc = function(s) {
    return s.toLocaleLowerCase();
  };

  RegExpExtensions.normalizeUrl = function(url) {
    var ref1;
    url = ((ref1 = RegExpExtensions.findUrlProtocolRegExp.exec(url)) != null ? ref1.index : void 0) === 0 ? url : "http://" + url;
    return url.replace(RegExpExtensions.findDomainRegExp, lc).replace(RegExpExtensions.findUrlProtocolRegExp, lc);
  };

  return RegExpExtensions;

})();


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(184)).addNamespace('Atomic', Atomic = (function(superClass) {
  extend(Atomic, superClass);

  function Atomic() {
    return Atomic.__super__.constructor.apply(this, arguments);
  }

  Atomic.version = __webpack_require__(161).version;

  return Atomic;

})(Neptune.PackageNamespace));


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, AtomicBase, Foundation, Point, Rectangle, bound, ceil, float32Precision, floatEq, floatEq0, floor, isArray, isFunction, isNumber, isString, log, max, min, point, round, stringToNumberArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(31);

AtomicBase = __webpack_require__(19);

Point = __webpack_require__(25);

max = Foundation.max, min = Foundation.min, bound = Foundation.bound, round = Foundation.round, floatEq = Foundation.floatEq, floor = Foundation.floor, ceil = Foundation.ceil, round = Foundation.round, log = Foundation.log, isNumber = Foundation.isNumber, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, stringToNumberArray = Foundation.stringToNumberArray, floatEq0 = Foundation.floatEq0, float32Precision = Foundation.float32Precision;

point = Point.point;

module.exports = Rectangle = (function(superClass) {
  var rect;

  extend(Rectangle, superClass);

  function Rectangle() {
    return Rectangle.__super__.constructor.apply(this, arguments);
  }

  Rectangle.defineAtomicClass({
    fieldNames: "x y w h",
    constructorFunctionName: "rect"
  });

  Rectangle.isRect = function(v) {
    return (v != null ? v.constructor : void 0) === Rectangle;
  };

  Rectangle.rect = rect = function(a, b, c, d) {
    if (a instanceof Rectangle) {
      return a;
    }
    return new Rectangle(a, b, c, d);
  };

  Rectangle.prototype._initFromObject = function(o) {
    this.x = o.x || 0;
    this.y = o.y || 0;
    this.w = o.w || 0;
    return this.h = o.h || 0;
  };

  Rectangle.prototype._init = function(a, b, c, d) {
    this.x = this.y = this.w = this.h = 0;
    if (d != null) {
      this.x = a - 0;
      this.y = b - 0;
      this.w = c - 0;
      return this.h = d - 0;
    } else if (b != null) {
      if (b instanceof Point) {
        this.x = a.x;
        this.y = a.y;
        this.w = b.w;
        return this.h = b.h;
      } else {
        this.w = a - 0;
        return this.h = b - 0;
      }
    } else if (a instanceof Point) {
      this.w = a.w;
      return this.h = a.h;
    } else if (a != null) {
      return this.w = this.h = a - 0;
    }
  };

  Rectangle.getter({
    location: function() {
      return new Point(this.x, this.y);
    },
    locationMatrix: function() {
      return Atomic.Matrix.translateXY(this.x, this.y);
    },
    size: function() {
      return new Point(this.w, this.h);
    },
    width: function() {
      return this.w;
    },
    height: function() {
      return this.h;
    },
    rounded: function() {
      return this["with"](round(this.x), round(this.y), round(this.w), round(this.h));
    },
    tl: function() {
      return new Point(this.x, this.y);
    },
    tc: function() {
      return new Point(this.hCenter, this.y);
    },
    tr: function() {
      return new Point(this.right, this.y);
    },
    lc: function() {
      return new Point(this.x, this.vCenter);
    },
    cc: function() {
      return new Point(this.hCenter, this.vCenter);
    },
    rc: function() {
      return new Point(this.right, this.vCenter);
    },
    bl: function() {
      return new Point(this.x, this.bottom);
    },
    bc: function() {
      return new Point(this.hCenter, this.bottom);
    },
    br: function() {
      return new Point(this.right, this.bottom);
    },
    topLeft: function() {
      return new Point(this.x, this.y);
    },
    topCenter: function() {
      return new Point(this.hCenter, this.y);
    },
    topRight: function() {
      return new Point(this.right, this.y);
    },
    centerLeft: function() {
      return new Point(this.x, this.vCenter);
    },
    centerCenter: function() {
      return new Point(this.hCenter, this.vCenter);
    },
    centerRight: function() {
      return new Point(this.right, this.vCenter);
    },
    bottomLeft: function() {
      return new Point(this.x, this.bottom);
    },
    bottomCenter: function() {
      return new Point(this.hCenter, this.bottom);
    },
    bottomRight: function() {
      return new Point(this.right, this.bottom);
    },
    locationIsZero: function() {
      return floatEq(this.x, 0) && floatEq(this.y, 0);
    },
    top: function() {
      return this.y;
    },
    left: function() {
      return this.x;
    },
    right: function() {
      return this.x + this.w;
    },
    bottom: function() {
      return this.y + this.h;
    },
    hCenter: function() {
      return this.x + this.w * .5;
    },
    vCenter: function() {
      return this.y + this.h * .5;
    },
    infinite: function() {
      return this.w === 2e308 || this.h === 2e308;
    },
    normalized: function() {
      var h, w, x, y;
      w = this.w;
      h = this.h;
      if (w >= 0 && h >= 0) {
        return this;
      } else {
        x = this.x;
        y = this.y;
        if (w < 0) {
          x += w;
          w = -w;
        }
        if (h < 0) {
          y += h;
          h = -h;
        }
        return this["with"](x, y, w, h);
      }
    },
    area: function() {
      return this.w * this.h;
    },
    corners: function() {
      var bottom, left, right, top;
      left = this.left;
      top = this.top;
      right = this.right;
      bottom = this.bottom;
      return [new Point(left, top), new Point(right, top), new Point(right, bottom), new Point(left, bottom)];
    }
  });

  Rectangle.prototype.withXY = function(x, y) {
    if (floatEq(x, this.x) && floatEq(y, this.y)) {
      return this;
    } else {
      return new Rectangle(x, y, this.w, this.h);
    }
  };

  Rectangle.prototype.withWH = function(w, h) {
    if (floatEq(w, this.w) && floatEq(h, this.h)) {
      return this;
    } else {
      return new Rectangle(this.x, this.y, w, h);
    }
  };

  Rectangle.prototype.withLocation = function(v) {
    return this.withXY(v.x, v.y);
  };

  Rectangle.prototype.withSize = function(v) {
    return this.withWH(v.x, v.y);
  };

  Rectangle.prototype.movedBy = function(d) {
    return this.withXY(this.x + d.x, this.y + d.y);
  };

  Rectangle.prototype.nearestInsidePoint = function(p) {
    return new Point(bound(this.left, p.x, this.right), bound(this.top, p.y, this.bottom));
  };

  Rectangle.prototype.largestInsideRect = function(ofSize) {
    var h, scaler, w;
    scaler = min(this.w / ofSize.w, this.h / ofSize.h);
    w = ofSize.w * scale;
    h = ofSize.h * scale;
    return new Rectangle((this.w - w) / 2, (this.h - h) / 2, w, h);
  };

  Rectangle.prototype.overlaps = function(val) {
    if (val == null) {
      return false;
    }
    if (val instanceof Point) {
      return this.contains(val);
    } else if (val instanceof Rectangle) {
      return val.getRight() > this.getLeft() && val.getBottom() > this.getTop() && val.getLeft() < this.getRight() && val.getTop() < this.getBottom();
    } else {
      throw new Error("Invalid arguments for 'overlaps'. Expecting Point or Rectangle. Got: " + val + ".");
    }
  };

  Rectangle.prototype.contains = function(val) {
    if (val == null) {
      return false;
    }
    if (val instanceof Point) {
      return val.x >= this.x && val.y >= this.y && val.x < this.right && val.y < this.bottom;
    } else if (val instanceof Rectangle) {
      return val.x >= this.x && val.y >= this.y && val.right <= this.right && val.bottom <= this.bottom;
    } else {
      throw new Error("Invalid arguments for 'contains'. Expecting Point or Rectangle. Got: " + val + ".");
    }
  };

  Rectangle.prototype.round = function(m) {
    var h, w, x, y;
    if (m == null) {
      m = 1;
    }
    x = round(this.x, m);
    y = round(this.y, m);
    w = round(this.x + this.w, m) - x;
    h = round(this.y + this.h, m) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.roundOut = function(m, k) {
    var h, w, x, y;
    if (m == null) {
      m = 1;
    }
    if (k == null) {
      k = float32Precision;
    }
    x = floor(this.x + k, m);
    y = floor(this.y + k, m);
    w = ceil(this.x + this.w - k, m) - x;
    h = ceil(this.y + this.h - k, m) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.roundIn = function(m, k) {
    var h, w, x, y;
    if (m == null) {
      m = 1;
    }
    if (k == null) {
      k = float32Precision;
    }
    x = ceil(this.x - k, m);
    y = ceil(this.y - k, m);
    w = floor(this.x + this.w + k, m) - x;
    h = floor(this.y + this.h + k, m) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.union = function(b) {
    var h, w, x, y;
    if (b == null) {
      return this;
    }
    if (this.getArea() <= 0) {
      return b;
    }
    x = min(this.x, b.left);
    y = min(this.y, b.top);
    w = max(this.getRight(), b.getRight()) - x;
    h = max(this.getBottom(), b.getBottom()) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.unionInto = function(into) {
    var area, h, intoArea, w, x, y;
    if (into == null) {
      return new Rectangle(this.x, this.y, this.w, this.h);
    }
    area = this.getArea();
    intoArea = into.getArea();
    if (area <= 0 || intoArea === 2e308) {
      return into;
    }
    if (intoArea <= 0 || area === 2e308) {
      into.x = this.x;
      into.y = this.y;
      into.w = this.w;
      into.h = this.h;
    } else {
      x = into.x, y = into.y, w = into.w, h = into.h;
      into.x = min(x, this.x);
      into.y = min(y, this.y);
      into.w = max(x + w, this.x + this.w) - into.x;
      into.h = max(y + h, this.y + this.h) - into.y;
    }
    return into;
  };

  Rectangle.prototype.intersectInto = function(into) {
    var area, h, intoArea, w, x, y;
    if (into == null) {
      return new Rectangle(this.x, this.y, this.w, this.h);
    }
    area = this.getArea();
    intoArea = into.getArea();
    if (intoArea <= 0 || area === 2e308) {
      return into;
    }
    if (area <= 0 || intoArea === 2e308) {
      into.x = this.x;
      into.y = this.y;
      into.w = this.w;
      return into.h = this.h;
    } else {
      x = into.x, y = into.y, w = into.w, h = into.h;
      into.x = max(x, this.x);
      into.y = max(y, this.y);
      into.w = max(0, min(x + w, this.x + this.w) - into.x);
      into.h = max(0, min(y + h, this.y + this.h) - into.y);
      return into;
    }
  };

  Rectangle.prototype.intersection = function(b) {
    var h, w, x, y;
    if (b == null) {
      return this;
    }
    if (b.getArea() === 2e308 || b.contains(this)) {
      return this;
    }
    if (this.getArea() === 2e308 || this.contains(b)) {
      return b;
    }
    x = max(this.x, b.left);
    y = max(this.y, b.top);
    w = min(this.getRight(), b.getRight()) - x;
    h = min(this.getBottom(), b.getBottom()) - y;
    if (w <= 0 || h <= 0) {
      return Rectangle.nothing;
    } else {
      return this["with"](x, y, w, h);
    }
  };

  Rectangle.prototype.grow = function(a, b) {
    var x, y;
    if (a instanceof Point) {
      x = a.x, y = a.y;
    } else {
      x = a;
      y = b != null ? b : a;
    }
    if (floatEq0(x) && floatEq0(y)) {
      return this;
    }
    return this["with"](this.x - x, this.y - y, this.w + 2 * x, this.h + 2 * y);
  };

  Rectangle.nothing = Object.freeze(new Rectangle(0, 0, 0, 0));

  Rectangle.everything = Object.freeze(new Rectangle(0, 0, 2e308, 2e308));

  Rectangle.prototype.withRect = function(a, b, c, d) {
    return this["with"](a, b, c, d);
  };

  Rectangle.prototype.cutout = function(r) {
    var bottom, h, out, outX, rBottom, rRight, ref, right, w, x, y;
    if (!this.overlaps(r)) {
      return [this];
    }
    ref = this, x = ref.x, y = ref.y, w = ref.w, h = ref.h, right = ref.right, bottom = ref.bottom;
    out = [];
    if (r.x > x) {
      out.push(new Rectangle(x, y, r.x - x, h));
    }
    if ((rRight = r.right) < right) {
      out.push(new Rectangle(rRight, y, right - rRight, h));
    }
    if (r.y > y) {
      out.push(new Rectangle(outX = max(r.x, x), y, min(rRight, right) - outX, r.y - y));
    }
    if ((rBottom = r.bottom) < bottom) {
      out.push(new Rectangle(outX = max(r.x, x), rBottom, min(rRight, right) - outX, bottom - rBottom));
    }
    return out;
  };

  return Rectangle;

})(AtomicBase);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(210);


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ConfigRegistry, Promise, clone, compactFlatten, deepMerge, defineModule, expandPathedProperties, formattedInspect, inspect, isPlainObject, isString, log, merge, mergeInto, parseQuery, pushIfNotPresent, ref, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, inspect = ref.inspect, formattedInspect = ref.formattedInspect, merge = ref.merge, deepMerge = ref.deepMerge, mergeInto = ref.mergeInto, parseQuery = ref.parseQuery, pushIfNotPresent = ref.pushIfNotPresent, isPlainObject = ref.isPlainObject, isString = ref.isString, upperCamelCase = ref.upperCamelCase, expandPathedProperties = ref.expandPathedProperties, clone = ref.clone, compactFlatten = ref.compactFlatten;

BaseObject = __webpack_require__(3).BaseObject;

defineModule(module, ConfigRegistry = (function(superClass) {
  extend(ConfigRegistry, superClass);

  function ConfigRegistry() {
    return ConfigRegistry.__super__.constructor.apply(this, arguments);
  }

  ConfigRegistry.configurables = [];

  ConfigRegistry.configs = {};

  ConfigRegistry.registerConfig = function(name, config) {
    if (!isPlainObject(config)) {
      throw new Error("config must be a plain object");
    }
    return ConfigRegistry.configs[name] = config;
  };

  ConfigRegistry.registerConfigurable = function(configurable) {
    return pushIfNotPresent(ConfigRegistry.configurables, configurable);
  };

  ConfigRegistry.configure = function() {
    var args, ref1;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    console.error("DEPRICATED: use Art.Config.configure");
    return (ref1 = Neptune.Art.Config).configure.apply(ref1, args);
  };

  return ConfigRegistry;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, BaseClass, config, defineModule,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defineModule = __webpack_require__(0).defineModule;

BaseClass = __webpack_require__(3).BaseClass;

ArtEry = __webpack_require__(20);

config = __webpack_require__(11).config;

defineModule(module, ArtEryBaseObject = (function(superClass) {
  extend(ArtEryBaseObject, superClass);

  function ArtEryBaseObject() {
    return ArtEryBaseObject.__super__.constructor.apply(this, arguments);
  }

  ArtEryBaseObject.abstractClass();

  ArtEryBaseObject.getter({
    pipelines: function() {
      return ArtEry.pipelines;
    }
  });

  return ArtEryBaseObject;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(109);

module.exports.includeInNamespace(__webpack_require__(226)).addModules({
  AfterEventsFilter: __webpack_require__(58),
  DataUpdatesFilter: __webpack_require__(103),
  LinkFieldsFilter: __webpack_require__(104),
  TimestampFilter: __webpack_require__(105),
  Tools: __webpack_require__(106),
  UniqueIdFilter: __webpack_require__(107),
  UserOwnedFilter: __webpack_require__(108),
  UuidFilter: __webpack_require__(227),
  ValidationFilter: __webpack_require__(59)
});


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var ArtEry, BaseObject, CommunicationStatus, Foundation, Promise, Request, RestClient, Validator, _validator, arrayWith, each, inspect, isFunction, isObject, isPlainObject, isString, log, merge, missing, object, objectHasKeys, objectKeyCount, objectWithout, present, ref, requestConstructorValidator, success, validStatus, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = Foundation = __webpack_require__(2), each = ref.each, present = ref.present, Promise = ref.Promise, BaseObject = ref.BaseObject, RestClient = ref.RestClient, merge = ref.merge, inspect = ref.inspect, isString = ref.isString, isObject = ref.isObject, log = ref.log, Validator = ref.Validator, CommunicationStatus = ref.CommunicationStatus, arrayWith = ref.arrayWith, w = ref.w, objectKeyCount = ref.objectKeyCount, isString = ref.isString, isPlainObject = ref.isPlainObject, objectWithout = ref.objectWithout, isFunction = ref.isFunction, object = ref.object, objectHasKeys = ref.objectHasKeys;

ArtEry = __webpack_require__(20);

success = CommunicationStatus.success, missing = CommunicationStatus.missing, validStatus = CommunicationStatus.validStatus;

_validator = null;

requestConstructorValidator = function() {
  return _validator || (_validator = new Validator({
    pipeline: {
      required: {
        "instanceof": ArtEry.Pipeline
      }
    },
    type: {
      required: {
        fieldType: "string"
      }
    },
    session: {
      required: {
        fieldType: "object"
      }
    },
    parentRequest: {
      "instanceof": ArtEry.Request
    },
    originatedOnServer: "boolean",
    props: "object",
    key: "string"
  }));
};


/*
new Request(options)

IN: options:
  see requestConstructorValidator for the validated options
  below are special-case options

   * aliases
  data: >> @props.data
  key:  >> @props.key

  NOTE: Request doesn't care about @data, the alias is proved only as a convenience
  NOTE: Request only cares about @key for two things:
    - REST urls
    - cachedGet

    In general, type: "get" and key: "string" is a CACHEABLE request.
    This is why it must be a string.
    Currently there are no controls for HOW cacheable type-get is, though.
    All other requests are NOT cacheable.

CONCEPTS

  context:

    This is the only mutable part of the request. It establishes one shared context for
    a request, all its clones, subrequests, responses and response clones.

    The primary purpose is for subrequests to coordinate their actions with the primary
    request. Currently this is only used server-side.

    There are two contexts when using a remote server: The client-side context is not
    shared with the server-side context. A new context is created server-side when
    responding to the request.

    BUT - there is only one context if location == "both" - if we are running without
    a remote server.
 */

module.exports = Request = (function(superClass) {
  var getRestClientParamsForArtEryRequest, restMap;

  extend(Request, superClass);

  function Request(options) {
    var key, ref1, ref2;
    Request.__super__.constructor.apply(this, arguments);
    this.type = options.type, this.pipeline = options.pipeline, this.session = options.session, this.parentRequest = options.parentRequest, this.originatedOnServer = options.originatedOnServer, this.props = (ref1 = options.props) != null ? ref1 : {}, this.context = (ref2 = options.context) != null ? ref2 : {};
    key = this._props.key || options.key;
    if (key != null) {
      options.key = this._props.key = this.pipeline.toKeyString(key);
    }
    requestConstructorValidator().validate(options, {
      context: "Art.Ery.Request options",
      logErrors: true
    });
    if (options.requestOptions) {
      throw new Error("options.requestOptions is DEPRICATED - use options.props");
    }
    if (options.key != null) {
      this._props.key = options.key;
    }
    if (options.data != null) {
      this._props.data = options.data;
    }
  }

  Request.property("type pipeline session originatedOnServer parentRequest props data key context");

  Request.getter({
    key: function() {
      return this._props.key;
    },
    data: function() {
      return this._props.data;
    },
    requestData: function() {
      return this._props.data;
    },
    requestProps: function() {
      return this._props;
    },
    requestOptions: function() {
      throw new Error("DEPRICATED: use props");
    },
    description: function() {
      return this.requestString + " request";
    }
  });

  Request.getter("subrequestCount", {
    request: function() {
      return this;
    },
    shortInspect: function() {
      return "" + (this.parentRequest ? this.parentRequest.shortInspect + " > " : "") + (this.pipeline.getName()) + "-" + this.type + "(" + (this.key || '') + ")";
    },
    beforeFilterLog: function() {
      return this.filterLog || [];
    },
    afterFilterLog: function() {
      return [];
    },
    isSuccessful: function() {
      return true;
    },
    notSuccessful: function() {
      return false;
    },
    isRequest: function() {
      return true;
    },
    isRootRequest: function() {
      return !this.parentRequest;
    },
    requestPipelineAndType: function() {
      return this.pipeline.name + "-" + this.type;
    },
    propsForClone: function() {
      return {
        pipeline: this.pipeline,
        type: this.type,
        props: this.props,
        session: this.session,
        parentRequest: this.parentRequest,
        filterLog: this.filterLog,
        originatedOnServer: this.originatedOnServer,
        context: this.context
      };
    },
    urlKeyClause: function() {
      if (present(this.key)) {
        return "/" + this.key;
      } else {
        return "";
      }
    }
  });

  Request.prototype.handled = function(_handledBy) {
    return this.success().then(function(response) {
      return response.handled(_handledBy);
    });
  };

  Request.prototype.getRestRequestUrl = function(server) {
    return server + "/" + this.pipeline.name + this.urlKeyClause;
  };

  Request.prototype.getNonRestRequestUrl = function(server) {
    return server + "/" + this.pipeline.name + "-" + this.type + this.urlKeyClause;
  };

  restMap = {
    get: "get",
    create: "post",
    update: "put",
    "delete": "delete"
  };

  Request.getRestClientParamsForArtEryRequest = getRestClientParamsForArtEryRequest = function(arg) {
    var data, hasSessionData, key, method, restPath, server, session, type, url, urlKeyClause;
    session = arg.session, server = arg.server, restPath = arg.restPath, type = arg.type, key = arg.key, data = arg.data;
    urlKeyClause = present(key) ? "/" + key : "";
    server || (server = "");
    hasSessionData = objectHasKeys(session);
    url = (method = restMap[type]) && (method !== "get" || !hasSessionData) ? "" + server + restPath + urlKeyClause : (method = "post", "" + server + restPath + "-" + type + urlKeyClause);
    return {
      method: method,
      url: url,
      data: data
    };
  };

  Request.getter({
    remoteRequestProps: function() {
      var data, key, pipeline, props, propsCount, ref1, remoteRequestData, session, type;
      ref1 = this, session = ref1.session, data = ref1.data, props = ref1.props, pipeline = ref1.pipeline, type = ref1.type, key = ref1.key;
      propsCount = 0;
      props = object(props, {
        when: function(v, k) {
          return v !== void 0 && k !== "key" && k !== "data";
        }
      });
      data = object(data, {
        when: function(v) {
          return v !== void 0;
        }
      });
      remoteRequestData = null;
      if (session.signature) {
        (remoteRequestData || (remoteRequestData = {})).session = session.signature;
      }
      if (0 < objectHasKeys(props)) {
        (remoteRequestData || (remoteRequestData = {})).props = props;
      }
      if (0 < objectHasKeys(data)) {
        (remoteRequestData || (remoteRequestData = {})).data = data;
      }
      return getRestClientParamsForArtEryRequest({
        restPath: pipeline.restPath,
        server: (function() {
          switch (pipeline.remoteServer) {
            case true:
            case ".":
            case "/":
              return "";
            default:
              return pipeline.remoteServer;
          }
        })(),
        type: type,
        key: key,
        session: session,
        data: remoteRequestData
      });
    }
  });

  Request.createFromRemoteRequestProps = function(options) {
    var data, key, pipeline, props, requestData, session, type;
    session = options.session, pipeline = options.pipeline, type = options.type, key = options.key, requestData = options.requestData;
    data = requestData.data, props = requestData.props;
    return new Request({
      pipeline: pipeline,
      type: type,
      session: session,
      key: key,
      data: data,
      props: props,
      originatedOnClient: true
    });
  };

  Request.prototype.sendRemoteRequest = function() {
    var remoteRequest;
    return RestClient.restJsonRequest(remoteRequest = this.remoteRequestProps)["catch"]((function(_this) {
      return function(arg) {
        var ref1, response, status;
        ref1 = arg.info, status = ref1.status, response = ref1.response;
        return merge(response, {
          status: status
        });
      };
    })(this)).then((function(_this) {
      return function(remoteResponse) {
        return _this.addFilterLog((remoteRequest.method.toLocaleUpperCase()) + " " + remoteRequest.url).toResponse(remoteResponse.status, merge(remoteResponse, {
          remoteRequest: remoteRequest,
          remoteResponse: remoteResponse
        }));
      };
    })(this));
  };

  return Request;

})(__webpack_require__(38));


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, Promise, RequestResponseBase, array, arrayWith, clientFailure, clientFailureNotAuthorized, compactFlatten, config, defineModule, failure, formattedInspect, inspect, inspectedObjectLiteral, isArray, isClientFailure, isFunction, isJsonType, isPlainObject, isPromise, isString, log, merge, missing, object, objectWithDefinedValues, objectWithout, present, ref, ref1, serverFailure, success, toInspectedObjects,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), log = ref.log, arrayWith = ref.arrayWith, defineModule = ref.defineModule, merge = ref.merge, isJsonType = ref.isJsonType, isString = ref.isString, isPlainObject = ref.isPlainObject, isArray = ref.isArray, inspect = ref.inspect, inspectedObjectLiteral = ref.inspectedObjectLiteral, toInspectedObjects = ref.toInspectedObjects, formattedInspect = ref.formattedInspect, Promise = ref.Promise, object = ref.object, isFunction = ref.isFunction, objectWithDefinedValues = ref.objectWithDefinedValues, objectWithout = ref.objectWithout, array = ref.array, isPromise = ref.isPromise, compactFlatten = ref.compactFlatten, present = ref.present;

ArtEry = __webpack_require__(20);

ArtEryBaseObject = __webpack_require__(35);

ref1 = __webpack_require__(8), failure = ref1.failure, isClientFailure = ref1.isClientFailure, success = ref1.success, missing = ref1.missing, serverFailure = ref1.serverFailure, clientFailure = ref1.clientFailure, clientFailureNotAuthorized = ref1.clientFailureNotAuthorized;

config = __webpack_require__(11).config;


/*
TODO: merge reponse and request into one object

TODO: Work towards the concept of "oldData" - sometimes we need to know
 the oldData when updating. Specifically, ArtEryPusher needs to know the oldData
 to notify clients if a record is removed from one query and added to another.
 Without oldData, there is no way of knowing what old query it was removed from.
 In this case, either a) the client needs to send the oldData to the server of b)
 we need to fetch the oldData before overwriting it - OR we need to us returnValues: "allOld".

 Too bad there isn't a way to return BOTH the old and new fields with DynamoDb.

 Not sure if ArtEry needs any special code for "oldData." It'll probably be a convention
 that ArtEryAws and ArtEryPusher conform to. It's just a props from ArtEry's POV.
 */

defineModule(module, RequestResponseBase = (function(superClass) {
  var cachedGet, defaultWhenTest;

  extend(RequestResponseBase, superClass);

  function RequestResponseBase(options) {
    RequestResponseBase.__super__.constructor.apply(this, arguments);
    this.filterLog = options.filterLog, this.errorProps = options.errorProps;
  }

  RequestResponseBase.property("filterLog errorProps");

  RequestResponseBase.prototype.addFilterLog = function(filter) {
    this._filterLog = arrayWith(this._filterLog, isString(filter) ? filter : filter.getLogName(this.type));
    return this;
  };

  RequestResponseBase.getter({
    location: function() {
      return this.pipeline.location;
    },
    requestType: function() {
      return this.type;
    },
    pipelineName: function() {
      return this.pipeline.getName();
    },
    requestDataWithKey: function() {
      return merge(this.requestData, this.keyObject);
    },
    keyObject: function() {
      return this.request.pipeline.toKeyObject(this.key);
    },
    rootRequest: function() {
      var ref2;
      return ((ref2 = this.parentRequest) != null ? ref2.rootRequest : void 0) || this.request;
    },
    inspectedObjects: function() {
      var obj;
      return (
        obj = {},
        obj["" + this["class"].namespacePath] = toInspectedObjects(objectWithDefinedValues(objectWithout(this.propsForClone, "context"))),
        obj
      );
    }
  });

  RequestResponseBase.getter({
    requestProps: function() {
      return this.request.requestProps;
    },
    requestData: function() {
      return this.request.requestData;
    },
    isRootRequest: function() {
      return this.request.isRootRequest;
    },
    key: function() {
      var ref2;
      return this.request.key || ((ref2 = this.responseData) != null ? ref2.id : void 0);
    },
    pipeline: function() {
      return this.request.pipeline;
    },
    parentRequest: function() {
      return this.request.parentRequest;
    },
    type: function() {
      return this.request.type;
    },
    originatedOnServer: function() {
      return this.request.originatedOnServer;
    },
    context: function() {
      return this.request.context;
    },
    requestString: function() {
      var str;
      str = this.pipelineName + "." + this.type;
      if (this.key) {
        str += "[" + (formattedInspect(this.key)) + "]";
      }
      return str;
    },
    description: function() {
      return this.requestString;
    },
    requestPathArray: function(into) {
      var localInto, parentRequest;
      localInto = into || [];
      parentRequest = this.parentRequest;
      if (parentRequest) {
        parentRequest.getRequestPathArray(localInto);
      }
      localInto.push(this);
      return localInto;
    },
    requestPath: function() {
      var r;
      return "<" + (((function() {
        var i, len, ref2, results;
        ref2 = this.requestPathArray;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          r = ref2[i];
          results.push(r.toStringCore());
        }
        return results;
      }).call(this)).join(' >> ')) + ">";
    }
  });

  RequestResponseBase.prototype.toStringCore = function() {
    return "ArtEry." + (this.isResponse ? 'Response' : 'Request') + " " + this.pipelineName + "." + this.type + (this.key ? " key: " + this.key : '');
  };

  RequestResponseBase.prototype.toString = function() {
    return "<" + (this.toStringCore()) + ">";
  };

  RequestResponseBase.getter({
    requestCache: function() {
      var base;
      return (base = this.context).requestCache || (base.requestCache = {});
    },
    subrequestCount: function() {
      var base;
      return (base = this.context).subrequestCount || (base.subrequestCount = 0);
    }
  });

  RequestResponseBase.setter({
    responseProps: function() {
      throw new Error("cannot set responseProps");
    }
  });

  RequestResponseBase.prototype.incrementSubrequestCount = function() {
    return this.context.subrequestCount = (this.context.subrequestCount | 0) + 1;
  };


  /*
  TODO:
    I think I may have a way clean up the subrequest API and do
    what is easy in Ruby: method-missing.
  
    Here's the new API:
       * request on the same pipeline
      request.pipeline.requestType requestOptions
  
       * request on another pipeline
      request.pipelines.otherPipelineName.requestType requestOptions
  
    Here's how:
      .pipeline and .pipelines are getters
      And the return proxy objects, generated and cached on the fly.
  
    Alt API idea:
       * same pipeline
      request.subrequest.requestType
  
       * other pipelines
      request.crossSubrequest.user.requestType
  
      I kinda like this more because it makes it clear we are talking
      sub-requests. This is just a ALIASes to the API above.
   */

  RequestResponseBase.prototype.createSubRequest = function(pipelineName, type, requestOptions) {
    var pipeline, ref2;
    if (requestOptions && !isPlainObject(requestOptions)) {
      throw new Error("requestOptions must be an object");
    }
    pipeline = ArtEry.pipelines[pipelineName];
    if (!pipeline) {
      throw new Error("Pipeline not registered: " + (formattedInspect(pipelineName)));
    }
    return new ArtEry.Request(merge({
      originatedOnServer: (ref2 = requestOptions != null ? requestOptions.originatedOnServer : void 0) != null ? ref2 : true
    }, requestOptions, {
      type: type,
      pipeline: pipeline,
      session: (requestOptions != null ? requestOptions.session : void 0) || this.session,
      parentRequest: this.request,
      context: this.context
    }));
  };

  RequestResponseBase.prototype.subrequest = function(pipelineName, type, requestOptions) {
    var promise, ref2, subrequest;
    if (isString(requestOptions)) {
      requestOptions = {
        key: requestOptions
      };
    }
    pipelineName = pipelineName.pipelineName || pipelineName;
    subrequest = this.createSubRequest(pipelineName, type, requestOptions);
    this.incrementSubrequestCount();
    promise = subrequest.pipeline._processRequest(subrequest).then((function(_this) {
      return function(response) {
        return response.toPromise(requestOptions);
      };
    })(this));
    if (type === "update" && !(requestOptions != null ? (ref2 = requestOptions.props) != null ? ref2.returnValues : void 0 : void 0) && isString(subrequest.key)) {
      this._getPipelineTypeCache(pipelineName, type)[subrequest.key] = promise;
    }
    return promise;
  };

  RequestResponseBase.prototype._getPipelineTypeCache = function(pipelineName, type) {
    var base, base1;
    return (base = ((base1 = this.requestCache)[pipelineName] || (base1[pipelineName] = {})))[type] || (base[type] = {});
  };

  RequestResponseBase.prototype.cachedSubrequest = function(pipelineName, type, key) {
    var base;
    if (!isString(key)) {
      throw new Error("key must be a string (" + (formattedInspect({
        key: key
      })) + ")");
    }
    return (base = this._getPipelineTypeCache(pipelineName, type))[key] || (base[key] = this.subrequest(pipelineName, type, {
      key: key
    }));
  };

  RequestResponseBase.prototype.setGetCache = function() {
    if (this.status === success && present(this.key) && (this.responseData != null)) {
      return this._getPipelineTypeCache(this.pipelineName, "get")[this.key] = Promise.then((function(_this) {
        return function() {
          return _this.responseData;
        };
      })(this));
    }
  };

  RequestResponseBase.prototype.cachedGet = cachedGet = function(pipelineName, key) {
    return this.cachedSubrequest(pipelineName, "get", key);
  };

  RequestResponseBase.prototype.cachedPipelineGet = cachedGet;

  RequestResponseBase.prototype.cachedGetIfExists = function(pipelineName, key) {
    if (key == null) {
      return Promise.resolve(null);
    }
    return this.cachedGet(pipelineName, key)["catch"](function(error) {
      if (error.status === missing) {
        return Promise.resolve(null);
      } else {
        throw error;
      }
    });
  };


  /*
  IN:
    test: booleanish
    message: string (optional)
  OUT:
    Success: promise.then (request) ->
    Failure: promise.catch (error) ->
      error.props.response # failing response
      error.props.response.data.message.match message # if message res provided
  
  Success if test is true
   */

  RequestResponseBase.prototype.require = function(test, message) {
    if (test) {
      return Promise.resolve(this);
    } else {
      if (isFunction(message)) {
        message = message();
      }
      return this.clientFailure({
        data: {
          message: "requirement not met: " + (message || 'see stack trace')
        }
      }).then(function(response) {
        return response.toPromise();
      });
    }
  };

  RequestResponseBase.prototype.rejectIf = function(test, message) {
    return this.require(!test, message);
  };


  /*
  Success if @originatedOnServer is true
  OUT: see require
   */

  RequestResponseBase.prototype.requireServerOrigin = function(message) {
    return this.requireServerOriginOr(true, message);
  };


  /*
  Success if either testResult or @originatedOnServer are true.
  OUT: see require
   */

  RequestResponseBase.prototype.requireServerOriginOr = function(testResult, message) {
    return this.require(testResult || this.originatedOnServer, function() {
      if (!(message != null ? message.match(/\s*to\s/) : void 0)) {
        message = "to " + message;
      }
      return "originatedOnServer required " + (message != null ? message : '');
    });
  };


  /*
  Success if either NOT testResult or @originatedOnServer are true.
  OUT: see require
  
  EXAMPLE: request.requireServerOriginIf createOk, "to use createOk"
   */

  RequestResponseBase.prototype.requireServerOriginIf = function(testResult, message) {
    return this.requireServerOriginOr(!testResult, message);
  };

  RequestResponseBase.prototype["with"] = function(constructorOptions) {
    return Promise.resolve(constructorOptions).then((function(_this) {
      return function(constructorOptions) {
        return _this._with(constructorOptions);
      };
    })(this));
  };

  RequestResponseBase.prototype._with = function(o) {
    return new this["class"](merge(this.propsForClone, o));
  };


  /*
  IN: data can be a plainObject or a promise returning a plainObject
  OUT: promise.then (new request or response instance) ->
  
  withData:           new instance has @data replaced by `data`
  withMergedData:     new instance has @data merged with `data`
  withSession:        new instance has @session replaced by `session`
  withMergedSession:  new instance has @session merged with `session`
   */

  RequestResponseBase.prototype.withData = function(data) {
    return Promise.resolve(data).then((function(_this) {
      return function(data) {
        return _this._with({
          data: data
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withMergedData = function(data) {
    return Promise.resolve(data).then((function(_this) {
      return function(data) {
        return _this._with({
          data: merge(_this.data, data)
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withSession = function(session) {
    return Promise.resolve(session).then((function(_this) {
      return function(session) {
        return _this._with({
          session: session
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withMergedSession = function(session) {
    return Promise.resolve(session).then((function(_this) {
      return function(session) {
        return _this._with({
          session: merge(_this.session, session)
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.respondWithSession = function(session) {
    return this.success({
      session: session
    });
  };

  RequestResponseBase.prototype.respondWithMergedSession = function(session) {
    return this.success({
      session: merge(this.session, session)
    });
  };


  /*
  IN:
    withFunction, whenFunction
    OR: object:
      with: withFunction
      when: whenFunction
  
  withFunction: (record, requestOrResponse) ->
    IN:
      record: a plain object
      requestOrResponse: this
    OUT: See EFFECT below
      (can return a Promise in all situations)
  
  whenFunction: (record, requestOrResponse) -> t/f
    withFunction is only applied if whenFunction returns true
  
  EFFECT:
    if isPlainObject @data
      called once: singleRecordTransform @data
      if singleRecordTransform returns:
        null:         >> return status: missing
        plainObject:  >> return @withData data
        response:     >> return response
  
      See singleRecordTransform.OUT above for results
  
    if isArray @data
      Basically:
        @withData array record in @data with singleRecordTransform record
  
      But, each value returned from singleRecordTransform:
        null:                              omitted from array results
        response.status is clientFailure*: omitted from array results
        plainObject:                       returned in array results
        if any error:
            exception thrown
            rejected promise
            response.status is not success and not clientFailure
          then a failing response is returned
   */

  defaultWhenTest = function(data, request) {
    return request.pipeline.isRecord(data);
  };

  RequestResponseBase.prototype.withTransformedRecords = function(withFunction, whenFunction) {
    var firstFailure, options, transformedRecords;
    if (whenFunction == null) {
      whenFunction = defaultWhenTest;
    }
    if (isPlainObject(options = withFunction)) {
      withFunction = options["with"];
      whenFunction = options.when || defaultWhenTest;
    }
    if (isPlainObject(this.data)) {
      return Promise.resolve(whenFunction(this.data, this) ? this.next(withFunction(this.data, this)) : this);
    } else if (isArray(this.data)) {
      firstFailure = null;
      transformedRecords = array(this.data, (function(_this) {
        return function(record) {
          return Promise.then(function() {
            if (whenFunction(record, _this)) {
              return withFunction(record, _this);
            } else {
              return record;
            }
          })["catch"](function(error) {
            var ref2, response;
            if (response = error != null ? (ref2 = error.props) != null ? ref2.response : void 0 : void 0) {
              return response;
            } else {
              throw error;
            }
          }).then(function(out) {
            if ((out != null ? out.status : void 0) && out instanceof RequestResponseBase) {
              if (isClientFailure(out.status)) {
                if (typeof out._clearErrorStack === "function") {
                  out._clearErrorStack();
                }
                return null;
              } else {
                return firstFailure || (firstFailure = out);
              }
            } else {
              return out;
            }
          });
        };
      })(this));
      return Promise.all(transformedRecords).then((function(_this) {
        return function(records) {
          return firstFailure || _this.withData(compactFlatten(records));
        };
      })(this));
    } else {
      return Promise.resolve(this);
    }
  };


  /*
  next is used right after a filter or a handler.
  It's job is to convert the results into a request or response object.
  
  IN:
    null/undefined OR
    JSON-compabile data-type OR
    Response/Request OR
    something else - which is invalid, but is handled.
  
    OR a Promise returing one of the above
  
  OUT:
    if a Request or Response object was passed in, that is immediatly returned.
    Otherwise, this returns a Response object as follows:
  
  
    if data is null/undefined, return @missing
    if data is a JSON-compatible data structure, return @success with that data
    else, return @failure
   */

  RequestResponseBase.prototype.next = function(data) {
    return Promise.resolve(data).then((function(_this) {
      return function(data) {
        if (data instanceof RequestResponseBase) {
          return data;
        }
        if (data == null) {
          return _this.missing();
        } else if (isJsonType(data)) {
          return _this.success({
            data: data
          });
        } else {
          log.error({
            invalidXYZ: data
          });
          throw new Error("invalid response data passed to RequestResponseBaseNext");
        }
      };
    })(this), (function(_this) {
      return function(error) {
        var ref2, ref3;
        if ((ref2 = error.props) != null ? (ref3 = ref2.response) != null ? ref3.isResponse : void 0 : void 0) {
          return error.props.response;
        } else {
          return _this.failure({
            error: error
          });
        }
      };
    })(this));
  };

  RequestResponseBase.prototype.success = function(responseProps) {
    return this.toResponse(success, responseProps);
  };

  RequestResponseBase.prototype.missing = function(responseProps) {
    return this.toResponse(missing, responseProps);
  };

  RequestResponseBase.prototype.clientFailure = function(responseProps) {
    return this.toResponse(clientFailure, responseProps);
  };

  RequestResponseBase.prototype.clientFailureNotAuthorized = function(responseProps) {
    return this.toResponse(clientFailureNotAuthorized, responseProps);
  };

  RequestResponseBase.prototype.failure = function(responseProps) {
    return this.toResponse(failure, responseProps);
  };


  /*
  IN:
    status: legal CommunicationStatus
    responseProps: (optionally Promise returning:)
      PlainObject:          directly passed into the Response constructor
      String:               becomes data: message: string
      RequestResponseBase:  returned directly
      else:                 considered internal error, but it will create a valid, failing Response object
  OUT:
    promise.then (response) ->
    .catch -> # should never happen
   */

  RequestResponseBase.prototype.toResponse = function(status, responseProps) {
    if (!isString(status)) {
      throw new Error("missing status");
    }
    return Promise.resolve(responseProps).then((function(_this) {
      return function(responseProps) {
        if (responseProps == null) {
          responseProps = {};
        }
        switch (false) {
          case !(responseProps instanceof RequestResponseBase):
            log.warn("toResponse is instanceof RequestResponseBase - is this EVER used???");
            return responseProps;
          case !isPlainObject(responseProps):
            return new ArtEry.Response(merge(_this.propsForResponse, responseProps, {
              status: status,
              request: _this.request
            }));
          case !isString(responseProps):
            return _this.toResponse(status, {
              data: {
                message: responseProps
              }
            });
          default:
            return _this.toResponse(failure, _this._toErrorResponseProps(responseProps));
        }
      };
    })(this));
  };

  RequestResponseBase.prototype._toErrorResponseProps = function(error) {
    return log(this, {
      responseProps: responseProps
    }, {
      data: {
        message: responseProps instanceof Error ? "Internal Error: ArtEry.RequestResponseBase#toResponse received Error instance: " + (formattedInspect(responseProps)) : "Internal Error: ArtEry.RequestResponseBase#toResponse received unsupported type"
      }
    });
  };

  return RequestResponseBase;

})(ArtEryBaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var Binary,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(41)).addNamespace('Binary', Binary = (function(superClass) {
  extend(Binary, superClass);

  function Binary() {
    return Binary.__super__.constructor.apply(this, arguments);
  }

  return Binary;

})(Neptune.PackageNamespace));


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var StandardLib, WebWorker, log;

StandardLib = __webpack_require__(0);

log = StandardLib.log;


/*
SRC:
  http://jsfiddle.net/uqcFM/49/
  http://stackoverflow.com/a/10372280/2121000
 */

module.exports = WebWorker = (function() {
  var startWorkerFromJsString;

  function WebWorker() {}

  WebWorker.echoWebWorker = "self.onmessage=function(e){postMessage('Worker: '+e.data);}";

  WebWorker.isBrowser = !!(self.window && self.navigator && self.document);

  WebWorker.isWebWorker = !WebWorker.isBrowser && self.importScripts;

  WebWorker.startWorkerFromJsString = startWorkerFromJsString = function(workerSource) {
    return new Worker(URL.createObjectURL(new Blob([workerSource], {
      type: 'application/javascript'
    })));
  };

  WebWorker.startWorkerFromFunction = function(workerFunction) {
    return startWorkerFromJsString("(" + workerFunction + ")();");
  };

  return WebWorker;

})();


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.Foundation', Foundation = (function(superClass) {
  extend(Foundation, superClass);

  function Foundation() {
    return Foundation.__super__.constructor.apply(this, arguments);
  }

  Foundation.version = __webpack_require__(164).version;

  return Foundation;

})(Neptune.PackageNamespace));

__webpack_require__(39);

__webpack_require__(127);

__webpack_require__(134);


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var ArrayExtensions, bound, exactlyOneWordRegex, intRand, isNumber, isString, max, modulo, ref, ref1, ref2, wordsRegex,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(24), bound = ref.bound, max = ref.max, intRand = ref.intRand, modulo = ref.modulo;

ref1 = __webpack_require__(4), isNumber = ref1.isNumber, isString = ref1.isString;

ref2 = __webpack_require__(30), wordsRegex = ref2.wordsRegex, exactlyOneWordRegex = ref2.exactlyOneWordRegex;

module.exports = ArrayExtensions = (function() {
  var _moveArrayElementLargeArray, _moveArrayElementSmallArray, a, arrayWithElementMoved, arrayWithInsertedValue, basicCompareFunction, indexOfOrLength, keepAll, keepIfRubyTrue, leftOfIndex, longestCommonSubsequence, moveArrayElement, randomElement, randomSort, rightOfIndex, w;

  function ArrayExtensions() {}


  /*
  Useful compact and compactFlatten keepTester functions
   */

  ArrayExtensions.keepAll = keepAll = function() {
    return true;
  };

  ArrayExtensions.keepIfRubyTrue = keepIfRubyTrue = function(a) {
    return a !== void 0 && a !== null && a !== false;
  };

  ArrayExtensions.reverseForEach = function(array, f) {
    var p, v;
    for (p = array.length - 1; p >= 0; p += -1) {
      v = array[p];
      f(v);
    }
    return array;
  };

  ArrayExtensions.arrayToTruthMap = function(array) {
    var a, len1, p, res;
    res = {};
    for (p = 0, len1 = array.length; p < len1; p++) {
      a = array[p];
      res[a] = true;
    }
    return res;
  };

  ArrayExtensions.arrayToFalseMap = function(array) {
    var a, len1, p, res;
    res = {};
    for (p = 0, len1 = array.length; p < len1; p++) {
      a = array[p];
      res[a] = false;
    }
    return res;
  };

  ArrayExtensions.concatInto = function(array, b) {
    return array.push.apply(array, b);
  };

  ArrayExtensions.uniqueValues = function(sortedArray, eqF) {
    var i, len1, p, results, v;
    if (eqF == null) {
      eqF = (function(a, b) {
        return a === b;
      });
    }
    results = [];
    for (i = p = 0, len1 = sortedArray.length; p < len1; i = ++p) {
      v = sortedArray[i];
      if (i === 0 || !eqF(v, sortedArray[i - 1])) {
        results.push(v);
      }
    }
    return results;
  };


  /*
  IN:
    array: an array or falsy value
    element: anything
  OUT:
    array containing element as the last element
  
  EFFECT:
    if array was falsy, a new length-1 array is returned
    else, array was mutated by pushing the current element
  
  WHY?
    Why write this when arrays alread have push?
  
    1) if array is null, this works as desired
    2) this returns array, not array.length
      Returning the array is what Ruby's push does.
      It makes chaining pushes easy.
   */

  ArrayExtensions.push = function(array, element) {
    if (array) {
      array.push(element);
      return array;
    } else {
      return [element];
    }
  };

  ArrayExtensions.peek = function(array, offset) {
    if (offset == null) {
      offset = -1;
    }
    if (array != null) {
      return array[array.length + offset];
    } else {
      return void 0;
    }
  };

  basicCompareFunction = function(a, b) {
    return a - b;
  };

  ArrayExtensions.leftOfIndex = leftOfIndex = function(array, index) {
    if (!array) {
      return array;
    }
    return array.slice(0, index);
  };

  ArrayExtensions.rightOfIndex = rightOfIndex = function(array, index) {
    if (!array) {
      return array;
    }
    if (index < 0) {
      index += array.length;
    }
    return array.slice(index + 1);
  };

  indexOfOrLength = function(array, value) {
    var i;
    if (0 > (i = array.indexOf(value))) {
      return array.length;
    } else {
      return i;
    }
  };

  ArrayExtensions.leftOf = function(array, value) {
    return leftOfIndex(array, indexOfOrLength(array, value));
  };

  ArrayExtensions.rightOf = function(array, value) {
    return rightOfIndex(array, indexOfOrLength(array, value));
  };

  ArrayExtensions.splitArray = function(array, value) {
    var index;
    index = indexOfOrLength(array, value);
    return [leftOfIndex(array, index), rightOfIndex(array, index)];
  };


  /*
  findSortedFirst
  
  Acts as-if it sorted the array and returned the first element.
  
  Details:
    tests each element in the array againts the current "smallest"
    returns the element for which tests "smaller" than every other
    element a is "smaller" than b if compareFunction(a, b) returns >0 value
  
  IN:
    array - the array to search or null
    compareFunction - (a, b) -> # standard compare function
      returns:
        0: if a and b are equal
        <0: if b is greater than a
        >0: if a is greater than b
      default: (a, b) -> a - b
  
  OUT:
    largest value in array or undefined if array is null or length 0
   */

  ArrayExtensions.findSortedFirst = function(array, compareFunction) {
    var element, i, p, ref3, returnElement;
    if (compareFunction == null) {
      compareFunction = basicCompareFunction;
    }
    if (!((array != null ? array.length : void 0) > 0)) {
      return void 0;
    }
    returnElement = array[0];
    for (i = p = 1, ref3 = array.length; p < ref3; i = p += 1) {
      if (0 < compareFunction(returnElement, element = array[i])) {
        returnElement = element;
      }
    }
    return returnElement;
  };

  ArrayExtensions.first = function(array) {
    return array[0];
  };

  ArrayExtensions.second = function(array) {
    return array[1];
  };

  ArrayExtensions.third = function(array) {
    return array[2];
  };

  ArrayExtensions.forth = function(array) {
    return array[3];
  };

  ArrayExtensions.fifth = function(array) {
    return array[4];
  };

  ArrayExtensions.last = function(array) {
    if (array) {
      return array[array.length - 1];
    } else {
      return void 0;
    }
  };

  ArrayExtensions.pushIfNotPresent = function(array, item) {
    if (indexOf.call(array, item) >= 0) {
      return false;
    } else {
      array.push(item);
      return true;
    }
  };

  ArrayExtensions.randomElement = randomElement = function(array, fromFirstN) {
    if (fromFirstN == null) {
      fromFirstN = array.length;
    }
    return array[Math.random() * fromFirstN | 0];
  };

  ArrayExtensions.randomSort = randomSort = function(array) {
    var a, i, j, len, p, ref3;
    len = array.length;
    for (i = p = ref3 = len - 1; p >= 0; i = p += -1) {
      j = intRand(i);
      a = array[i];
      array[i] = array[j];
      array[j] = a;
    }
    return array;
  };

  ArrayExtensions.arrayWithRandomSort = function(array) {
    if (array) {
      return randomSort(array.slice());
    } else {
      return [];
    }
  };

  ArrayExtensions.insert = function(array, index, item) {
    if (index < 0) {
      index = array.length + index + 1;
    }
    array.splice(index, 0, item);
    return array;
  };

  ArrayExtensions.arrayWithInsertedValue = arrayWithInsertedValue = function(array, index, item) {
    return ArrayExtensions.insert(array.slice(), index, item);
  };

  ArrayExtensions.withInserted = arrayWithInsertedValue;

  ArrayExtensions.withSort = function(array, sortFunction) {
    array = array.slice();
    return array.sort(sortFunction);
  };

  ArrayExtensions.remove = function(array, index, amount) {
    if (amount == null) {
      amount = 1;
    }
    if (index < 0) {
      index = array.length + index + 1;
    }
    array.splice(index, amount);
    return array;
  };

  ArrayExtensions.removeFirstMatch = function(array, toMatchValue) {
    var index;
    index = array.indexOf(toMatchValue);
    if (index >= 0) {
      return ArrayExtensions.remove(array, index);
    } else {
      return array;
    }
  };

  ArrayExtensions.arrayWithout = function(array, index, amount) {
    if (amount == null) {
      amount = 1;
    }
    if (index == null) {
      index = array.length - 1;
    }
    return ArrayExtensions.remove(array.slice(), index, amount);
  };

  ArrayExtensions.arrayWithoutValue = function(array, value) {
    return ArrayExtensions.remove(array.slice(), array.indexOf(value), 1);
  };

  ArrayExtensions.arrayWithoutLast = function(array, amount) {
    if (amount == null) {
      amount = 1;
    }
    if ((array != null) && amount < array.length) {
      return array.slice(0, array.length - amount);
    } else {
      return [];
    }
  };

  ArrayExtensions.arrayWith = function(array, value) {
    if (!array) {
      return [value];
    }
    array = array.slice();
    array.push(value);
    return array;
  };

  ArrayExtensions.truncatedArrayWith = function(array, length, value) {
    if (!array) {
      return [value];
    }
    array = array.slice(0, length);
    array.push(value);
    return array;
  };

  ArrayExtensions.poppedArray = function(array) {
    return array.slice(0, array.length - 1);
  };

  ArrayExtensions.arrayWithOne = function(array, value) {
    if (!array) {
      return [value];
    }
    array = array.slice();
    if (indexOf.call(array, value) < 0) {
      array.push(value);
    }
    return array;
  };

  ArrayExtensions.slice = function(a, b, c) {
    return arraySlice.call(a, b, c);
  };

  ArrayExtensions.shuffleArray = function(a) {
    var i, j, t;
    i = a.length;
    while (--i > 0) {
      j = ~~(Math.random() * (i + 1));
      t = a[j];
      a[j] = a[i];
      a[i] = t;
    }
    return a;
  };

  ArrayExtensions._moveArrayElementLargeArray = _moveArrayElementLargeArray = function(array, from, to) {
    array.splice(to, 0, array.splice(from, 1)[0]);
    return array;
  };

  ArrayExtensions._moveArrayElementSmallArray = _moveArrayElementSmallArray = function(array, from, to) {
    var i, p, q, ref3, ref4, ref5, ref6, tmp;
    from = from | 0;
    to = to | 0;
    tmp = array[from];
    if (from < to) {
      for (i = p = ref3 = from, ref4 = to - 1; p <= ref4; i = p += 1) {
        array[i] = array[i + 1];
      }
    } else {
      for (i = q = ref5 = from, ref6 = to + 1; q >= ref6; i = q += -1) {
        array[i] = array[i - 1];
      }
    }
    array[to] = tmp;
    return array;
  };

  ArrayExtensions.moveArrayElement = moveArrayElement = function(array, from, to) {
    from = modulo(from | 0, array.length);
    to = modulo(to | 0, array.length);
    if (Math.abs(from - to) > 300) {
      _moveArrayElementLargeArray(array, from, to);
    } else {
      _moveArrayElementSmallArray(array, from, to);
    }
    return array;
  };

  ArrayExtensions.arrayWithElementMoved = arrayWithElementMoved = function(array, from, to) {
    from = modulo(from | 0, array.length);
    to = modulo(to | 0, array.length);
    if (from === to) {
      return array;
    }
    array = array.slice();
    return moveArrayElement(array, from, to);
  };

  ArrayExtensions.arrayWithElementValueMoved = function(array, value, to) {
    var from;
    from = array.indexOf(value);
    if (from < 0) {
      return array;
    }
    return arrayWithElementMoved(array, from, to);
  };

  ArrayExtensions.arrayWithElementReplaced = function(array, value, index) {
    array = array.slice();
    array[index] = value;
    return array;
  };

  ArrayExtensions.arrayWithAllButLast = function(array, amount) {
    if (amount == null) {
      amount = 1;
    }
    if (array) {
      return array.slice(0, array.length - amount);
    } else {
      return [];
    }
  };

  ArrayExtensions.stableSort = function(array, compare) {
    var a, b, i, length, notSorted, p, ref3;
    compare || (compare = function(a, b) {
      return a - b;
    });
    notSorted = true;
    length = array.length;
    while (notSorted) {
      notSorted = false;
      for (i = p = 1, ref3 = length; p < ref3; i = p += 1) {
        if (compare(a = array[i - 1], b = array[i]) > 0) {
          array[i - 1] = b;
          array[i] = a;
          notSorted = true;
        }
      }
    }
    return array;
  };

  ArrayExtensions.longestCommonSubsequence = longestCommonSubsequence = function(a, b) {
    var c, diag, i, j, latch, lcs, left, m, n, p, q, r, ref3, ref4, ref5, row, s;
    lcs = [];
    row = [];
    c = [];
    if (m < n) {
      s = a;
      a = b;
      b = s;
    }
    m = a.length;
    n = b.length;
    for (j = p = 0, ref3 = n; p < ref3; j = p += 1) {
      row[j] = 0;
    }
    for (i = q = 0, ref4 = m; q < ref4; i = q += 1) {
      c[i] = row = row.slice();
      diag = 0;
      for (j = r = 0, ref5 = n - 1; r <= ref5; j = r += 1) {
        latch = row[j];
        if (a[i] === b[j]) {
          row[j] = diag + 1;
        } else {
          left = row[j - 1] || 0;
          if (left > row[j]) {
            row[j] = left;
          }
        }
        diag = latch;
      }
    }
    i--;
    j--;
    while (i > -1 && j > -1) {
      switch (c[i][j]) {
        case i && c[i - 1][j]:
          i--;
          continue;
        case j && c[i][j - 1]:
          j--;
          break;
        default:
          j--;
          lcs.unshift(a[i]);
          i--;
          continue;
      }
    }
    return lcs;
  };

  ArrayExtensions.minimumOrderedOverlappingMerge = function(a, b) {
    var ai, bj, c, ck, i, j, k, l, m, n, o, out;
    c = longestCommonSubsequence(a, b);
    m = a.length;
    n = b.length;
    o = c.length;
    out = new Array(n);
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    while (i < m && j < n && k < o) {
      ai = a[i];
      bj = b[j];
      ck = c[k];
      if (ai === ck && bj === ck) {
        i++;
        j++;
        k++;
        out[l++] = ai;
      } else if (ai !== ck) {
        i++;
        if (indexOf.call(b, ai) < 0) {
          out[l++] = ai;
        }
      } else {
        j++;
        out[l++] = bj;
      }
    }
    while (i < m) {
      ai = a[i++];
      if (indexOf.call(b, ai) < 0) {
        out[l++] = ai;
      }
    }
    while (j < n) {
      out[l++] = b[j++];
    }
    return out;
  };

  ArrayExtensions.wordsArray = w = function() {
    var arg, len1, out, p;
    out = [];
    for (p = 0, len1 = arguments.length; p < len1; p++) {
      arg = arguments[p];
      if (isString(arg) && !arg.match(exactlyOneWordRegex)) {
        out = out.concat(arg.match(wordsRegex));
      } else {
        out.push(arg);
      }
    }
    return out;
  };

  ArrayExtensions.wordArray = ArrayExtensions.wordsArray;

  ArrayExtensions.w = ArrayExtensions.wordsArray;

  ArrayExtensions.a = a = function() {
    var arg, len1, out, p;
    out = [];
    for (p = 0, len1 = arguments.length; p < len1; p++) {
      arg = arguments[p];
      out.push(arg);
    }
    return out;
  };

  return ArrayExtensions;

})();


/***/ }),
/* 43 */
/***/ (function(module, exports) {

var ArrayCompactFlatten;

module.exports = ArrayCompactFlatten = (function() {
  var arraySlice, compact, compactFlattenIfNeeded, deepArrayEach, doFlattenInternal, flatten, isArguments, isArrayOrArguments, keepAll, keepUnlessNullOrUndefined, needsFlatteningOrCompacting;

  function ArrayCompactFlatten() {}

  ArrayCompactFlatten.isArguments = isArguments = function(o) {
    return o.constructor === Object && o.toString() === '[object Arguments]';
  };

  ArrayCompactFlatten.isArrayOrArguments = isArrayOrArguments = function(o) {
    return o && (o.constructor === Array || isArguments(o));
  };

  ArrayCompactFlatten.needsFlatteningOrCompacting = needsFlatteningOrCompacting = function(array, keepTester) {
    var a, i, len;
    for (i = 0, len = array.length; i < len; i++) {
      a = array[i];
      if (isArrayOrArguments(a) || !keepTester(a)) {
        return true;
      }
    }
    return false;
  };

  ArrayCompactFlatten.keepUnlessNullOrUndefined = keepUnlessNullOrUndefined = function(a) {
    return a !== null && a !== void 0;
  };


  /*
  IN:
    array: array or arguments-object
    keepTester: (value) -> true/false
      OUT: return true if that element should be in the output
  
  OUT: array where all elements test true to keepTester
  NOTE: NOT recursive - just does a shallow pass
   */

  ArrayCompactFlatten.compact = compact = function(array, keepTester) {
    var a, i, len;
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    for (i = 0, len = array.length; i < len; i++) {
      a = array[i];
      if (!keepTester(a)) {
        return (function() {
          var j, len1, results;
          results = [];
          for (j = 0, len1 = array.length; j < len1; j++) {
            a = array[j];
            if (keepTester(a)) {
              results.push(a);
            }
          }
          return results;
        })();
      }
    }
    return array;
  };


  /*
  IN: accepts any number of arguments
  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
    to the top level (flatten)
   */

  ArrayCompactFlatten.flatten = flatten = function(firstArg) {
    return compactFlattenIfNeeded(arguments.length === 1 ? firstArg : arguments);
  };


  /*
  IN: array: any object that has a length
  
  EFFECT:
    itterates over array and recurse over any element which isArrayOrArguments
    invokes f on every element that is not isArrayOrArguments
  OUT: array (same as passed in)
   */

  ArrayCompactFlatten.deepArrayEach = deepArrayEach = function(array, f) {
    var el, i, len;
    for (i = 0, len = array.length; i < len; i++) {
      el = array[i];
      if (isArrayOrArguments(el)) {
        deepArrayEach(el, f);
      } else {
        f(el);
      }
    }
    return array;
  };


  /*
  IN:
    array: array or arguments-object
    keepTester: (value) -> true/false
      OUT: return true if that element should be in the output
  
  OUT: array where all elements test true to keepTester
  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
    to the top level (flatten)
   */

  ArrayCompactFlatten.compactFlatten = function(array, keepTester) {
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    return compactFlattenIfNeeded(array, keepTester);
  };

  arraySlice = Array.prototype.slice;

  doFlattenInternal = function(array, keepTester) {
    var output;
    output = [];
    deepArrayEach(array, function(el) {
      if (keepTester(el)) {
        return output.push(el);
      }
    });
    return output;
  };

  keepAll = function() {
    return true;
  };

  compactFlattenIfNeeded = function(array, keepTester) {
    if (keepTester == null) {
      keepTester = keepAll;
    }
    if (array == null) {
      return array;
    }
    if ((array != null) && !isArrayOrArguments(array)) {
      return [array];
    }
    if (needsFlatteningOrCompacting(array, keepTester)) {
      return doFlattenInternal(array, keepTester);
    } else if (array.constructor !== Array) {
      return arraySlice.call(array);
    } else {
      return array;
    }
  };

  return ArrayCompactFlatten;

})();


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var InspectedObjectLiteral, compare;

compare = __webpack_require__(67).compare;

module.exports = InspectedObjectLiteral = (function() {
  InspectedObjectLiteral.inspectedObjectLiteral = function(literal, isError) {
    return new InspectedObjectLiteral(literal, isError);
  };

  function InspectedObjectLiteral(literal1, isError1) {
    this.literal = literal1;
    this.isError = isError1;
  }

  InspectedObjectLiteral.prototype.getInspectedObjects = function() {
    return this;
  };

  InspectedObjectLiteral.prototype.inspect = function() {
    return this.literal;
  };

  InspectedObjectLiteral.prototype.compare = function(b) {
    return compare(this.literal, b.literal);
  };

  return InspectedObjectLiteral;

})();


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var Inspect,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(72)).addNamespace('Inspect', Inspect = (function(superClass) {
  extend(Inspect, superClass);

  function Inspect() {
    return Inspect.__super__.constructor.apply(this, arguments);
  }

  return Inspect;

})(Neptune.PackageNamespace));

__webpack_require__(146);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {


/*
TODO: This is almost identical to ES6's Map: Switch to using a Polyfill like:
  https://github.com/paulmillr/es6-shim

Map is a Key-Value map which preserves order.

Unlike Javascript objects, you can use any object or value as keys. This includes:

  Strings
  Numbers
  null
  undefined
  Arrays
  Objects

Arrays and Objects are assigned a unique id using the StandardLib.Unique library.
"0", "", null, undefined and 0 are all different unique keys and can each have unique values.
 */
var KeysIterator, Map, MinimalBaseObject, Node, Unique, ValuesIterator, m,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Unique = __webpack_require__(71);

MinimalBaseObject = __webpack_require__(15);

Node = (function() {
  function Node(key, value, prev, next) {
    this.key = key;
    this.value = value;
    this.prev = prev || null;
    this.next = next || null;
    if (prev) {
      prev.next = this;
    }
    if (next) {
      next.prev = this;
    }
  }

  Node.prototype.remove = function() {
    var n, p;
    n = this.next;
    p = this.prev;
    if (p) {
      p.next = n;
      this.prev = null;
    }
    if (n) {
      n.prev = p;
      return this.next = null;
    }
  };

  return Node;

})();

KeysIterator = (function() {
  function KeysIterator(node1) {
    this.node = node1;
    this.started = false;
  }

  KeysIterator.prototype.next = function() {
    var ref, ref1;
    this.node = this.started ? (ref = this.node) != null ? ref.next : void 0 : (this.started = true, this.node);
    return {
      done: !this.node,
      value: (ref1 = this.node) != null ? ref1.key : void 0
    };
  };

  return KeysIterator;

})();

ValuesIterator = (function() {
  function ValuesIterator(node1) {
    this.node = node1;
    this.started = false;
  }

  ValuesIterator.prototype.next = function() {
    var ref, ref1;
    this.node = this.started ? (ref = this.node) != null ? ref.next : void 0 : (this.started = true, this.node);
    return {
      done: !this.node,
      value: (ref1 = this.node) != null ? ref1.value : void 0
    };
  };

  return ValuesIterator;

})();

module.exports = (m = new global.Map).set(1, 2) === m ? global.Map : Map = (function(superClass) {
  extend(Map, superClass);

  function Map() {
    this._length = 0;
    this._map = {};
    this._first = this._last = null;
  }

  Map.getter({
    size: function() {
      return this._length;
    }
  });

  Map.prototype._getNodes = function() {
    var n, result;
    result = [];
    n = this._first;
    while (n) {
      result.push(n);
      n = n.next;
    }
    return result;
  };

  Map.prototype.keys = function() {
    return new KeysIterator(this._first);
  };

  Map.prototype.values = function() {
    return new ValuesIterator(this._first);
  };

  Map.prototype.get = function(key) {
    var node;
    node = this._map[Unique.id(key)];
    return node && node.value;
  };

  Map.prototype.set = function(key, value) {
    var id;
    id = Unique.id(key);
    if (this._map[id]) {
      this._map[id].value = value;
    } else {
      this._length++;
      this._last = this._map[id] = new Node(key, value, this._last);
      if (!this._first) {
        this._first = this._last;
      }
    }
    return this;
  };

  Map.prototype._remove = function(key) {
    var id, n;
    id = Unique.id(key);
    if (n = this._map[id]) {
      this._length--;
      delete this._map[id];
      if (this._first === n) {
        this._first = n.next;
      }
      if (this._last === n) {
        this._last = n.prev;
      }
      n.remove();
      return n;
    } else {
      return void 0;
    }
  };

  Map.prototype["delete"] = function(key) {
    return !!this._remove(key);
  };

  Map.prototype.forEach = function(f) {
    var i, len, node, ref;
    ref = this._getNodes();
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      f(node.value, node.key, this);
    }
    return void 0;
  };

  Map.prototype.has = function(key) {
    return !!this._map[Unique.id(key)];
  };

  return Map;

})(MinimalBaseObject);


/***/ }),
/* 47 */
/***/ (function(module, exports) {

var ParseUrl;

module.exports = ParseUrl = (function() {
  var generateQuery, parsedGlobalQuery;

  function ParseUrl() {}

  parsedGlobalQuery = null;

  ParseUrl.parseQuery = function(qs) {
    var i, isCurrentLocation, j, key, len, obj, pair, ref, ref1, val;
    if ((isCurrentLocation = qs == null) && parsedGlobalQuery) {
      return parsedGlobalQuery;
    }
    qs || (qs = ((ref = global.location) != null ? ref.search : void 0) || "");
    obj = {};
    ref1 = qs.replace(/^\?/, '').split('&');
    for (j = 0, len = ref1.length; j < len; j++) {
      pair = ref1[j];
      if ((i = pair.indexOf('=')) >= 0) {
        key = pair.slice(0, i);
        val = pair.slice(i + 1);
        if (key.length > 0) {
          obj[key] = decodeURIComponent(val);
        }
      } else {
        obj[pair] = true;
      }
    }
    if (isCurrentLocation) {
      parsedGlobalQuery = obj;
    }
    return obj;
  };

  ParseUrl.generateQuery = generateQuery = function(o) {
    var k, parts, v;
    parts = (function() {
      var results;
      results = [];
      for (k in o) {
        v = o[k];
        results.push((encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
      }
      return results;
    })();
    return parts.join("&");
  };

  ParseUrl.urlJoin = function(uri, path) {
    return (uri.replace(/\/$/, '')) + "/" + (path.replace(/^\//, ''));
  };

  ParseUrl.appendQuery = function(uri, o) {
    var str;
    str = generateQuery(o);
    return "" + uri + (uri.match(/\?/) ? "&" : "?") + str;
  };

  ParseUrl.parseUrl = function(url) {
    var __, a, anchor, fileName, host, hostWithPort, m, password, path, pathName, port, protocol, query, username;
    m = url.match(/(([A-Za-z]+):(\/\/)?)?(([\-;&=\+\$,\w]+)(:([\-;:&=\+\$,\w]+))?@)?([A-Za-z0-9\.\-]+)(:([0-9]+))?(\/[\+~%\/\.\w\-]*)?(\?([\-\+=&;%@\.\w,]*))?(\#([\.\!\/\\\w]*))?/);
    if (!m) {
      return void 0;
    }
    __ = m[0], __ = m[1], protocol = m[2], __ = m[3], __ = m[4], username = m[5], __ = m[6], password = m[7], host = m[8], __ = m[9], port = m[10], pathName = m[11], __ = m[12], query = m[13], __ = m[14], anchor = m[15];
    if (pathName) {
      a = pathName.split("/");
      fileName = a[a.length - 1];
      path = (a.slice(0, a.length - 1)).join("/");
    }
    host = host.toLowerCase();
    hostWithPort = host;
    if (port) {
      hostWithPort += ":" + port;
    }
    return {
      protocol: protocol,
      username: username,
      password: password,
      hostWithPort: hostWithPort,
      host: host,
      port: port,
      pathName: pathName,
      path: path,
      fileName: fileName,
      query: query && ParseUrl.parseQuery(query),
      anchor: anchor
    };
  };

  return ParseUrl;

})();


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var base, isBoolean, isDate, isFunction, isJsonType, isNumber, isPlainArray, isPlainObject, isString, merge, object, ref;

ref = __webpack_require__(0), isBoolean = ref.isBoolean, isNumber = ref.isNumber, isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, isDate = ref.isDate, isJsonType = ref.isJsonType, merge = ref.merge, object = ref.object;


/*
@dataTypes only includes the Standard Json types:
  except 'null':
    no field has the type of 'null'
    instead, it has some other type and can be 'null' unless it is 'required'
 */

base = {
  boolean: {
    validate: isBoolean
  },
  number: {
    validate: isNumber
  },
  string: {
    validate: isString
  },
  object: {
    validate: isPlainObject
  },
  array: {
    validate: isPlainArray
  },
  "function": {
    validate: isFunction
  },
  date: {
    validate: isDate
  },
  json: {
    validate: isJsonType
  },
  any: {}
};

module.exports = merge(base, object(base, {
  key: function(v, k) {
    return k + "DataType";
  },
  "with": function(v, k) {
    return k;
  }
}));


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  return __webpack_require__(232);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let method, AllowAllCorsHandler;
  method = null;
  return (AllowAllCorsHandler = Caf.defClass(
    class AllowAllCorsHandler extends __webpack_require__(77) {},
    function(AllowAllCorsHandler, classSuper, instanceSuper) {
      this.commonResponseHeaders = { "Access-Control-Allow-Origin": "*" };
      this.prototype.canHandleRequest = function({ method }) {
        return method === "OPTIONS";
      };
      this.prototype.handleRequest = function(request) {
        return {
          status: "success",
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods":
              request.headers["access-control-request-method"] ||
              "GET, POST, PUT, UPDATE, DELETE",
            "Access-Control-Allow-Headers":
              request.headers["access-control-request-headers"] || "",
            "Content-Type": "text/html; charset=utf-8"
          }
        };
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let log, dateFormat, compactFlatten;
  ({ log, dateFormat, compactFlatten } = Caf.import(
    ["log", "dateFormat", "compactFlatten"],
    [global, __webpack_require__(0)]
  ));
  return function(superClass) {
    let LoggingMixin;
    return (LoggingMixin = Caf.defClass(
      class LoggingMixin extends superClass {},
      function(LoggingMixin, classSuper, instanceSuper) {
        this.prototype.log = function(toLog) {
          return log.withOptions({ color: true }, this.preprocessLog(toLog));
        };
        this.prototype.logError = function(toLog) {
          return log.error(this.preprocessLog(toLog));
        };
        this.prototype.logVerbose = function(toLog) {
          return this.verbose ? this.log(toLog) : undefined;
        };
        this.prototype.preprocessLog = function(toLog) {
          return { [`${Caf.toString(this.logHeader)}`]: toLog };
        };
        this.getter({
          logTime: function() {
            return dateFormat("UTC:yyyy-mm-dd_HH-MM-ss");
          },
          verbose: function() {
            let cafBase;
            return (
              this._verbose ||
              (Caf.exists((cafBase = this.options)) && cafBase.verbose)
            );
          },
          logHeader: function() {
            return compactFlatten([
              this.logTime,
              this.workerId && `worker${Caf.toString(this.workerId)}`,
              this.class.getName()
            ]).join(" ");
          }
        });
      }
    ));
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(197);


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var Common, Foundation, isBoolean, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, wordsArray;

Foundation = __webpack_require__(2);

log = Foundation.log, lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isString = Foundation.isString, isPlainArray = Foundation.isPlainArray, isPlainObject = Foundation.isPlainObject, isNumber = Foundation.isNumber, isBoolean = Foundation.isBoolean;

module.exports = Common = (function() {
  var dynamoDbConstant, i, len, ref;

  function Common() {}

  Common.apiConstantsMap = {
    string: 'S',
    number: 'N',
    binary: 'B',
    bothImages: 'NEW_AND_OLD_IMAGES'
  };

  ref = wordsArray("ALL\nALL_ATTRIBUTES\nALL_NEW\nALL_OLD\nALL_PROJECTED_ATTRIBUTES\nCOUNT\nHASH\nINCLUDE\nINDEXES\nKEYS_ONLY\nNEW_AND_OLD_IMAGES\nNEW_IMAGE\nNONE\nOLD_IMAGE\nRANGE\nS N B\nSPECIFIC_ATTRIBUTES\nTOTAL\nUPDATED_NEW\nUPDATED_OLD\n");
  for (i = 0, len = ref.length; i < len; i++) {
    dynamoDbConstant = ref[i];
    Common.apiConstantsMap[lowerCamelCase(dynamoDbConstant)] = dynamoDbConstant;
  }

  return Common;

})();


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var Aws,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(198)).addNamespace('Aws', Aws = (function(superClass) {
  extend(Aws, superClass);

  function Aws() {
    return Aws.__super__.constructor.apply(this, arguments);
  }

  Aws.version = __webpack_require__(162).version;

  return Aws;

})(Neptune.PackageNamespace));

__webpack_require__(86);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var Chat,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.Chat', Chat = (function(superClass) {
  extend(Chat, superClass);

  function Chat() {
    return Chat.__super__.constructor.apply(this, arguments);
  }

  Chat.version = __webpack_require__(286).version;

  return Chat;

})(Neptune.PackageNamespace));

__webpack_require__(88);

__webpack_require__(89);

__webpack_require__(90);


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, ExtendablePropertyMixin, Log, MinimalBaseObject, StandardLib, Unique, WebpackHotLoader, callStack, capitalize, clone, concatInto, decapitalize, extendClone, functionName, getModuleBeingDefined, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, isString, log, mergeInto, nextUniqueObjectId, object, objectName,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

StandardLib = __webpack_require__(0);

WebpackHotLoader = __webpack_require__(92);

capitalize = StandardLib.capitalize, decapitalize = StandardLib.decapitalize, log = StandardLib.log, extendClone = StandardLib.extendClone, clone = StandardLib.clone, isFunction = StandardLib.isFunction, objectName = StandardLib.objectName, isPlainObject = StandardLib.isPlainObject, functionName = StandardLib.functionName, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, Unique = StandardLib.Unique, callStack = StandardLib.callStack, Log = StandardLib.Log, log = StandardLib.log, inspectedObjectLiteral = StandardLib.inspectedObjectLiteral, MinimalBaseObject = StandardLib.MinimalBaseObject, getModuleBeingDefined = StandardLib.getModuleBeingDefined, concatInto = StandardLib.concatInto, mergeInto = StandardLib.mergeInto, isString = StandardLib.isString, object = StandardLib.object;

nextUniqueObjectId = Unique.nextUniqueObjectId;

ExtendablePropertyMixin = __webpack_require__(91);

module.exports = BaseClass = (function(superClass) {
  var createWithPostCreate, getSingleton, imprintObject, nonImprintableProps, thoroughDeleteProperty, warnedAboutIncludeOnce;

  extend(BaseClass, superClass);

  BaseClass.objectsCreated = 0;

  BaseClass.objectsCreatedByType = {};

  BaseClass.resetStats = function() {
    BaseClass.objectsCreated = 0;
    return BaseClass.objectsCreatedByType = {};
  };

  BaseClass._name = null;


  /*
  NOTE: only hasOwnProperties are considered! Inherited properties are not touched.
  IN:
    targetObject:   object will be altered to be an "imprint" of fromObject
    fromObject: object pattern used to imprint targetObject
    preserveState:
      false:
        targetObject has every property updated to exactly match fromObject
  
        This includes:
          1. delete properties in targetObject that are not in fromObject
          2. add every property in fromObject but not in targetObject
          3. overwriting every property in targetObject also in fromObject
  
      true:
        Attempts to preserve the state of targetObject while updating its functionality.
        This means properties which are functions in either object are updated.
  
        WARNING: This is a grey area for JavaScript. It is not entirely clear what is
          state and what is 'functionality'. I, SBD, have made the following heuristic decisions:
  
        Imprint actions taken when preserving State:
  
        1. DO NOTHING to properties in targetObject that are not in fromObject
        2. add every property in fromObject but not in targetObject
        3. properties in targetObject that are also in fromObject are updated
          if one of the following are true:
          - isFunction fromObject[propName]
          - isFunction targetObject[propName]
          - propName does NOT start with "_"
          NOTE: property existance is detected using Object.getOwnPropertyDescriptor
   */

  thoroughDeleteProperty = function(object, propName) {
    Object.defineProperty(object, propName, {
      configurable: true,
      writable: false,
      value: 1
    });
    return delete object[propName];
  };

  nonImprintableProps = ["__proto__", "prototype"];

  BaseClass.imprintObject = imprintObject = function(targetObject, sourceObject, preserveState) {
    var i, j, len, len1, sourcePropDescriptor, sourcePropName, sourcePropertyNames, targetPropDescriptor, targetPropName, targetPropertyNames;
    if (preserveState == null) {
      preserveState = false;
    }
    targetPropertyNames = Object.getOwnPropertyNames(targetObject);
    sourcePropertyNames = Object.getOwnPropertyNames(sourceObject);
    if (!preserveState) {
      for (i = 0, len = targetPropertyNames.length; i < len; i++) {
        targetPropName = targetPropertyNames[i];
        if (!(indexOf.call(sourcePropertyNames, targetPropName) >= 0)) {
          thoroughDeleteProperty(targetObject, targetPropName);
        }
      }
    }
    for (j = 0, len1 = sourcePropertyNames.length; j < len1; j++) {
      sourcePropName = sourcePropertyNames[j];
      if (!(!(indexOf.call(nonImprintableProps, sourcePropName) >= 0))) {
        continue;
      }
      targetPropDescriptor = Object.getOwnPropertyDescriptor(targetObject, sourcePropName);
      sourcePropDescriptor = Object.getOwnPropertyDescriptor(sourceObject, sourcePropName);
      if (!preserveState || !targetPropDescriptor || isFunction(sourcePropDescriptor.value) || isFunction(targetPropDescriptor != null ? targetPropDescriptor.value : void 0) || !sourcePropName.match(/^_/)) {
        Object.defineProperty(targetObject, sourcePropName, sourcePropDescriptor);
      }
    }
    return sourceObject;
  };


  /*
  imprints both the class and its prototype.
  
  preserved in spite of imprintObject's rules:
    @namespace
    @::constructor
   */

  BaseClass.imprintFromClass = function(updatedKlass) {
    var _name, namespace, namespacePath, oldConstructor, ref;
    if (updatedKlass !== this) {
      ref = this, namespace = ref.namespace, namespacePath = ref.namespacePath, _name = ref._name;
      oldConstructor = this.prototype.constructor;
      imprintObject(this, updatedKlass, true);
      imprintObject(this.prototype, updatedKlass.prototype, false);
      this.prototype.constructor = oldConstructor;
      this.namespace = namespace;
      this.namespacePath = namespacePath;
      this._name = _name;
    }
    return this;
  };

  BaseClass.getHotReloadKey = function() {
    return this.getName();
  };


  /*
  IN:
    _module should be the CommonJS 'module'
    klass: class object which extends BaseClass
  
  liveClass:
    On the first load, liveClass gets set.
    Each subsequent hot-load UPDATES liveClass,
    but liveClass always points to the initially created class object.
  
  OUT: the result of the call to liveClass.postCreate()
  
  postCreate is passed:
    hotReloaded:            # true if this is anything but the initial load
    classModuleState:
      liveClass:            # the original liveClass
      hotUpdatedFromClass:  # the most recently hot-loaded class
      hotReloadVersion:     # number starting at 0 and incremented with each hot reload
    _module:                # the CommonJs module
  
  EFFECTS:
    The following two methods are invoked on liveClass:
  
      if hot-reloading
        liveClass.imprintFromClass klass
  
       * always:
      liveClass.postCreate hotReloaded, classModuleState, _module
   */

  BaseClass.createWithPostCreate = createWithPostCreate = function(a, b) {
    var _module, klass;
    klass = b ? (_module = a, b) : a;
    _module || (_module = getModuleBeingDefined() || global.__definingModule);
    if (!(klass != null ? klass.postCreate : void 0)) {
      return klass;
    }
    if (!(_module != null ? _module.hot : void 0)) {
      return klass.postCreate({
        hotReloadEnabled: false,
        hotReloaded: false,
        classModuleState: {},
        module: _module
      }) || klass;
    }
    return WebpackHotLoader.runHot(_module, function(moduleState) {
      var classModuleState, hotReloadKey, hotReloaded, liveClass;
      hotReloadKey = klass.getHotReloadKey();
      if (classModuleState = moduleState[hotReloadKey]) {
        liveClass = classModuleState.liveClass;
        hotReloaded = true;
        classModuleState.hotReloadVersion++;
        classModuleState.hotUpdatedFromClass = klass;
        liveClass.namespace._setChildNamespaceProps(liveClass.getName(), klass);
        klass._name = liveClass._name;
        liveClass.imprintFromClass(klass);
        liveClass.classModuleState = classModuleState;
        log({
          "Art.ClassSystem.BaseClass: class hot-reload": {
            "class": liveClass.getNamespacePath(),
            version: classModuleState.hotReloadVersion,
            hotReloadKey: hotReloadKey
          }
        });
      } else {
        hotReloaded = false;
        klass._hotClassModuleState = moduleState[hotReloadKey] = klass.classModuleState = classModuleState = {
          liveClass: liveClass = klass,
          hotUpdatedFromClass: null,
          hotReloadVersion: 0
        };
      }
      return liveClass.postCreate({
        hotReloadEnabled: true,
        hotReloaded: hotReloaded,
        classModuleState: classModuleState,
        module: _module
      });
    });
  };

  BaseClass.createHotWithPostCreate = function(a, b) {
    log.error("createHotWithPostCreate is DEPRICATED");
    return createWithPostCreate(a, b);
  };


  /*
  called every load
  IN: options:
    NOTE: hot-loading inputs are only set if this class created as follows:
      createHotWithPostCreate module, class Foo extends BaseClass
  
    hotReload: true/false
      true if this class was hot-reloaded
  
    hotReloadEnabled: true/false
  
    classModuleState:
      liveClass:            the first-loaded version of the class.
                            This is the official version of the class at all times.
                            The hot-reloaded version of the class is "imprinted" onto the liveClass
                            but otherwise is not used (but can be accessed via classModuleState.hotUpdatedFromClass)
      hotUpdatedFromClass:  The most recently loaded version of the class.
      hotReloadVersion:     number, starting at 1, and counting up each load
  
      classModuleState is a plain-object specific to the class and its CommonJS module. If there is
      more than one hot-loaded class in the same module, each will have its own classModuleState.
  
      SBD NOTE: Though we could allow clients to add fields to classModuleState, I think it works
      just as well, and is cleaner, if any state is stored in the actual class objects and
      persisted via postCreate.
  
    module: the CommonJs module object.
  
  {hotReloadEnabled, hotReloaded, classModuleState, module} = options
   */

  BaseClass.postCreate = function(options) {
    if (this.getIsAbstractClass()) {
      return this.postCreateAbstractClass(options);
    } else {
      return this.postCreateConcreteClass(options);
    }
  };

  BaseClass.setNamespace = function(ns) {
    return this._namespace = ns;
  };

  BaseClass.postCreateAbstractClass = function(options) {
    return this;
  };

  BaseClass.postCreateConcreteClass = function(options) {
    return this;
  };

  function BaseClass() {
    this.__uniqueId = null;
  }

  BaseClass.implementsInterface = function(object, methods) {
    var i, len, method;
    for (i = 0, len = methods.length; i < len; i++) {
      method = methods[i];
      if (typeof object[method] !== "function") {
        return false;
      }
    }
    return true;
  };


  /*
  mix-in class methods
  Define getters/setters example:
    class MyMixin
      included: ->
        @getter foo: -> @_foo
        @setter foo: (v) -> @_foo = v
  
  NOTE! This will NOT include any properties you defined with getter or setter!
  NOTE! This only copies over values if there aren't already values in the included-into class
    This somewhat mirrors Ruby's include where the included-into-class's methods take precidence.
    However, if you include two modules in a row, the first module gets priority here.
    In ruby the second module gets priority (I believe).
  
  DEPRICATED!!!
  Time to do it "right" - and it's just a simple pattern:
    Justin Fagnani figured this out. Thanks!
    Read More:
      http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
  
  To define a mixin:
  
    MyMixin = (superClass) ->
      class MyMixin extends superClass
        ... write your mixin as-if it were part of the normal inheritance hierachy
  
  To use a mixin:
  
    class MyClass extends MyMixin MySuperClass
  
  To use two mixins:
  
    class MyClass extends MyMixin1 MyMixin2 MySuperClass
   */

  warnedAboutIncludeOnce = false;

  BaseClass.include = function(obj) {
    var key, ref, value;
    log.error("DEPRICATED: BaseClass.include. Use pattern.");
    if (!warnedAboutIncludeOnce) {
      warnedAboutIncludeOnce = true;
      console.warn("Mixin pattern:\n\n  To define a mixin:\n\n    MyMixin = (superClass) ->\n      class MyMixin extends superClass\n        ... write your mixin as-if it were part of the normal inheritance hierachy\n\n  To use a mixin:\n\n    class MyClass extends MyMixin MySuperClass\n\n  To use two mixins:\n\n    class MyClass extends MyMixin1 MyMixin2 MySuperClass");
    }
    for (key in obj) {
      value = obj[key];
      if (key !== 'included') {
        if (!this[key]) {
          this[key] = value;
        }
      }
    }
    ref = obj.prototype;
    for (key in ref) {
      value = ref[key];
      if (key) {
        if (!this.prototype[key]) {
          this.prototype[key] = value;
        }
      }
    }
    if (typeof obj.included === "function") {
      obj.included(this);
    }
    return this;
  };

  BaseClass.getNamespacePath = function() {
    if (!this.namespacePath) {
      return "parentNamespaceNotSet." + (this.getName());
    } else {
      return this.namespacePath;
    }
  };

  BaseClass.getNamespacePathWithExtendsInfo = function() {
    var ref, ref1, ref2, ref3;
    if (!this.namespacePath || ((ref = this.__super__) != null ? (ref1 = ref["class"]) != null ? ref1.namespacePath : void 0 : void 0) === this.namespacePath) {
      return this.namespacePath = ((ref2 = (ref3 = this.namespace) != null ? ref3.namespacePath : void 0) != null ? ref2 : '(no parent namespace)') + "." + (this.getName()) + " extends " + (this.__super__["class"].getNamespacePath());
    } else {
      return this.namespacePath;
    }
  };

  BaseClass.getClassName = function(klass) {
    if (klass == null) {
      klass = this;
    }
    return (typeof klass.getName === "function" ? klass.getName() : void 0) || klass.name;
  };


  /*
  inspect: ->
  IN: ()
  OUT: string
  
  Can override with same or alternate, recursion-block-supported signature:
    IN: (inspector) ->
    OUT: if inspector then null else string
  
    To handle the case where the inspector is not set, we
    recommneded declaring your 'inspect' as follows:
      inspect: (inspector) ->
        return StandardLib.inspect @ unless inspector
         * ...
         * custom code which writes all output to inspector.put
         * and uses inspector.inspect for inspecting sub-objects
         * ...
        null
  
    EFFECT:
      call inspector.put one or multiple times with strings to add to the inspected output
      call inspector.inspect foo to sub-inspect other objects WITH RECURSION BLOCK
  
   * Example 1:
  inspect: (inspector) ->
    return StandardLib.inspect @ unless inspector
    inspector.put @getNamespacePath()
  
   * Example 2:
  inspect: ->
    @getNamespacePath()
   */

  BaseClass.inspect = function() {
    return this.getNamespacePath();
  };

  BaseClass.prototype.inspect = function() {
    return "<" + this["class"].namespacePath + ">";
  };


  /*
  getInspectedObjects: -> plainObjects
  
  usually implemented this way:
  @getter inspectedObjects: -> plainObjects or objects which implement "inspect"
  
  TODO: I think I want to refactor inspectedObjects to ONLY return near-JSON-compatible objects:
    1. strings
    2. maps
    3. arrays
  
    Everything else should be rendered to a string. In general, strings should Eval to the object
    they represent:
  
      toInspectedObject(null):                    'null' # null becomes a string
      toInspectedObject(true):                    'true' # true becomes a string
      toInspectedObject(false):                   'false' # false becomes a string
      toInspectedObject(undefined):               'undefined' # undefined becomes a string
      toInspectedObject('hi'):                    '"hi"' # ESCAPED
      toInspectedObject((a) -> a):                'function(a){return a;}'
      toInspectedObject(rgbColor())               "rgbColor('#000000')"
  
    NOTE: inspectedObjects differs from plainObjects. The latter should be 100% JSON,
      and should return actual values where JSON allows, otherwise, return JSON data structures
      that encode the object's information in a human-readable format, ideally one that can be
      used as an input to the constructor of the object's class to recreate the original object.
  
      plainObjects:
        null:         null
        true:         true
        false:        false
        'str':        'str' # NOT escaped
        undefined:    null
        ((a) -> a):   'function(a){return a;}'
        rgbColor():   r: 0, g: 0, b: 0, a: 0
  
  You can provide this function for fine-grained control of what Inspector2 outputs and hence
  what DomConsole displays.
  
  If you would like for a string to appear without quotes, use:
    {inspect: -> 'your string without quotes here'}
   */

  BaseClass.getter({
    inspectObjects: function() {
      console.warn("inspectObjects/getInspectObjects is DEPRICATED. Use: inspectedObjects/getInspectedObjects");
      return this.getInspectedObjects();
    },
    inspectedObjects: function() {
      var ref;
      return inspectedObjectLiteral("<" + ((ref = this["class"]) != null ? ref.getNamespacePath() : void 0) + ">");
    }
  });

  BaseClass.classGetter({
    inspectedObjects: function() {
      return inspectedObjectLiteral(this.getNamespacePath());
    }
  });


  /*
  Define this class as an abstract class. Implicitly it means
  any class it extends is also abstract, at least in this context.
  
  Definition: Abstract classes are not intended to every be instantiated.
    i.e.: never do: new MyAbstractClass
  
  TODO: in Debug mode, in the constructor:
    throw new Error "cannot instantiate abstract classes" if @class.getIsAbstractClass()
   */

  BaseClass.abstractClass = function() {
    if (this.getIsSingletonClass()) {
      throw new Error("abstract classes cannot also be singleton");
    }
    return this._firstAbstractAncestor = this;
  };

  BaseClass.classGetter({
    isAbstractClass: function() {
      return !(this.prototype instanceof this._firstAbstractAncestor);
    },
    abstractPrototype: function() {
      return this._firstAbstractAncestor.prototype;
    },
    firstAbstractAncestor: function() {
      return this._firstAbstractAncestor;
    },
    isSingletonClass: function() {
      var ref;
      return ((ref = this._singleton) != null ? ref["class"] : void 0) === this;
    },
    concretePrototypeProperties: function() {
      var abstractClassPrototype;
      abstractClassPrototype = this.getAbstractClass().prototype;
      return object(this.prototype, {
        when: function(v, k) {
          return k !== "constructor" && abstractClassPrototype[k] !== v;
        }
      });
    }
  });

  BaseClass.getAbstractClass = function() {
    return this._firstAbstractAncestor;
  };

  BaseClass.abstractClass();

  BaseClass.propertyIsAbstract = function(propName) {
    return this.getAbstractClass().prototype[propName] === this.prototype[propName];
  };

  BaseClass.propertyIsConcrete = function(propName) {
    return this.getAbstractClass().prototype[propName] !== this.prototype[propName];
  };


  /*
  SBD2017: this is the new path for singleton classes.
  WHY: We can elliminate the need to DECLARE classes singleton.
    Instead, we can just access the singleton for any class, if needed.
  TODO: once we are 100% CaffeineScript, switch this to a @classGetter
   */

  BaseClass.getSingleton = getSingleton = function() {
    var ref;
    if (((ref = this._singleton) != null ? ref["class"] : void 0) === this) {
      return this._singleton;
    } else {
      if (this.getIsAbstractClass()) {
        throw new Error("singleton classes cannot be abstract");
      }
      return this._singleton = new this;
    }
  };


  /*
  creates the classGetter "singleton" which returns a single instance of the current class.
  
  IN: args are passed to the singleton constructor
  OUT: null
  
  The singleton instance is created on demand the first time it is accessed.
  
  SBD2017: Possibly depricated; maybe we just need a singleton getter for everyone?
    The problem is coffeescript doesn't properly inherit class getters.
    BUT ES6 and CaffeineScript DO. So, when we switch over, I think we can do this.
   */

  BaseClass.singletonClass = function() {
    var obj1;
    if (this.getIsAbstractClass()) {
      throw new Error("singleton classes cannot be abstract");
    }
    this.classGetter((
      obj1 = {
        singleton: getSingleton
      },
      obj1["" + (decapitalize(functionName(this)))] = function() {
        return this.getSingleton();
      },
      obj1
    ));
    return null;
  };

  BaseClass.getter({
    className: function() {
      return this["class"].getClassName();
    },
    "class": function() {
      return this.constructor;
    },
    keys: function() {
      return Object.keys(this);
    },
    namespacePath: function() {
      return this["class"].getNamespacePath();
    },
    classPathNameAndId: function() {
      return this.classPathName + ":" + this.objectId;
    },
    uniqueId: function() {
      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
    },
    objectId: function() {
      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
    }
  });

  BaseClass.prototype.implementsInterface = function(methods) {
    return Function.BaseClass.implementsInterface(this, methods);
  };

  BaseClass.prototype.tap = function(f) {
    f(this);
    return this;
  };

  BaseClass.rawLog = function() {
    return Log.rawLog.apply(Log, arguments);
  };

  BaseClass.log = function() {
    var a, stack, toLog;
    stack = callStack();
    toLog = (function() {
      var i, len, results;
      if (arguments.length > 1) {
        results = [];
        for (i = 0, len = arguments.length; i < len; i++) {
          a = arguments[i];
          results.push(a);
        }
        return results;
      } else {
        return arguments[0];
      }
    }).apply(this, arguments);
    Log.logCore(toLog, stack, {
      className: this.className
    });
    return arguments[arguments.length - 1];
  };

  BaseClass.prototype.log = BaseClass.log;

  BaseClass.prototype.rawLog = BaseClass.rawLog;

  return BaseClass;

})(ExtendablePropertyMixin(MinimalBaseObject));


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, Config, Configurable, defineModule, isString, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, Configurable = ref.Configurable, log = ref.log, isString = ref.isString;

ArtEry = __webpack_require__(13);


/*
Pusher provieds a testing stub:
https://blog.pusher.com/testing-your-integration-with-the-pusher-javascript-library/
  "pusher-test-sub.js"

Could be useful for testing.

I'm having problems testing since connections can take a bit to fire up...
 */

defineModule(module, Config = (function(superClass) {
  var encodeKeyString;

  extend(Config, superClass);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }


  /*
  /Client.coffee and /Server.coffee set this appropriatly:
  Should be a function: () -> pusher instance
    IN: nothing
    OUT: pusher instance
  
  NOTE: Pusher has a different library for server-side and client-side.
    They are rather inconsistent. Their constructors take different argument structures.
    Their API's aren't even very similar.
   */

  Config.newPusher = null;

  Config.defaults({
    appId: "...",
    key: "...",
    secret: "...",
    cluster: null,
    encrypted: true,
    verbose: false,
    verifyConnection: false,
    pusherEventName: "changed"
  });

  encodeKeyString = function(key) {
    return key.replace(/[^-a-zA-Z0-9_=@,;]/g, ";");
  };


  /*
  IN:
    pipeline: string or pipeline
    key: string or plain object
      if plain object, must provide a pipeline that implements toKeyString
   */

  Config.getPusherChannel = function(pipeline, key) {
    if (!isString(key)) {
      key = pipeline.toKeyString(key);
    }
    if (!isString(pipeline)) {
      pipeline = pipeline.getName();
    }
    return [ArtEry.config.tableNamePrefix, pipeline, encodeKeyString(key)].join('.');
  };

  Config.configured = function() {
    var cluster, encrypted, key, pusher, ref1, verbose, verifyConnection;
    Config.__super__.constructor.configured.apply(this, arguments);
    ref1 = this.config, verbose = ref1.verbose, verifyConnection = ref1.verifyConnection, key = ref1.key, encrypted = ref1.encrypted, cluster = ref1.cluster;
    if (this.PusherClient) {
      pusher = this.pusherClient = new this.PusherClient(key, {
        encrypted: encrypted,
        cluster: cluster
      });
      verbose && log("ArtEryPusher: PusherClient initialized");
      if (verifyConnection) {
        log("ArtEryPusher: PusherClient - subscribing to connection state_change");
        return this.pusherClient.connection.bind('state_change', function(data) {
          return log({
            "ArtEryPusher: PusherClient state_change": data
          });
        });
      }
    } else if (this.PusherServer) {
      this.pusherServer = new this.PusherServer(log("pusher config", this.config));
      verbose && log("ArtEryPusher: PusherServer initialized");
      return verifyConnection && this.pusherServer.trigger('ArtEryPusherConfig', "server", {
        message: "ArtEryPusher: verifyConnection: pusher was initialized correctly"
      }, function(error, request, response) {
        if (error) {
          log.error("ArtEryPusher: PusherServer not initialized correctly! trigger-attempt error: " + error);
          return console.log(error);
        } else {
          return log("ArtEryPusher: PusherServer initialized correctly.");
        }
      });
    } else {
      if (verbose) {
        return log("ArtEryPusher disabled. Require: art-ery-pusher/Client or art-ery-pusher/Server");
      }
    }
  };

  Config.onConnected = function() {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        if (_this.pusherClient) {
          log("onConnected current state: " + _this.pusherClient.connection.state);
          if (_this.pusherClient.connection.state === "connected") {
            return resolve();
          } else {
            return _this.pusherClient.connection.bind('state_change', function(arg) {
              var current;
              current = arg.current;
              log("onConnected updated state: " + current);
              if (current === "connected") {
                return resolve();
              }
            });
          }
        } else {
          return reject("no pusherClient");
        }
      };
    })(this));
  };

  return Config;

})(Configurable));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AfterEventsFilter, Filter, Promise, defineModule, formattedInspect, isFunction, isString, log, pushIfNotPresent, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, isFunction = ref.isFunction, isString = ref.isString, pushIfNotPresent = ref.pushIfNotPresent, formattedInspect = ref.formattedInspect;

Filter = __webpack_require__(9);

defineModule(module, AfterEventsFilter = (function(superClass) {
  extend(AfterEventsFilter, superClass);

  function AfterEventsFilter() {
    return AfterEventsFilter.__super__.constructor.apply(this, arguments);
  }

  AfterEventsFilter.handlers = {};

  AfterEventsFilter._registeredPipelineHandlers = {};

  AfterEventsFilter._reset = function() {
    AfterEventsFilter.handlers = {};
    return AfterEventsFilter._registeredPipelineHandlers = {};
  };

  AfterEventsFilter.on = function(pipelineName, requestType, actionOrPipeline) {
    var base, base1;
    return pushIfNotPresent(((base = ((base1 = this.handlers)[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])), actionOrPipeline);
  };

  AfterEventsFilter.registerPipelineListener = function(listeningPipeline, listeningToPipelineName, requestType) {
    if (!isFunction(listeningPipeline.handleRequestAfterEvent)) {
      throw new Error("listeningPipeline must implement handleRequestAfterEvent");
    }
    if (!isString(listeningToPipelineName)) {
      throw new Error("listeningToPipelineName must be a string");
    }
    return this.on(listeningToPipelineName, requestType, listeningPipeline);
  };

  AfterEventsFilter.sendEvents = function(response) {
    return Promise.resolve(response).then(function(response) {
      var actionOrPipeline, actionPromises, pipelineName, requestType;
      pipelineName = response.pipelineName, requestType = response.requestType;
      actionPromises = (function() {
        var i, len, ref1, ref2, results;
        ref2 = ((ref1 = AfterEventsFilter.handlers[pipelineName]) != null ? ref1[requestType] : void 0) || [];
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          actionOrPipeline = ref2[i];
          if (isFunction(actionOrPipeline.handleRequestAfterEvent)) {
            results.push(actionOrPipeline.handleRequestAfterEvent(response));
          } else {
            results.push(actionOrPipeline(response));
          }
        }
        return results;
      })();
      return Promise.all(actionPromises);
    }).then(function() {
      return response;
    });
  };

  AfterEventsFilter.after({
    all: function(response) {
      return AfterEventsFilter.sendEvents(response);
    }
  });

  return AfterEventsFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, Promise, ValidationFilter, Validator, defineModule, log, merge, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, log = ref.log, Validator = ref.Validator, merge = ref.merge, Promise = ref.Promise;

Filter = __webpack_require__(9);


/*
TODO!!!
 * BUG: ValidationFilter doesn't validated the TimestampFilter's fields! (when using createDatabaseFilters)
 * PROBLEM: ValidationFilter only validates the fields it is passed.
 * SOLUTION: we need it to always validate all fields declared for the pipeline.
 * createDatabaseFilters needs to change order: it needs to run ValidationFilter last.

I almost want to rename this "FieldTypesFilter" - since it both validates and preprocesses.
It should actually also have an @after pass that at least converts timestamps back into Dates.
 */

defineModule(module, ValidationFilter = (function(superClass) {
  extend(ValidationFilter, superClass);

  ValidationFilter.location("both");

  function ValidationFilter(options) {
    ValidationFilter.__super__.constructor.apply(this, arguments);
    this._exclusive = options != null ? options.exclusive : void 0;
    this._validator = new Validator(this.fields);
  }

  ValidationFilter.before({
    create: function(request) {
      return this._validate("validateCreate", request);
    },
    update: function(request) {
      return this._validate("validateUpdate", request);
    }
  });

  ValidationFilter.prototype._validate = function(method, request) {
    return Promise.then((function(_this) {
      return function() {
        var data, fields, k, ref1, rejection, unexpectedFields, v, validatedData;
        validatedData = _this._validator[method](request.data, {
          context: (((ref1 = request.pipeline) != null ? ref1.getName() : void 0) || "no pipeline?") + " " + (_this["class"].getName())
        });
        if (request.location !== "client") {
          data = validatedData;
        }
        rejection = (function() {
          if (this._exclusive) {
            fields = request.pipeline.fields;
            unexpectedFields = null;
            for (k in data) {
              v = data[k];
              if (!fields[k]) {
                (unexpectedFields || (unexpectedFields = [])).push(k);
              }
            }
            if (unexpectedFields) {
              return Promise.reject({
                message: "unexpected fields: " + (unexpectedFields.join(', ')),
                info: {
                  unexpected: unexpectedFields
                }
              });
            }
          }
        }).call(_this);
        return rejection || request.withData(data);
      };
    })(this))["catch"](function(arg) {
      var info, message;
      message = arg.message, info = arg.info;
      log({
        request: request
      });
      return request.clientFailure({
        data: merge({
          message: message
        }, info)
      });
    });
  };

  return ValidationFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, PipelineRegistry, compactFlatten, decapitalize, defineModule, each, inspect, isClass, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, each = ref.each, compactFlatten = ref.compactFlatten, log = ref.log, BaseObject = ref.BaseObject, decapitalize = ref.decapitalize, isClass = ref.isClass, inspect = ref.inspect;

defineModule(module, PipelineRegistry = (function(superClass) {
  var pipelines;

  extend(PipelineRegistry, superClass);

  function PipelineRegistry() {
    return PipelineRegistry.__super__.constructor.apply(this, arguments);
  }

  PipelineRegistry.pipelines = pipelines = {};

  PipelineRegistry.register = function(PipelineClass) {
    var _aliases, alias, singleton;
    singleton = PipelineClass.singleton, _aliases = PipelineClass._aliases;
    _aliases && (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = _aliases.length; i < len; i++) {
        alias = _aliases[i];
        results.push(pipelines[alias] = singleton);
      }
      return results;
    })();
    return pipelines[singleton.name] = singleton;
  };

  PipelineRegistry._reset = function(testFunction) {
    if (testFunction == null) {
      testFunction = function() {
        return true;
      };
    }
    return each(Object.keys(pipelines), function(key) {
      if (testFunction(pipelines[key])) {
        return delete pipelines[key];
      }
    });
  };

  return PipelineRegistry;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ErrorWithInfo, Promise, RequestHandler, RequestResponseBase, defineModule, isJsonType, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), ErrorWithInfo = ref.ErrorWithInfo, defineModule = ref.defineModule, Promise = ref.Promise, isJsonType = ref.isJsonType, log = ref.log;

RequestResponseBase = __webpack_require__(38);

defineModule(module, RequestHandler = (function(superClass) {
  extend(RequestHandler, superClass);

  function RequestHandler() {
    return RequestHandler.__super__.constructor.apply(this, arguments);
  }

  RequestHandler.abstractClass();


  /*
  OUT:
    promise.then (request or response) ->
      NOTE: response may be failing
    .catch -> internal errors only
   */

  RequestHandler.prototype.applyHandler = function(request, handlerFunction) {
    if (!handlerFunction) {
      return Promise.resolve(request);
    }
    return Promise.then((function(_this) {
      return function() {
        request.addFilterLog(_this);
        return handlerFunction.call(_this, request);
      };
    })(this)).then((function(_this) {
      return function(data) {
        if (data == null) {
          return request.missing();
        } else if (data instanceof RequestResponseBase) {
          return data;
        } else if (isJsonType(data)) {
          return request.success({
            data: data
          });
        } else {
          throw new ErrorWithInfo("invalid response data passed to RequestResponseBaseNext", {
            data: data
          });
        }
      };
    })(this), (function(_this) {
      return function(error) {
        var ref1, ref2;
        if ((ref1 = error.props) != null ? (ref2 = ref1.response) != null ? ref2.isResponse : void 0 : void 0) {
          return error.props.response;
        } else {
          return request.failure({
            errorProps: {
              exception: error,
              source: {
                "this": _this,
                "function": handlerFunction
              }
            }
          });
        }
      };
    })(this));

    /*
    IN:
      request OR response
    
      if response, it is immediately returned
    OUT:
      promise.then -> response
        response may or maynot be successful, but it is always returned via the promise-success path
    
      promise.catch -> always means an internal failure
    
    OVERRIDE THIS
     */
  };

  return RequestHandler;

})(__webpack_require__(35)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, CommunicationStatus, Foundation, Promise, Request, RequestError, Response, Validator, arrayWith, clientFailure, compactFlatten, config, failure, formattedInspect, inspect, isJsonType, isPlainArray, isPlainObject, log, merge, missing, object, objectKeyCount, peek, pureMerge, responseValidator, serverFailure, success, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Request = __webpack_require__(37);

pureMerge = Foundation.pureMerge, Promise = Foundation.Promise, BaseObject = Foundation.BaseObject, compactFlatten = Foundation.compactFlatten, object = Foundation.object, peek = Foundation.peek, isPlainArray = Foundation.isPlainArray, objectKeyCount = Foundation.objectKeyCount, arrayWith = Foundation.arrayWith, inspect = Foundation.inspect, RequestError = Foundation.RequestError, isPlainObject = Foundation.isPlainObject, log = Foundation.log, CommunicationStatus = Foundation.CommunicationStatus, Validator = Foundation.Validator, merge = Foundation.merge, isJsonType = Foundation.isJsonType, formattedInspect = Foundation.formattedInspect, w = Foundation.w;

success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure, serverFailure = CommunicationStatus.serverFailure, clientFailure = CommunicationStatus.clientFailure;

config = __webpack_require__(11).config;

responseValidator = new Validator({
  request: w("required", {
    "instanceof": Request
  }),
  status: w("required communicationStatus"),
  session: "object",
  props: "object"
});


/*
TODO: Merge Response back into Request

  Turns out, Response has very little special functionality.
  At this point, the RequestuestResponseBase / Request / Response class structure
  actually requires more code than just one, Request class would.

What to add to Request:

  @writeOnceProperty "responseStatus responseSession responseProps"

  @getter
    hasResponse: -> !!@responseStatus

  Split out: filterLog into beforeFilterLog and afterFilterLog.
 */


/*
new Response

IN:
  request: Request (required)
  status: CommunicationStatus (required)
  props: plainObject with all JSON values
  session: plainObject with all JSON values

  data: JSON value
    data is an alias for @props.data
    EFFECT: replaces @props.data
    NOTE: for clientRequest, @props.data is the value returned unless returnResponseObject is requested

  remoteRequest: remoteResponse:
    Available for inspecting what exactly went over-the-wire.
    Otherwise ignored by Response

  replaceSession: false
    If true, then the current session will be replace instead of merged
    with the new one. If no new session is provided, the old session
    will be reset to empty.

    NOTE: Pipeline is responsible for updating the Client session
      from the response session returned after a request.

      Pipeline checks for @replaceSession to implement the above
      semantics.
 */

module.exports = Response = (function(superClass) {
  extend(Response, superClass);

  function Response(options) {
    var ref;
    Response.__super__.constructor.apply(this, arguments);
    responseValidator.validate(options, {
      context: "Art.Ery.Response options",
      logErrors: true
    });
    this.request = options.request, this.status = options.status, this.props = (ref = options.props) != null ? ref : {}, this.session = options.session, this.remoteRequest = options.remoteRequest, this.remoteResponse = options.remoteResponse, this.replaceSession = options.replaceSession;
    if (options.requestOptions) {
      throw new Error("options.requestOptions is DEPRICATED - use options.props");
    }
    if (options.data) {
      this._props.data = options.data;
    }
    this.session || (this.session = this.request.session);
    if (this.status !== success) {
      this._captureErrorStack();
    }
    if (this.type === "create" || this.type === "get") {
      this.setGetCache();
    }
  }

  Response.prototype.isResponse = true;

  Response.property("request props session replaceSession remoteResponse remoteRequest");

  Response.setter("status");

  Response.getter({
    status: function() {
      if (this.failed) {
        switch (this.location) {
          case "server":
            return serverFailure;
          case "client":
            return clientFailure;
        }
      }
      return this._status;
    },
    failed: function() {
      return this._status === failure;
    },
    data: function() {
      return this._props.data;
    },
    responseData: function() {
      return this._props.data;
    },
    responseProps: function() {
      return this._props;
    },
    beforeFilterLog: function() {
      return this.request.filterLog || [];
    },
    handledBy: function() {
      return !this.failed && peek(this.request.filterLog);
    },
    afterFilterLog: function() {
      return this.filterLog || [];
    },
    isSuccessful: function() {
      return this._status === success;
    },
    isMissing: function() {
      return this._status === missing;
    },
    notSuccessful: function() {
      return this._status !== success;
    },
    description: function() {
      return this.requestString + ": " + this.status;
    },
    propsForClone: function() {
      return {
        request: this.request,
        status: this.status,
        props: this.props,
        session: this.session,
        filterLog: this.filterLog,
        remoteRequest: this.remoteRequest,
        remoteResponse: this.remoteResponse,
        errorProps: this.errorProps
      };
    },
    propsForResponse: function() {
      return this.propsForClone;
    },
    plainObjectsResponse: function(fields) {
      return object(fields || {
        status: this.status,
        props: this.props,
        session: this.session,
        beforeFilterLog: this.beforeFilterLog,
        afterFilterLog: this.afterFilterLog
      }, {
        when: function(v) {
          switch (false) {
            case !isPlainObject(v):
              return objectKeyCount(v) > 0;
            case !isPlainArray(v):
              return v.length > 0;
            default:
              return v !== void 0;
          }
        }
      });
    },
    responseForRemoteRequest: function() {
      return this.getPlainObjectsResponse(!config.returnProcessingInfoToClient ? {
        status: this.status,
        props: this.props,
        session: this.session
      } : void 0);
    }
  });

  Response.prototype.withMergedSession = function(session) {
    return Promise.resolve(session).then((function(_this) {
      return function(session) {
        return new _this["class"](merge(_this.propsForClone, {
          session: merge(_this.session, session)
        }));
      };
    })(this));
  };


  /*
  IN: options:
    returnNullIfMissing: true [default: false]
      if status == missing
        if returnNullIfMissing
          promise.resolve null
        else
          promise.reject new RequestError
  
    returnResponseObject: true [default: false]
      if true, the response object is returned, otherwise, just the data field is returned.
  
  OUT:
     * if response.isSuccessful && returnResponseObject == true
    promise.then (response) ->
  
     * if response.isSuccessful && returnResponseObject == false
    promise.then (data) ->
  
     * if response.isMissing && returnNullIfMissing == true
    promise.then (data) -> # data == null
  
     * else
    promise.catch (errorWithInfo) ->
      {response} = errorWithInfo.info
   */

  Response.prototype.toPromise = function(options) {
    var data, isMissing, isSuccessful, ref, returnNullIfMissing, returnResponseObject;
    if (options) {
      returnNullIfMissing = options.returnNullIfMissing, returnResponseObject = options.returnResponseObject;
    }
    ref = this, data = ref.data, isSuccessful = ref.isSuccessful, isMissing = ref.isMissing;
    if (isMissing && returnNullIfMissing) {
      data = null;
      isSuccessful = true;
    }
    if (isSuccessful) {
      return Promise.resolve(returnResponseObject ? this : data);
    } else {
      return Promise.reject(this._getRejectionError());
    }
  };

  Response.prototype._getRejectionError = function() {
    var ref, ref1, ref2, ref3;
    return this._preparedRejectionError || (this._preparedRejectionError = new RequestError({
      sourceLib: "ArtEry " + this.pipelineName,
      requestData: this.requestData,
      type: this.type,
      key: this.key,
      status: this.status,
      data: this.data,
      response: this,
      message: (ref = this.errorProps) != null ? (ref1 = ref.exception) != null ? ref1.message : void 0 : void 0,
      stack: (ref2 = this.errorProps) != null ? (ref3 = ref2.exception) != null ? ref3.stack : void 0 : void 0
    }));
  };


  /*
  EFFECT:
    If we create the RequestError when the error-response is created
    we are much more likely to capture the correct stack-trace for the
    events that lead to the error.
  
  TODO: We may only want to do this when artPromiseDebug=true or dev=true
   */

  Response.prototype._captureErrorStack = function() {
    return this._getRejectionError();
  };

  return Response;

})(__webpack_require__(38));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, EventedMixin, JsonStore, Promise, Session, Validator, config, inspect, isBrowser, isObject, isPlainObject, isString, log, merge, plainObjectsDeepEq, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventedMixin = __webpack_require__(114).EventedMixin;

config = __webpack_require__(11).config;

ref = __webpack_require__(0), isPlainObject = ref.isPlainObject, Promise = ref.Promise, BaseObject = ref.BaseObject, merge = ref.merge, inspect = ref.inspect, isString = ref.isString, isObject = ref.isObject, log = ref.log, plainObjectsDeepEq = ref.plainObjectsDeepEq, isBrowser = ref.isBrowser;

Validator = __webpack_require__(17).Validator;

JsonStore = __webpack_require__(2).JsonStore;

module.exports = Session = (function(superClass) {
  var jsonStore;

  extend(Session, superClass);

  jsonStore = new JsonStore;


  /*
  A global singleton Session is provided and used by default.
  Or multiple instances can be created and passed to the
  constructor of each Pipeline for per-pipeline custom sessions.
   */

  Session.singletonClass();

  Session.property("data jsonStoreKey");

  function Session(_data, _jsonStoreKey) {
    this._data = _data != null ? _data : {};
    this._jsonStoreKey = _jsonStoreKey != null ? _jsonStoreKey : "Art.Ery.Session";
    if (typeof global !== "undefined" && global !== null ? global.document : void 0) {
      this._startPollingSession();
    }
  }

  Session.prototype._startPollingSession = function() {
    return setInterval((function(_this) {
      return function() {
        return _this.reloadSession();
      };
    })(this), 2000);
  };

  Session.prototype.reloadSession = function() {
    this._sessionLoadPromise = null;
    return this.loadSession();
  };

  Session.prototype.loadSession = function() {
    return this._sessionLoadPromise || (this._sessionLoadPromise = this.jsonStoreKey ? jsonStore.getItem(this.jsonStoreKey).then((function(_this) {
      return function(data) {
        if (isPlainObject(data)) {
          return _this.data = data;
        }
      };
    })(this)) : Promise.resolve());
  };

  Session.getter("sessionLoadPromise", {
    loadedDataPromise: function() {
      if (config.location === "server") {
        throw new Error("INTERNAL ERROR: Attempted to access the global session serverside. HINT: Use 'session: {}' for no-session requests.");
      }
      return this.loadSession().then((function(_this) {
        return function() {
          return _this.data;
        };
      })(this));
    },
    sessionSignature: function() {
      var ref1;
      return (ref1 = this._data) != null ? ref1.signature : void 0;
    },
    inspectedObjects: function() {
      return this._data;
    }
  });

  Session.setter({
    data: function(v) {
      if (!plainObjectsDeepEq(v, this._data)) {
        this.queueEvent("change", {
          data: v
        });
      }
      this._data = v;
      return this.jsonStoreKey && jsonStore.setItem(this.jsonStoreKey, v);
    }
  });

  Session.prototype.reset = function() {
    return this.data = {};
  };

  if (isBrowser) {
    Session.singleton.loadSession();
  }

  return Session;

})(EventedMixin(__webpack_require__(35)));


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Event, currentSecond, emptyProps,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

currentSecond = __webpack_require__(0).currentSecond;

BaseClass = __webpack_require__(3).BaseClass;

emptyProps = {};

module.exports = Event = (function(superClass) {
  extend(Event, superClass);

  function Event(type, props, timeStamp) {
    this.type = type;
    this.props = props != null ? props : emptyProps;
    this.timeStamp = timeStamp != null ? timeStamp : currentSecond();
  }

  return Event;

})(BaseClass);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var BinaryString, File, Promise, StandardLib;

StandardLib = __webpack_require__(0);

Promise = StandardLib.Promise;

BinaryString = __webpack_require__(14);

module.exports = File = (function() {
  var readAsArrayBuffer;

  function File() {}

  File._readWithPromise = function(readFunction) {
    return function(file) {
      return new Promise(function(resolve, reject) {
        var fr;
        fr = new FileReader;
        fr[readFunction](file);
        fr.onerror = reject;
        return fr.onload = (function(_this) {
          return function(event) {
            return resolve(event.target.result);
          };
        })(this);
      });
    };
  };

  File.readAsArrayBuffer = readAsArrayBuffer = File._readWithPromise("readAsArrayBuffer");

  File.readAsDataURL = File._readWithPromise("readAsDataURL");

  File.readAsBinaryString = function(file) {
    return readAsArrayBuffer(file).then(function(arrayBuffer) {
      return new BinaryString(arrayBuffer);
    });
  };

  return File;

})();


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var CallStack, inspect, isString, parseUrl;

isString = __webpack_require__(4).isString;

parseUrl = __webpack_require__(47).parseUrl;

inspect = __webpack_require__(23).inspect;

module.exports = CallStack = (function() {
  var CallStackLine;

  function CallStack() {}

  CallStack.errorToString = function(error) {
    return (error != null ? error.error : void 0) || (error != null ? error.message : void 0) || (isString(error) && error) || Neptune.Art.StandardLib.formattedInspect(error);
  };

  CallStack.CallStackLine = CallStackLine = (function() {
    CallStackLine.getter = function(map) {
      var getter, prop, results;
      results = [];
      for (prop in map) {
        getter = map[prop];
        results.push(Object.defineProperty(this.prototype, prop, {
          get: getter,
          configurable: true
        }));
      }
      return results;
    };

    CallStackLine.setter = function(map) {
      var prop, results, setter;
      results = [];
      for (prop in map) {
        setter = map[prop];
        results.push(Object.defineProperty(this.prototype, prop, {
          set: setter,
          configurable: true
        }));
      }
      return results;
    };

    function CallStackLine(line) {
      this.original = line;
      this["function"] = null;
      this.source = null;
      this["class"] = null;
      this.classPath = null;
      this.sourceFileName = null;
      this.sourcePath = null;
      this.sourceHostWithPort = null;
      this.sourceLine = 0;
      this.sourceColumn = 0;
      if (this.parseLineWithFunction(line)) {

      } else {
        this.parseLineWithoutFunction(line);
      }
      this.subParseFunction();
      this.subParseSource();
    }

    CallStackLine.prototype.toString = function() {
      return this.original;
    };

    CallStackLine.getter({
      fileWithLocation: function() {
        return this._fileWithLocation || (this._fileWithLocation = this.sourceFileName ? this.sourcePath + "/" + this.sourceFileName + ":" + this.sourceLine + ":" + this.sourceColumn : this.original);
      }
    });

    CallStackLine.prototype.parseLineWithFunction = function(line) {
      var r;
      if (r = line.match(/\s*at\s((new\s)?[a-zA-Z0-9_.<>]+)\s\(([^)]*):([0-9]+):([0-9]+)\)/)) {
        this["function"] = r[1];
        this.source = r[3];
        this.sourceLine = r[4] | 0;
        return this.sourceColumn = r[5] | 0;
      }
    };

    CallStackLine.prototype.parseLineWithoutFunction = function(line) {
      var r;
      if (r = line.match(/\s*at\s([^)]*):([0-9]+):([0-9]+)/)) {
        this.source = r[1];
        this.sourceLine = r[2] | 0;
        return this.sourceColumn = r[3] | 0;
      }
    };

    CallStackLine.prototype.subParseSource = function() {
      var url;
      if (this.source) {
        url = parseUrl(this.source);
        this.sourceFileName = url.fileName;
        this.sourcePath = url.path;
        return this.sourceHostWithPort = url.hostWithPort;
      }
    };

    CallStackLine.prototype.subParseFunction = function() {
      var f;
      if (this["function"]) {
        f = this["function"].split(".");
        this["function"] = f[f.length - 1];
        if (this["function"] === "<anonymous>") {
          this["function"] = void 0;
        }
        this["class"] = f[f.length - 2];
        return this.classPath = f.slice(0, f.length - 2);
      }
    };

    return CallStackLine;

  })();

  CallStack.rawCallStack = (new Error).stack ? function(ignoreTop) {
    if (ignoreTop == null) {
      ignoreTop = 0;
    }
    return (new Error).stack.split(/\n  */).slice(ignoreTop + 2);
  } : function(ignoreTop) {
    var e;
    if (ignoreTop == null) {
      ignoreTop = 0;
    }
    try {
      throw new Error;
    } catch (error1) {
      e = error1;
      return e.stack.split(/\n  */).slice(ignoreTop + 2);
    }
  };

  CallStack.callStack = function(ignoreTop) {
    var i, len, line, ref, results;
    if (ignoreTop == null) {
      ignoreTop = 0;
    }
    ref = CallStack.rawCallStack(ignoreTop + 1);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      results.push(new CallStackLine(line));
    }
    return results;
  };

  return CallStack;

})();


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var Eq, floatTrue0, isNumber, isString, min, objectKeyCount, ref, remove,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

remove = __webpack_require__(42).remove;

objectKeyCount = __webpack_require__(28).objectKeyCount;

floatTrue0 = __webpack_require__(24).floatTrue0;

ref = __webpack_require__(4), isString = ref.isString, isNumber = ref.isNumber;

min = Math.min;

module.exports = Eq = (function() {
  var plainObjectsDeepDiff, plainObjectsDeepEq;

  function Eq() {}


  /*
  IN: see @compare
  OUT:
    true: if a and b are structurally equal
    false: otherwise
   */

  Eq.eq = function(a, b) {
    return 0 === Eq.compare(a, b, true);
  };

  Eq.neq = function(a, b) {
    return 0 !== Eq.compare(a, b, true);
  };

  Eq.fastEq = function(a, b) {
    return 0 === Eq.compare(a, b, false);
  };

  Eq.fastNeq = function(a, b) {
    return 0 !== Eq.compare(a, b, false);
  };

  Eq._compareArray = function(a, b, recursionBlockArray) {
    var aLength, av, bLength, bv, i, j, ref1, val;
    aLength = a.length;
    bLength = b.length;
    for (i = j = 0, ref1 = Math.min(aLength, bLength); j < ref1; i = j += 1) {
      av = a[i];
      bv = b[i];
      if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
        return val;
      }
    }
    return aLength - bLength;
  };

  Eq._compareObject = function(a, b, recursionBlockArray) {
    var aLength, av, bv, compared, k, val;
    aLength = 0;
    compared = 0;
    for (k in a) {
      av = a[k];
      aLength++;
      av = a[k];
      bv = b[k];
      if (bv !== void 0 || b.hasOwnProperty(k)) {
        compared++;
        if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
          return val;
        }
      }
    }
    if (aLength === compared && compared === objectKeyCount(b)) {
      return 0;
    } else {
      return 0/0;
    }
  };


  /*
  compare is recursive. However, it only recurses for 'plain' objects and arrays.
  
  If you want to compare custom objects deeply, you must add an .eq or .compare function to your custom objects.
    signature: a.eq b, recursionBlockArray => truthy if a equals b
    signature: a.compare b, recursionBlockArray => NaN / <0 / 0 / >0 for incomparable / a<b / a==b / a>b respectively
    IN:
      a: => this/@
      b: compared with a
      recursionBlockArray: an array of objects already on the stack being tested, pass this to
    It is an array of every object recursively currently being tested - don't test an object in this array
    recursionBlockArray can be altered, but should be returned in its original state. It may be null.
  
  IN:
    a and b: compare a and b
    recursionBlockEnabled:
      truthy: recursive structures will be handled correctly
      falsey: (default) faster, but recursive structures result in infinite recursion
  OUT:
    NaN:
      a and b are different types
      a and b are otherwise not comparable
  
    <0: a < b
    0:  a == b
    >0: a > b
   */

  Eq.compare = function(a, b, recursionBlockEnabled) {
    return Eq._compare(a, b, recursionBlockEnabled && []);
  };

  Eq._compare = function(a, b, recursionBlockArray) {
    var _constructor;
    if (a === b) {
      return 0;
    }
    if ((a != null) && (b != null) && a.constructor === (_constructor = b.constructor)) {
      if (isString(a)) {
        return a.localeCompare(b);
      }
      if (isNumber(a)) {
        return floatTrue0(a - b);
      }
      if (recursionBlockArray) {
        if (indexOf.call(recursionBlockArray, a) >= 0 || indexOf.call(recursionBlockArray, b) >= 0) {
          return 0;
        }
        recursionBlockArray.push(a);
        recursionBlockArray.push(b);
      }
      if (a.compare) {
        return a.compare(b, recursionBlockArray);
      }
      if (_constructor === Array) {
        return Eq._compareArray(a, b, recursionBlockArray);
      }
      if (_constructor === Object) {
        return Eq._compareObject(a, b, recursionBlockArray);
      }
      if (a.eq && a.eq(b, recursionBlockArray)) {
        return 0;
      }
      if (recursionBlockArray) {
        remove(recursionBlockArray, recursionBlockArray.length - 2, 2);
      }
    }
    return 0/0;
  };

  Eq.plainObjectsDeepEqArray = function(a, b) {
    var av, i, j, len1;
    if (a.length !== b.length) {
      return false;
    }
    for (i = j = 0, len1 = a.length; j < len1; i = ++j) {
      av = a[i];
      if (!Eq.plainObjectsDeepEq(av, b[i])) {
        return false;
      }
    }
    return true;
  };

  Eq.plainObjectsDeepEqObject = function(a, b) {
    var aLength, av, bv, k;
    aLength = 0;
    for (k in a) {
      av = a[k];
      aLength++;
      bv = b[k];
      if (!((bv !== void 0 || b.hasOwnProperty(k)) && Eq.plainObjectsDeepEq(av, bv))) {
        return false;
      }
    }
    return aLength === objectKeyCount(b);
  };

  Eq.plainObjectsDeepEq = plainObjectsDeepEq = function(a, b) {
    var _constructor;
    if (a === b) {
      return true;
    } else if (a && b && a.constructor === (_constructor = b.constructor)) {
      if (a.eq) {
        return a.eq(b);
      } else if (_constructor === Array) {
        return Eq.plainObjectsDeepEqArray(a, b);
      } else if (_constructor === Object) {
        return Eq.plainObjectsDeepEqObject(a, b);
      } else {
        return false;
      }
    } else {
      return false;
    }
  };

  Eq.propsEq = plainObjectsDeepEq;

  Eq.plainObjectsDeepDiffArray = function(before, after) {
    var diff, i, j, l, len, m, ref1, ref2, ref3, ref4, ref5, res;
    res = null;
    len = min(before.length, after.length);
    for (i = j = 0, ref1 = len; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      if (!(diff = plainObjectsDeepDiff(before[i], after[i]))) {
        continue;
      }
      res || (res = {});
      res[i] = diff;
    }
    if (len < before.length) {
      for (i = l = ref2 = len, ref3 = before.length; ref2 <= ref3 ? l < ref3 : l > ref3; i = ref2 <= ref3 ? ++l : --l) {
        res || (res = {});
        res[i] = {
          removed: before[i]
        };
      }
    }
    if (len < after.length) {
      for (i = m = ref4 = len, ref5 = after.length; ref4 <= ref5 ? m < ref5 : m > ref5; i = ref4 <= ref5 ? ++m : --m) {
        res || (res = {});
        res[i] = {
          added: after[i]
        };
      }
    }
    return res;
  };

  Eq.plainObjectsDeepDiffObject = function(before, after) {
    var afterV, beforeV, diff, k, res;
    res = null;
    for (k in before) {
      beforeV = before[k];
      if (after.hasOwnProperty(k)) {
        if (diff = plainObjectsDeepDiff(beforeV, after[k])) {
          res || (res = {});
          res[k] = diff;
        }
      } else {
        res || (res = {});
        res[k] = {
          removed: beforeV
        };
      }
    }
    for (k in after) {
      afterV = after[k];
      if (!(!before.hasOwnProperty(k))) {
        continue;
      }
      res || (res = {});
      res[k] = {
        added: afterV
      };
    }
    return res;
  };

  Eq.plainObjectsDeepDiff = plainObjectsDeepDiff = function(before, after) {
    var _constructor;
    if (before === after) {
      return null;
    } else if (before && after && before.constructor === (_constructor = after.constructor)) {
      if (before.eq) {
        if (before.eq(after)) {
          return null;
        } else {
          return {
            before: before,
            after: after
          };
        }
      } else if (_constructor === Array) {
        return Eq.plainObjectsDeepDiffArray(before, after);
      } else if (_constructor === Object) {
        return Eq.plainObjectsDeepDiffObject(before, after);
      } else {
        return {
          before: before,
          after: after
        };
      }
    } else {
      return {
        before: before,
        after: after
      };
    }
  };

  Eq.diff = plainObjectsDeepDiff;

  Eq.shallowEq = function(a, b) {
    return a === b || (a && b && a.eq && a.eq(b));
  };

  return Eq;

})();


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var InspectedObjects, dateFormat, deepMap, escapeJavascriptString, inspectedObjectLiteral, isClass, isDate, isFunction, isNonNegativeInt, isPlainArray, isPlainObject, isPromise, isRegExp, isString, ref;

ref = __webpack_require__(4), isDate = ref.isDate, deepMap = ref.deepMap, isNonNegativeInt = ref.isNonNegativeInt, isClass = ref.isClass, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isString = ref.isString, isFunction = ref.isFunction, isPromise = ref.isPromise, isRegExp = ref.isRegExp;

escapeJavascriptString = __webpack_require__(16).escapeJavascriptString;

inspectedObjectLiteral = __webpack_require__(44).inspectedObjectLiteral;

dateFormat = __webpack_require__(160);

module.exports = InspectedObjects = (function() {
  var toInspectedObjects;

  function InspectedObjects() {}

  InspectedObjects.toInspectedObjects = toInspectedObjects = function(m) {
    var functionString, literal, oldm, out, reducedFunctionString;
    if (m == null) {
      return m;
    }
    oldm = m;
    if (m === global) {
      return inspectedObjectLiteral("global");
    } else if (out = typeof m.getInspectedObjects === "function" ? m.getInspectedObjects() : void 0) {
      return out;
    } else if (isPromise(m)) {
      return inspectedObjectLiteral("Promise");
    } else if (isPlainObject(m) || isPlainArray(m)) {
      return deepMap(m, function(v) {
        return toInspectedObjects(v);
      });
    } else if (m instanceof Error) {
      literal = inspectedObjectLiteral(m.stack || m.toString(), true);
      if (m.info) {
        return toInspectedObjects({
          Error: {
            info: m.info,
            stack: literal
          }
        });
      } else {
        return {
          Error: {
            "class": toInspectedObjects(m.constructor),
            stack: literal
          }
        };
      }
    } else if (isRegExp(m)) {
      return inspectedObjectLiteral("" + m);
    } else if (isDate(m)) {
      return inspectedObjectLiteral(dateFormat(m, "UTC:yyyy-mm-dd HH:MM:ss Z"));
    } else if (isClass(m)) {
      return inspectedObjectLiteral("<" + ((typeof m.getName === "function" ? m.getName() : void 0) || m.name) + ">");
    } else if (isFunction(m)) {
      functionString = "" + m;
      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
    } else if (m && !isString(m)) {
      if (isNonNegativeInt(m.length)) {
        return inspectedObjectLiteral("{" + m.constructor.name + " length: " + m.length + "}");
      } else if (isNonNegativeInt(m.byteLength)) {
        return inspectedObjectLiteral("{" + m.constructor.name + " byteLength: " + m.byteLength + "}");
      } else {
        return m;
      }
    } else {
      return m;
    }
  };

  return InspectedObjects;

})();


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var Inspector, Map, escapeJavascriptString, isArray, isBrowserObject, isClass, isFunction, isObject, isPlainArray, isPlainObject, isString, objectName, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Map = __webpack_require__(46);

escapeJavascriptString = __webpack_require__(16).escapeJavascriptString;

ref = __webpack_require__(4), objectName = ref.objectName, isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isClass = ref.isClass, isBrowserObject = ref.isBrowserObject, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray;

module.exports = Inspector = (function() {
  var inspect;

  Inspector.unquotablePropertyRegex = /^([0-9]+|[_a-zA-Z][_0-9a-zA-Z]*)$/;

  Inspector.customInspectable = function(obj) {
    return obj.inspect && !(typeof obj === "function");
  };

  Inspector.parentString = function(distance) {
    switch (distance) {
      case 0:
        return "parent";
      case 1:
        return "grandparent";
      case 2:
        return "great grandparent";
      default:
        return "great^" + (distance - 1) + " grandparent";
    }
  };

  function Inspector(options) {
    if (options == null) {
      options = {};
    }
    this.inspect = bind(this.inspect, this);
    this.inspectInternal = bind(this.inspectInternal, this);
    this.inspectObject = bind(this.inspectObject, this);
    this.inspectArray = bind(this.inspectArray, this);
    this.maxLength = options.maxLength || 10000;
    this.allowCustomInspectors = !options.noCustomInspectors;
    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
    this.outArray = [];
    this.length = 0;
    this.depth = 0;
    this.inspectingMap = new Map;
    this.done = false;
  }

  Inspector.inspect = inspect = function(obj, options) {
    var inspector;
    if (options == null) {
      options = {};
    }
    if (this !== global) {
      return Neptune.Base.inspect.call(this);
    }
    inspector = new Inspector(options);
    inspector.inspect(obj);
    return inspector.getResult();
  };

  Inspector.shallowInspect = function(obj) {
    if (obj == null) {
      return "" + obj;
    } else if (Inspector.customInspectable(obj)) {
      return Inspector.inspect(obj);
    } else if (isString(obj)) {
      return escapeJavascriptString(obj);
    } else if (isArray(obj)) {
      return "<<Array length: " + obj.length + ">>";
    } else if (isFunction(obj) && obj.name === "") {
      return "<<function args: " + obj.length + ">>";
    } else {
      return "<<" + (typeof obj) + ": " + (obj.name || obj) + ">>";
    }
  };

  Inspector.inspectLean = function(object, options) {
    var fullInspect, match;
    fullInspect = inspect(object, options);
    if (!isFunction(object != null ? object.inspect : void 0) && (isPlainObject(object) || (isPlainArray(object) && (object.length > 1 || (options != null ? options.forArgs : void 0))))) {
      match = fullInspect.match(/^\[(.+)\]$|^\{(.+)\}$/);
      if (match) {
        return match[1] || match[2] || match[3];
      } else {
        return fullInspect;
      }
    } else {
      return fullInspect;
    }
  };

  Inspector.prototype.put = function(s) {
    var remaining;
    if (this.done) {
      return;
    }
    if (this.length + s.length > this.maxLength) {
      this.done = true;
      remaining = this.maxLength - this.length;
      s = (s.slice(0, remaining)) + "<... first " + remaining + "/" + s.length + ">";
    }
    this.length += s.length;
    this.outArray.push(s);
    return s;
  };

  Inspector.prototype.getResult = function() {
    return this.outArray.join("");
  };

  Inspector.prototype.maxDepthOutput = function(obj) {
    var keys, name;
    switch (typeof obj) {
      case "string":
      case "number":
      case "boolean":
      case "undefined":
        return this.inspectInternal(obj);
      case "function":
        return this.put(objectName(obj));
      case "object":
        return this.put(obj === null ? "null" : isArray(obj) ? "[" + obj.length + " elements]" : (keys = Object.keys(obj), name = objectName(obj), name === "Object" ? "{" + keys.length + " keys}" : keys.length > 0 ? "{" + name + " " + keys.length + " keys}" : name));
    }
  };

  Inspector.prototype.inspectArray = function(array) {
    var first, i, len, obj;
    this.put("[");
    first = true;
    for (i = 0, len = array.length; i < len; i++) {
      obj = array[i];
      if (!first) {
        this.put(", ");
      }
      this.inspect(obj);
      first = false;
    }
    return this.put("]");
  };

  Inspector.prototype.inspectObject = function(obj) {
    var attributes, first, i, k, keys, len, name, v;
    attributes = [];
    keys = Object.keys(obj);
    name = objectName(obj);
    if (isFunction(obj) && keys.length === 0) {
      return this.put(name + "()");
    } else if (isBrowserObject(obj)) {
      return this.put("{" + name + "}");
    } else {
      this.put("{");
      if (obj.constructor !== Object) {
        this.put(name + " ");
      }
      first = true;
      for (i = 0, len = keys.length; i < len; i++) {
        k = keys[i];
        if (!(k !== "__uniqueId")) {
          continue;
        }
        if (!first) {
          this.put(", ");
        }
        v = obj[k];
        if (Inspector.unquotablePropertyRegex.test(k)) {
          this.put(k);
        } else {
          this.inspect(k);
        }
        this.put(": ");
        this.inspect(v);
        first = false;
      }
      return this.put("}");
    }
  };

  Inspector.prototype.inspectInternal = function(obj) {
    if (obj == null) {
      return this.put("" + obj);
    } else if (isString(obj)) {
      return this.put(escapeJavascriptString(obj));
    } else if (isArray(obj)) {
      return this.inspectArray(obj);
    } else if (isClass(obj)) {
      return this.put(objectName(obj));
    } else if (this.allowCustomInspectors && Inspector.customInspectable(obj)) {
      if (obj.inspect.length > 0) {
        return obj.inspect(this);
      } else {
        return this.put(obj.inspect());
      }
    } else if (obj instanceof RegExp) {
      return this.put("" + obj);
    } else if (isObject(obj) || isFunction(obj)) {
      return this.inspectObject(obj);
    } else if (isFunction(obj != null ? obj.toString : void 0)) {
      return this.put(obj.toString());
    } else {
      return this.put("" + obj);
    }
  };

  Inspector.prototype.inspect = function(obj) {
    var objDepth;
    if (this.done) {
      return;
    }
    if (objDepth = this.inspectingMap.get(obj)) {
      this.put("<" + (Inspector.parentString(this.depth - objDepth)) + ">");
      return null;
    }
    if (this.depth >= this.maxDepth) {
      this.maxDepthOutput(obj);
    } else {
      this.depth++;
      this.inspectingMap.set(obj, this.depth);
      this.inspectInternal(obj);
      this.inspectingMap["delete"](obj);
      this.depth--;
    }
    return null;
  };

  return Inspector;

})();


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var Iteration, compactFlatten, deepArrayEach, isArrayOrArguments, isFunction, isObject, isPlainArray, isPlainObject, log, mergeInto, ref, ref1;

ref = __webpack_require__(7), compactFlatten = ref.compactFlatten, deepArrayEach = ref.deepArrayEach, isArrayOrArguments = ref.isArrayOrArguments, mergeInto = ref.mergeInto;

ref1 = __webpack_require__(4), isPlainObject = ref1.isPlainObject, isObject = ref1.isObject, isFunction = ref1.isFunction, isPlainArray = ref1.isPlainArray;

log = function() {
  var ref2;
  return (ref2 = Neptune.Art.StandardLib).log.apply(ref2, arguments);
};

module.exports = Iteration = (function() {
  var arrayIterableTest, emptyOptions, invokeNormalizedIteration, normalizedArray, normalizedEach, normalizedEachWhile, normalizedFind, normalizedInject, normalizedObject, returnFirst, returnSecond;

  function Iteration() {}

  returnFirst = function(a) {
    return a;
  };

  returnSecond = function(a, b) {
    return b;
  };

  arrayIterableTest = function(source) {
    return (source != null ? source.length : void 0) >= 0;
  };

  emptyOptions = {};


  /*
  COMMON API:
  
  IN: (source, withBlock = returnFirst) ->
  IN: (source, options) ->
  IN: (source, into, withBlock = returnFirst) ->
  IN: (source, into, options) ->
  
  source:
    array-like (see arrayIterableTest)
      use indexes to iterate
  
    non-null
  
  options:
    with: withBlock
    when: whenBlock
    into: into
  
  withBlock: (value, key, into, whenBlockResult) -> value
    Generally, this generates the 'value' used for each part of the iteration.
    When constructing a new collection, this is the value for each entry.
    'find' and 'reduce' use this differently.
  
  OUT: into
  
  TODO:
    - support ES6 iterables and iterators
    - flatten: true - if source is an array, recurse into any sub-arrays
    - compact: effectively `when: (v) -> v?` except you can also have your own when-function in addition, run after this one.
    - skip: N - skip the first N values
    - short: N - stop short N values
    - until: () -> T/F - same args as withBlock, loop stops when true, executed after first withBlock
    - while: () -> T/F - same args as withBlock, loop stops when false, executed before first whenBlock
    - by: N -
        N>0: only stop at every Nth value
        N<0: iterate in reverse order, only stop at every abs(N)th value
   */


  /*
  each differences from the common-api:
  
  1) into defaults to source
   */

  Iteration.each = function(source, a, b) {
    return invokeNormalizedIteration(normalizedEach, source, a, b);
  };

  normalizedEach = function(source, into, withBlock, options) {
    var i, j, k, len, len1, v, w, whenBlock;
    if (into === void 0) {
      into = source;
    }
    if (options) {
      whenBlock = options.when;
    }
    if (arrayIterableTest(source)) {
      if (whenBlock) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            withBlock(v, k, into, w);
          }
        }
      } else {
        for (k = j = 0, len1 = source.length; j < len1; k = ++j) {
          v = source[k];
          withBlock(v, k, into);
        }
      }
    } else if (source != null) {
      if (whenBlock) {
        for (k in source) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            withBlock(v, k, into, w);
          }
        }
      } else {
        for (k in source) {
          v = source[k];
          withBlock(v, k, into);
        }
      }
    }
    return into;
  };


  /*
  eachWhile differences from the common-api:
  
  1) into defaults to source
  2) stops when withBlock returns false
   */

  Iteration.eachWhile = function(source, a, b) {
    return invokeNormalizedIteration(normalizedEachWhile, source, a, b);
  };

  normalizedEachWhile = function(source, into, withBlock, options) {
    var i, j, k, len, len1, v, w, whenBlock;
    if (into === void 0) {
      into = source;
    }
    if (options) {
      whenBlock = options.when;
    }
    if (arrayIterableTest(source)) {
      if (whenBlock) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            if (!withBlock(v, k, into, w)) {
              break;
            }
          }
        }
      } else {
        for (k = j = 0, len1 = source.length; j < len1; k = ++j) {
          v = source[k];
          if (!withBlock(v, k, into)) {
            break;
          }
        }
      }
    } else if (source != null) {
      if (whenBlock) {
        for (k in source) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            if (!withBlock(v, k, into, w)) {
              break;
            }
          }
        }
      } else {
        for (k in source) {
          v = source[k];
          if (!withBlock(v, k, into)) {
            break;
          }
        }
      }
    }
    return into;
  };


  /*
  reduce differences from the common-api:
  
  1) The with-block has a different argument order. Into is passed first instead of last:
    with: (into, value, key, whenReturnValue) ->
    This allows you to drop-in functions that take two arguments and reduce them to one like:
      Math.max
      add = (a, b) -> a + b
  
    The default with-block still returns value (which is now the second argument).
  
  1) if into starts out undefined:
    for v = the first value (if whenBlock is present, the first value when whenBlock is true)
      into = v
      skip: withBlock
  
  2) when withBlock is executed, into is updated:
    into = withBlock()
   */

  Iteration.reduce = function(source, a, b) {
    return invokeNormalizedIteration(normalizedInject, source, a, b);
  };

  normalizedInject = function(source, into, withBlock, options) {
    var intoSet;
    if (source == null) {
      return into;
    }
    normalizedEach(source, void 0, (intoSet = into !== void 0) ? function(v, k, __, w) {
      return into = withBlock(into, v, k, w);
    } : function(v, k, __, w) {
      return into = intoSet ? withBlock(into, v, k, w) : (intoSet = true, v);
    }, options);
    return into;
  };


  /*
  object differences from the common-api:
  
  IN:
    options.key: (value, key, into, whenBlockResult) -> value
  
  1) into defaults to a new object ({}) (if into == undefined)
  
  2) when withBlock is executed, into is updated:
    if source is array-like:
      into[v] = withBlock()
    else
      into[k] = withBlock()
   */

  Iteration.object = function(source, a, b) {
    return invokeNormalizedIteration(normalizedObject, source, a, b);
  };

  normalizedObject = function(source, into, withBlock, options) {
    var keyFunction;
    keyFunction = options.key || (arrayIterableTest(source) ? returnFirst : returnSecond);
    return normalizedEach(source, into != null ? into : {}, function(v, k, into, w) {
      return into[keyFunction(v, k, into, w)] = withBlock(v, k, into, w);
    }, options);
  };


  /*
  array differences from the common-api:
  
  1) into defaults to a new array ([]) (if into == undefined)
  
  2) when withBlock is executed, into is updated:
    into.push withBlock()
   */

  Iteration.array = function(source, a, b) {
    return invokeNormalizedIteration(normalizedArray, source, a, b);
  };

  normalizedArray = function(source, into, withBlock, options) {
    return normalizedEach(source, into != null ? into : [], function(v, k, into, w) {
      return into.push(withBlock(v, k, into, w));
    }, options);
  };


  /*
  differs from common api:
  
  1) returns the last value returned by withBlock or undefined if withBlock was never executed
  2) stops if
    a) whenBlock?:  and it returned true (stops after withBlock is evaluated)
    b) !whenBlock?: withBlock returns a truish value
   */

  Iteration.find = function(source, a, b) {
    return invokeNormalizedIteration(normalizedFind, source, a, b);
  };

  normalizedFind = function(source, into, withBlock, options) {
    var found;
    normalizedEachWhile(source, found = void 0, options.whenBlock ? function(v, k, into, w) {
      found = withBlock(v, k, null, w);
      return false;
    } : function(v, k, into, w) {
      return !(found = withBlock(v, k, null, w));
    }, options);
    return found;
  };


  /*
  Normalizes input params for the 'iteration' function.
  Since this normalizes multile params, and therefor would need to return
  an new array or new object otherwise, we pass IN the iteration function
  and pass the params directly to it. This keeps the computed params on the
  stack and doesn't create new objects.
  
  IN signature 1: (iteration, source, into, withBlock) ->
  IN signature 2: (iteration, source, into, options) ->
  IN signature 3: (iteration, source, withBlock) ->
  IN signature 4: (iteration, source, options) ->
  IN signature 5: (iteration, source) ->
  
  IN:
    iteration: (source, into, withBlock, options) -> out
  
      The iteration function is invoked last with the computed args.
      Its retults are returned.
  
      IN:
        source:     passed directly through from inputs
        into:       passed directly through from inputs OR from options.into
        withBlock:  passed directly through from inputs OR from options.with
        options:    passed direftly through from inputs OR {}
                    (guaranteed to be set and a plainObject)
  
    source: the source collection to be iterated over. Passed streight through.
  
    into:       passed through to 'iteration'
    withBlock:  passed through to 'iteration'
    options:    passed through to 'iteration' AND:
  
      into:     set 'into' from the options object
      with:     set 'withBlock' from the options object
  
  OUT: out
   */

  invokeNormalizedIteration = function(iteration, source, a, b) {
    var into, options, withBlock;
    options = b ? (into = a, b) : a;
    if (isPlainObject(options)) {
      if (into == null) {
        into = options.into;
      }
      withBlock = options["with"];
    } else {
      if (isFunction(options)) {
        withBlock = options;
      }
      options = emptyOptions;
    }
    return iteration(source, into, withBlock || returnFirst, options);
  };

  return Iteration;

})();


/***/ }),
/* 71 */
/***/ (function(module, exports) {

var Unique, nextId;

nextId = 1;

module.exports = Unique = (function() {
  var nextUniqueObjectId, objectId;

  function Unique() {}

  Unique.nextUniqueObjectId = nextUniqueObjectId = function() {
    return "object_" + nextId++;
  };

  Unique.objectId = objectId = function(o) {
    if (o.hasOwnProperty("__uniqueId")) {
      return o.__uniqueId || (o.__uniqueId = nextUniqueObjectId());
    } else {
      Object.defineProperty(o, "__uniqueId", {
        enumerable: false,
        value: nextUniqueObjectId()
      });
      return o.__uniqueId;
    }
  };

  Unique.id = function(key) {
    if (typeof key === "object" || typeof key === "function") {
      if (key) {
        if (typeof key.getUniqueId === "function") {
          return key.getUniqueId();
        } else {
          return objectId(key);
        }
      } else {
        return "null";
      }
    } else if (typeof key === "number") {
      return "" + key;
    } else if (typeof key === "symbol") {
      return key.toString();
    } else if (typeof key === "string") {
      return "string_" + key;
    } else if (typeof key === "boolean") {
      if (key) {
        return "true";
      } else {
        return "false";
      }
    } else if (key === void 0) {
      return "undefined";
    } else {
      return (typeof key) + "_" + key;
    }
  };

  return Unique;

})();


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var StandardLib,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.StandardLib', StandardLib = (function(superClass) {
  extend(StandardLib, superClass);

  function StandardLib() {
    return StandardLib.__super__.constructor.apply(this, arguments);
  }

  StandardLib.version = __webpack_require__(296).version;

  return StandardLib;

})(Neptune.PackageNamespace));

__webpack_require__(140);

__webpack_require__(45);


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let ArtEryHandler,
    pipelines,
    verifySession,
    Promise,
    Request,
    log,
    signSession,
    config;
  ({
    pipelines,
    verifySession,
    Promise,
    Request,
    log,
    signSession,
    config
  } = Caf.import(
    [
      "pipelines",
      "verifySession",
      "Promise",
      "Request",
      "log",
      "signSession",
      "config"
    ],
    [global, __webpack_require__(18), __webpack_require__(75)]
  ));
  return (ArtEryHandler = Caf.defClass(
    class ArtEryHandler extends __webpack_require__(49).PromiseHandler {},
    function(ArtEryHandler, classSuper, instanceSuper) {
      let httpMethodsToArtEryRequestTypes;
      this.prototype.canHandleRequest = function(request) {
        let url;
        ({ url } = request);
        return Caf.extendedEach(
          pipelines,
          undefined,
          (pipeline, pipelineName, into, brk) => {
            return pipeline.restPathRegex.test(url) && (brk(), pipeline);
          }
        );
      };
      this.prototype.handleApiRequest = function(request, requestData) {
        let found, pipeline, type, key;
        return (found = this._findPipelineForRequest(request))
          ? (({ pipeline, type, key } = found),
            verifySession(requestData.session)
              .catch(() => {
                return null;
              })
              .then(session => {
                return pipeline
                  ._processRequest(
                    Request.createFromRemoteRequestProps({
                      session: session || {},
                      pipeline,
                      type,
                      key,
                      requestData
                    })
                  )
                  .then(response => {
                    if (response.failed) {
                      log.error(response);
                    }
                    return signSession(
                      session,
                      response.responseForRemoteRequest
                    );
                  });
              }))
          : Promise.resolve(null);
      };
      httpMethodsToArtEryRequestTypes = {
        get: "get",
        post: "create",
        put: "update",
        delete: "delete"
      };
      this.prototype._findPipelineForRequest = function(request) {
        let url, method, found, match, pipeline, __, type, key;
        ({ url, method } = request);
        return (found = Caf.extendedEach(
          pipelines,
          undefined,
          (pipeline, pipelineName, into, brk) => {
            let cafRet;
            return (
              (cafRet = (match = url.match(pipeline.restPathRegex))
                ? { match, pipeline }
                : undefined) && (brk(), cafRet)
            );
          }
        ))
          ? (({ match, pipeline } = found),
            ([__, type, key] = match),
            type ||
              (type =
                httpMethodsToArtEryRequestTypes[method.toLocaleLowerCase()]),
            config.verbose && type && !pipeline.publicRequestTypes[type]
              ? log.warn(
                  `ArtEryHandler blocked request: '${Caf.toString(
                    pipeline.name
                  )}.${Caf.toString(type)}': ${Caf.toString(
                    Caf.in(type, pipeline.requestTypes)
                      ? "not in publicRequestTypes"
                      : "not a valid request-type"
                  )}`
                )
              : undefined,
            pipeline.publicRequestTypes[type] && { pipeline, type, key })
          : undefined;
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let ArtEryInfoHandler, config, pipelines, objectKeyCount;
  ({ config, pipelines, objectKeyCount } = Caf.import(
    ["config", "pipelines", "objectKeyCount"],
    [global, __webpack_require__(18)]
  ));
  return (ArtEryInfoHandler = Caf.defClass(
    class ArtEryInfoHandler extends __webpack_require__(49)
      .PromiseHandler {},
    function(ArtEryInfoHandler, classSuper, instanceSuper) {
      this.getter({
        handleUrlRegex: function() {
          return (
            this._exactDefaultHandlerRegex ||
            (this._exactDefaultHandlerRegex = RegExp(
              `^\\/${Caf.toString(config.apiRoot)}\\/?\$`
            ))
          );
        }
      });
      this.prototype.handleApiRequest = function(request, requestData) {
        let reports;
        reports = Caf.each(pipelines, {}, (pipeline, k, into) => {
          into[k] = pipeline.getApiReport({ publicOnly: true });
        });
        return {
          "Art.Ery.Api": Caf.each(reports, {}, (report, k, into) => {
            if (0 < objectKeyCount(report)) {
              into[k] = report;
            }
          })
        };
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let PromiseJsonWebToken,
    ArtErySessionManager,
    Promise,
    config,
    objectWithout,
    merge,
    Date,
    eq;
  ({ Promise, config, objectWithout, merge, Date, eq } = Caf.import(
    ["Promise", "config", "objectWithout", "merge", "Date", "eq"],
    [global, __webpack_require__(18)]
  ));
  PromiseJsonWebToken = __webpack_require__(76);
  return (ArtErySessionManager = Caf.defClass(
    class ArtErySessionManager extends Object {},
    function(ArtErySessionManager, classSuper, instanceSuper) {
      let iatAgeInDays;
      this.verifySession = function(session) {
        let sessionSignature;
        return !(sessionSignature = session)
          ? Promise.resolve({})
          : PromiseJsonWebToken.verify(
              sessionSignature,
              config.server.privateSessionKey
            ).then(session => {
              return session;
            });
      };
      this.signSession = (oldSession, responseData) => {
        let newSession;
        return this._shouldReturnNewSignedSession(
          oldSession,
          (newSession = responseData.session || oldSession)
        )
          ? PromiseJsonWebToken.sign(
              objectWithout(newSession, "exp", "iat"),
              config.server.privateSessionKey,
              { expiresIn: "30 days" }
            ).then(signature => {
              return merge(responseData, {
                session: merge(newSession, { signature })
              });
            })
          : objectWithout(responseData, "session");
      };
      this.iatAgeInDays = iatAgeInDays = function(iat) {
        return (Date.now() / 1000 - iat) / (60 * 60 * 24);
      };
      this._shouldReturnNewSignedSession = function(oldSession, newSession) {
        let iat;
        if (oldSession) {
          ({ iat } = oldSession);
        }
        return !iat || 1 < iatAgeInDays(iat) || !eq(oldSession, newSession);
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let jsonwebtoken, PromiseJsonWebToken, Promise;
  ({ Promise } = Caf.import(
    ["Promise"],
    [global, __webpack_require__(18)]
  ));
  jsonwebtoken = __webpack_require__(303);
  return (PromiseJsonWebToken = Caf.defClass(
    class PromiseJsonWebToken extends Object {},
    function(PromiseJsonWebToken, classSuper, instanceSuper) {
      this.sign = function(payload, secretOrPrivateKey, options) {
        return Promise.withCallback(callback => {
          return jsonwebtoken.sign(
            payload,
            secretOrPrivateKey,
            options,
            callback
          );
        });
      };
      this.verify = function(token, secretOrPrivateKey, options) {
        return Promise.withCallback(callback => {
          return jsonwebtoken.verify(
            token,
            secretOrPrivateKey,
            options,
            callback
          );
        });
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let querystring,
    PromiseHandler,
    Promise,
    serverFailure,
    Error,
    formattedInspect,
    encodeHttpStatus,
    JSON,
    isString,
    findUrlRegexp,
    merge,
    missing,
    isPlainObject;
  ({
    Promise,
    serverFailure,
    Error,
    formattedInspect,
    encodeHttpStatus,
    JSON,
    isString,
    findUrlRegexp,
    merge,
    missing,
    isPlainObject
  } = Caf.import(
    [
      "Promise",
      "serverFailure",
      "Error",
      "formattedInspect",
      "encodeHttpStatus",
      "JSON",
      "isString",
      "findUrlRegexp",
      "merge",
      "missing",
      "isPlainObject"
    ],
    [global, __webpack_require__(0), __webpack_require__(8)]
  ));
  querystring = __webpack_require__(169);
  return (PromiseHandler = Caf.defClass(
    class PromiseHandler extends __webpack_require__(51)(
      __webpack_require__(3).BaseClass
    ) {
      constructor(options = {}) {
        super(...arguments);
        this.options = options;
        this.logVerbose("initialized");
        this._commonResponseHeaders = this.options.commonResponseHeaders;
      }
    },
    function(PromiseHandler, classSuper, instanceSuper) {
      this.getMiddleware = function(options) {
        return new this(options).middleware;
      };
      this.getter({
        handleUrlRegex: function() {
          return null;
        }
      });
      this.prototype.canHandleRequest = function(request) {
        let cafBase;
        return (
          Caf.exists((cafBase = this.handleUrlRegex)) &&
          cafBase.test(request.url)
        );
      };
      this.prototype.handleApiRequest = null;
      this.prototype.handleHtmlRequest = null;
      this.prototype.handleRequest = function(request, requestData) {
        return Promise.then(() => {
          return (() => {
            switch (false) {
              case !this.handleApiRequest:
                return this._handleApiRequestWrapper(request, requestData);
              case !this.handleHtmlRequest:
                return this._handleHtmlRequestWrapper(request, requestData);
              default:
                return null;
            }
          })();
        });
      };
      this.getter({
        middleware: function() {
          return (request, response, next) => {
            let dataChunks, requestData;
            return this.canHandleRequest(request)
              ? (this.logVerbose({
                  start: { method: request.method, url: request.url }
                }),
                (dataChunks = []),
                (requestData = null),
                request.on("data", chunk => {
                  return dataChunks.push(chunk);
                }),
                request.on("end", () => {
                  return Promise.then(() => {
                    return this.handleRequest(
                      request,
                      (requestData = dataChunks.join(""))
                    );
                  })
                    .catch(error => {
                      this.logError({ internalError: { request, error } });
                      return { status: serverFailure };
                    })
                    .then(plainResponse => {
                      let headers, data, status, statusCode, responseData;
                      if (plainResponse) {
                        ({ headers, data, status, statusCode } = plainResponse);
                        if (
                          !(
                            data != null ||
                            status != null ||
                            statusCode != null
                          )
                        ) {
                          throw new Error(
                            `expected data, status or statusCode in response: ${Caf.toString(
                              formattedInspect(plainResponse)
                            )}`
                          );
                        }
                      }
                      responseData = data;
                      response.statusCode =
                        statusCode ||
                        (status && (statusCode = encodeHttpStatus(status))
                          ? statusCode
                          : (statusCode = data ? 200 : 404));
                      if (((statusCode / 100) | 0) === 5) {
                        this.logError({
                          url: request.url,
                          requestData:
                            (() => {
                              try {
                                return JSON.parse(requestData);
                              } catch (cafError) {}
                            })() || requestData,
                          responseData:
                            (() => {
                              try {
                                return JSON.parse(responseData);
                              } catch (cafError) {}
                            })() || responseData
                        });
                      }
                      return this._encodeOutput(
                        request,
                        response,
                        headers,
                        responseData
                      );
                    });
                }))
              : next();
          };
        }
      });
      this.prototype._encodeJson = function(responseHeaders, responseData) {
        responseHeaders["Content-Type"] = "application/json; charset=UTF-8";
        return JSON.stringify(responseData);
      };
      this.prototype._encodeHtml = function(responseHeaders, responseData) {
        responseHeaders["Content-Type"] = "text/html; charset=UTF-8";
        return isString(responseData)
          ? responseData
          : `<html><body style='font-family:Monaco,courier;font-size:10pt'>\n${Caf.toString(
              formattedInspect(responseData)
                .replace(/\n/g, "<br>\n")
                .replace(/\ /g, "&nbsp;")
                .replace(
                  RegExp(`(${Caf.toString(findUrlRegexp.source)})`, "g"),
                  "<a href='$1'>$1</a>"
                )
            )}\n</body></html>`;
      };
      this.prototype._encodePlain = function(responseHeaders, responseData) {
        responseHeaders["Content-Type"] = "text/plain; charset=UTF-8";
        return isString(responseData)
          ? responseData
          : formattedInspect(responseData);
      };
      this.prototype._encodeOutput = function(
        request,
        response,
        responseHeaders = {},
        responseData
      ) {
        let accept, encodedData, headers;
        ({ accept = "text/html" } = request.headers);
        encodedData =
          responseData &&
          (() => {
            switch (false) {
              case !/json/.test(accept):
                return this._encodeJson(responseHeaders, responseData);
              case !/html/.test(accept):
                return this._encodeHtml(responseHeaders, responseData);
              default:
                return this._encodePlain(responseHeaders, responseData);
            }
          })();
        Caf.each(
          (headers = merge(this._commonResponseHeaders, responseHeaders)),
          undefined,
          (v, k, into) => {
            response.setHeader(k, v);
          }
        );
        this.logVerbose({
          done: {
            method: request.method,
            url: request.url,
            accept,
            responseData,
            headers,
            encodedData
          }
        });
        return response.end(encodedData);
      };
      this.prototype._handleHtmlRequestWrapper = function(
        request,
        requestData
      ) {
        return Promise.then(() => {
          return this.handleHtmlRequest(request, requestData);
        }).then(data => {
          return (() => {
            switch (false) {
              case !!(data != null):
                return { status: missing };
              case !isPlainObject(data):
                return data;
              case !(
                isString(data) ||
                (data = Caf.isF(data.toString) && data.toString())
              ):
                return { data };
              default:
                return (() => {
                  throw new Error(
                    "ArtExpressServer.PromiseHandler#_handleHtmlRequestWrapper - expected string, plainObject, object with toString() or null response"
                  );
                })();
            }
          })();
        });
      };
      this.prototype._handleApiRequestWrapper = function(request, requestData) {
        return Promise.then(() => {
          return JSON.parse(requestData || "{}");
        })
          .catch(() => {
            return (() => {
              throw new Error(
                `requested data was not valid JSON: ${Caf.toString(
                  requestData
                )}`
              );
            })();
          })
          .then(parsedData => {
            let url, __, query;
            ({ url } = request);
            [__, query] = url.split("?");
            return merge(
              parsedData,
              query &&
                Caf.each(querystring.parse(query), {}, (v, k, into) => {
                  let cafError;
                  into[k] = (() => {
                    try {
                      return JSON.parse(v);
                    } catch (cafError) {
                      return v;
                    }
                  })();
                })
            );
          })
          .then(parsedData => {
            return this.handleApiRequest(request, parsedData);
          })
          .then(data => {
            return data ? { data } : { status: missing };
          });
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let Server, merge, process, Neptune, fastBind, compactFlatten;
  ({ merge, process, Neptune, fastBind, compactFlatten } = Caf.import(
    ["merge", "process", "Neptune", "fastBind", "compactFlatten"],
    [global, __webpack_require__(0), __webpack_require__(8)]
  ));
  __webpack_require__(301);
  return (Server = Caf.defClass(
    class Server extends __webpack_require__(51)(
      __webpack_require__(3).BaseClass
    ) {},
    function(Server, classSuper, instanceSuper) {
      this.defaults = { port: 8085, server: "http://localhost" };
      this.start = function(...manyOptions) {
        return new Server().start(...manyOptions);
      };
      this.prototype.start = function(...manyOptions) {
        let numWorkers;
        ({ numWorkers } = this.options = this._allowAllCors(
          merge(
            Server.defaults,
            {
              numWorkers: process.env.WEB_CONCURRENCY || 1,
              port: process.env.PORT
            },
            ...manyOptions
          )
        ));
        this.logVerbose({
          start: {
            options: this.options,
            env: merge(
              Caf.each(process.env, {}, (v, k, into) => {
                if (k.match(/^art/)) {
                  into[k] = v;
                }
              }),
              {},
              process.env.WEB_CONCURRENCY,
              process.env.WEB_MEMORY,
              process.env.MEMORY_AVAILABLE,
              process.env.PORT
            ),
            Neptune: Neptune.getVersions()
          }
        });
        if (numWorkers != null) {
          numWorkers = numWorkers | 0;
        }
        return numWorkers > 1
          ? (this.log({ start: { throng: { workers: numWorkers } } }),
            __webpack_require__(306)(numWorkers, fastBind(this._startOneServer, this)))
          : this._startOneServer();
      };
      this.prototype._allowAllCors = function(options) {
        return options.allowAllCors
          ? merge(options, {
              commonResponseHeaders: merge(
                __webpack_require__(50).commonResponseHeaders,
                options.commonResponseHeaders
              ),
              handlers: compactFlatten([
                __webpack_require__(50),
                options.handlers
              ])
            })
          : options;
      };
      this.prototype._startOneServer = function(workerId) {
        let port,
          handlers,
          middleware,
          commonResponseHeaders,
          staticOptions,
          app;
        this.workerId = workerId;
        ({ port, handlers, middleware, commonResponseHeaders } = this.options);
        staticOptions = this.options.static;
        app = __webpack_require__(168)();
        app.use(__webpack_require__(302)());
        Caf.each(compactFlatten([middleware]), undefined, (mw, k, into) => {
          app.use(mw);
        });
        Caf.each(compactFlatten([handlers]), undefined, (handler, k, into) => {
          app.use(handler.getMiddleware(this.options));
        });
        if (staticOptions) {
          app.use(
            __webpack_require__(168).static(
              staticOptions.root,
              merge(
                {
                  maxAge: 3600 * 24 * 7,
                  setHeaders: (response, path) => {
                    switch (__webpack_require__(304)
                      .extname(path)
                      .toLowerCase()) {
                      case ".js":
                        response.setHeader(
                          "Content-Type",
                          "application/javascript; charset=UTF-8"
                        );
                    }
                    return Caf.each(
                      merge(commonResponseHeaders, staticOptions.headers),
                      undefined,
                      (v, k, into) => {
                        response.setHeader(k, v);
                      }
                    );
                  }
                },
                staticOptions
              )
            )
          );
        }
        return app.listen(port | 0, () => {
          return this.log(
            `listening on: http://localhost:${Caf.toString(port)}`
          );
        });
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(183);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var AtomicBase, Color, Foundation, abs, bound, colorFloatEq, float32Eq, float32Eq0, hex16ColorRegex, hex256ColorRegex, inspect, isString, log, max, min, modulo, pad, parseRGBColorComponent, rgbColorRegex, rgbaColorRegex,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(19);

inspect = Foundation.inspect, bound = Foundation.bound, modulo = Foundation.modulo, pad = Foundation.pad, min = Foundation.min, max = Foundation.max, abs = Foundation.abs, float32Eq = Foundation.float32Eq, isString = Foundation.isString, log = Foundation.log, hex16ColorRegex = Foundation.hex16ColorRegex, hex256ColorRegex = Foundation.hex256ColorRegex, rgbColorRegex = Foundation.rgbColorRegex, rgbaColorRegex = Foundation.rgbaColorRegex, float32Eq0 = Foundation.float32Eq0;

colorFloatEq = float32Eq;

parseRGBColorComponent = function(str) {
  var percentIndex;
  if ((percentIndex = str.indexOf('%')) !== -1) {
    return (str.slice(0, percentIndex) | 0) * .01;
  } else {
    return (str | 0) * 1 / 255;
  }
};

module.exports = Color = (function(superClass) {
  var colorNames, colorNamesMap, defaultAlpha, hexString, hslColor, k, parseCache, rgbColor, v, withSat, zeroString;

  extend(Color, superClass);

  function Color() {
    return Color.__super__.constructor.apply(this, arguments);
  }

  Color.defineAtomicClass({
    fieldNames: "r g b a",
    constructorFunctionName: "rgbColor"
  });

  Color.isColor = function(c) {
    return (c != null ? c.constructor : void 0) === Color;
  };

  Color.colorNames = colorNames = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];

  Color.colorNamesMap = colorNamesMap = {
    transparent: "rgba(0,0,0,0)",
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgrey: "#a9a9a9",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategrey: "#2f4f4f",
    darkslategray: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgrey: "#696969",
    dimgray: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    grey: "#808080",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgrey: "#d3d3d3",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategrey: "#778899",
    lightslategray: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategrey: "#708090",
    slategray: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };

  Color.parseCache = parseCache = {};

  defaultAlpha = 1;

  Color.rgbColor = rgbColor = function(a, b, c, d) {
    var clr;
    if ((b == null) && (a instanceof Color)) {
      return a;
    }
    if (isString(a) && (clr = colorNamesMap[a] || parseCache[a])) {
      return clr;
    }
    return new Color(a, b, c, d);
  };

  Color.rgb256Color = function(a, b, c, d) {
    var clr, out;
    if ((b == null) && (a instanceof Color)) {
      return a;
    }
    if (isString(a) && (clr = colorNamesMap[a] || parseCache[a])) {
      return clr;
    }
    defaultAlpha = 255;
    out = new Color(a, b, c, d);
    defaultAlpha = 1;
    out.r /= 255;
    out.g /= 255;
    out.b /= 255;
    out.a /= 255;
    return out;
  };

  Color.newColor = rgbColor;

  Color.color = function(a, b, c, d) {
    log.error("Atomic.color DEPRICATED. Use rgbColor.");
    return rgbColor(a, b, c, d);
  };

  Color.hslColor = hslColor = function(h, s, l, a) {
    var f, p, phase, q, t;
    if (a == null) {
      a = 1;
    }
    if (h instanceof Color) {
      return h;
    }
    h = modulo(h, 1);
    phase = h * 6 | 0;
    f = h * 6 - phase;
    p = l * (1 - s);
    q = l * (1 - f * s);
    t = l * (1 - (1 - f) * s);
    h = colorFloatEq(h, 1) ? 1 : h % 1;
    switch (phase % 6) {
      case 0:
        return new Color(l, t, p, a, h, s, l);
      case 1:
        return new Color(q, l, p, a, h, s, l);
      case 2:
        return new Color(p, l, t, a, h, s, l);
      case 3:
        return new Color(p, q, l, a, h, s, l);
      case 4:
        return new Color(t, p, l, a, h, s, l);
      case 5:
        return new Color(l, p, q, a, h, s, l);
    }
  };

  Color.parse = function(string, existing) {
    if (existing == null) {
      existing = null;
    }
    if (existing) {
      throw new Error("existing feature is no longer supported");
    }
    return new Artomic.Color(string);
  };

  Color.prototype._initFromObject = function(obj) {
    return this.r = obj.r, this.g = obj.g, this.b = obj.b, this.a = obj.a, obj;
  };

  Color.prototype._initFromString = function(string) {
    var a, b, clr, elements, g, lcString, match, r, x;
    this.initProperties();
    parseCache[string] = this;
    if (match = string.match(hex16ColorRegex)) {
      x = match[0], r = match[1], g = match[2], b = match[3], a = match[4];
      if (!a) {
        this._htmlColorString = string;
      }
      a || (a = "f");
      this.r = parseInt(r, 16) / 15;
      this.g = parseInt(g, 16) / 15;
      this.b = parseInt(b, 16) / 15;
      return this.a = parseInt(a, 16) / 15;
    } else if (match = string.match(hex256ColorRegex)) {
      x = match[0], r = match[1], g = match[2], b = match[3], a = match[4];
      if (!a) {
        this._htmlColorString = string;
      }
      a || (a = "ff");
      this.r = parseInt(r, 16) / 255;
      this.g = parseInt(g, 16) / 255;
      this.b = parseInt(b, 16) / 255;
      return this.a = parseInt(a, 16) / 255;
    } else if (elements = string.match(rgbColorRegex)) {
      this._htmlColorString = string;
      this.a = 1;
      this.r = parseRGBColorComponent(elements[1]);
      this.g = parseRGBColorComponent(elements[2]);
      return this.b = parseRGBColorComponent(elements[3]);
    } else if (elements = string.match(rgbaColorRegex)) {
      this._htmlColorString = string;
      this.r = parseRGBColorComponent(elements[1]);
      this.g = parseRGBColorComponent(elements[2]);
      this.b = parseRGBColorComponent(elements[3]);
      return this.a = elements[4] - 0;
    } else if (/^[a-z]+$/i.test(lcString = string.toLowerCase())) {
      if (!(clr = colorNamesMap[lcString])) {
        return this.log({
          parseError: this.parseError = "WARNING: Color.parse failure. Unknown rgbColor name: " + (inspect(string))
        });
      }
      this._htmlColorString = clr._htmlColorString;
      this.r = clr.r;
      this.g = clr.g;
      this.b = clr.b;
      return this.a = clr.a;
    } else {
      return this.log({
        parseError: this.parseError = "WARNING: Color.parse failure for " + (inspect(string))
      });
    }
  };

  Color.prototype.initProperties = function() {
    this.r = this.g = this.b = 0;
    this.a = defaultAlpha;
    this._hue = this._saturation = this._lightness = null;
    this.parseError = null;
    return this._htmlColorString = null;
  };

  Color.prototype._init = function(a, b, c, d, h, s, l) {
    this.initProperties();
    if (h != null) {
      this._hue = h - 0;
    }
    if (s != null) {
      this._saturation = s - 0;
    }
    if (l != null) {
      this._lightness = l - 0;
    }
    if (a == null) {
      return this.r = this.g = this.b = 0;
    } else if (b == null) {
      return this.r = this.g = this.b = a - 0;
    } else if (c != null) {
      this.r = a - 0;
      this.g = b - 0;
      this.b = c - 0;
      if (d != null) {
        return this.a = d - 0;
      }
    }
  };

  Color.prototype.interpolate = function(toColor, p) {
    var a, b, g, oneMinusP, r, ref;
    ref = this, r = ref.r, g = ref.g, b = ref.b, a = ref.a;
    toColor = rgbColor(toColor);
    if (float32Eq0(a)) {
      r = toColor.r, g = toColor.g, b = toColor.b;
    }
    if (float32Eq0(toColor.a)) {
      toColor = this.withAlpha(0);
    }
    oneMinusP = 1 - p;
    return new Color(toColor.r * p + r * oneMinusP, toColor.g * p + g * oneMinusP, toColor.b * p + b * oneMinusP, toColor.a * p + a * oneMinusP);
  };

  Color.prototype.blend = function(color, amount) {
    var a, b, g, r, ref;
    color = rgbColor(color);
    ref = this, r = ref.r, g = ref.g, b = ref.b, a = ref.a;
    switch (false) {
      case amount == null:
        return new Color((color.r - r) * amount + r, (color.g - g) * amount + g, (color.b - b) * amount + b, (color.a - a) * amount + a);
      case !colorFloatEq(color.a, 1):
        return color;
      case !colorFloatEq(color.a, 0):
        return this;
      default:
        amount = color.a;
        return new Color((color.r - r) * amount + r, (color.g - g) * amount + g, (color.b - b) * amount + b, (1 - a) * amount + a);
    }
  };

  Color.prototype.withAlpha = function(a) {
    return new Color(this.r, this.g, this.b, a);
  };

  Color.prototype.withLightness = function(v) {
    return hslColor(this.h, this.s, v, this.a);
  };

  Color.prototype.withHue = function(v) {
    return hslColor(v, this.s, this.l, this.a);
  };

  Color.prototype.withSat = withSat = function(v) {
    return hslColor(this.h, v, this.l, this.a);
  };

  Color.prototype.withSaturation = withSat;

  Color.prototype.withScaledLightness = function(s) {
    return hslColor(this.h, this.s, s * this.l, this.a);
  };

  Color.prototype.withScaledSaturation = function(s) {
    return hslColor(this.h, s * this.s, this.l, this.a);
  };

  Color.prototype.withScaledLAndS = function(l, s) {
    return hslColor(this.h, s * this.s, l * this.l, this.a);
  };

  Color.prototype.withChannel = function(c, v) {
    switch (c) {
      case "r":
      case "red":
        return new Color(v, this.g, this.b, this.a);
      case "g":
      case "green":
        return new Color(this.r, v, this.b, this.a);
      case "b":
      case "blue":
        return new Color(this.r, this.g, v, this.a);
      case "h":
      case "hue":
        return hslColor(v, this.s, this.l, this.a);
      case "s":
      case "sat":
      case "saturation":
        return hslColor(this.h, v, this.l, this.a);
      case "l":
      case "lightness":
        return this.withLightness(v);
      case "a":
      case "alpha":
        return this.withAlpha(v);
      default:
        throw new Error("invalid channel: " + (inspect(c)));
    }
  };

  Color.prototype.withChannels = function(c) {
    var a, b, g, h, l, r, s;
    if (c.h || c.s || c.l) {
      h = c.h != null ? c.h : this.h;
      s = c.s != null ? c.s : this.s;
      l = c.l != null ? c.l : this.l;
      a = c.a != null ? c.a : this.a;
      return hslColor(h, s, l, a);
    } else {
      r = c.r != null ? c.r : this.r;
      g = c.g != null ? c.g : this.g;
      b = c.b != null ? c.b : this.b;
      a = c.a != null ? c.a : this.a;
      return new Color(r, g, b, a);
    }
  };

  zeroString = "0";

  hexString = function(number, length) {
    if (length == null) {
      length = 2;
    }
    return pad(number.toString(16), length, zeroString, true);
  };

  Color.getter({
    arrayRGB: function() {
      return [this.r, this.g, this.b];
    },
    arrayRgb: function() {
      return [this.r, this.g, this.b];
    },
    arrayHsl: function() {
      return this._computeHsl() && [this._hue, this._saturation, this._lightness];
    },
    rgbSum: function() {
      return this.r + this.g + this.b;
    },
    rgbSquaredSum: function() {
      return this.r * this.r + this.g * this.g + this.b * this.b;
    },
    clamped: function() {
      return new Color(bound(0, this.r, 1), bound(0, this.g, 1), bound(0, this.b, 1), bound(0, this.a, 1));
    },
    r256: function() {
      return bound(0, Math.round(this.r * 255), 255);
    },
    g256: function() {
      return bound(0, Math.round(this.g * 255), 255);
    },
    b256: function() {
      return bound(0, Math.round(this.b * 255), 255);
    },
    a256: function() {
      return bound(0, Math.round(this.a * 255), 255);
    },
    r16: function() {
      return bound(0, Math.round(this.r * 15), 15);
    },
    g16: function() {
      return bound(0, Math.round(this.g * 15), 15);
    },
    b16: function() {
      return bound(0, Math.round(this.b * 15), 15);
    },
    a16: function() {
      return bound(0, Math.round(this.a * 15), 15);
    },
    h256: function() {
      return bound(0, Math.round(this.h * 255), 255);
    },
    s256: function() {
      return bound(0, Math.round(this.s * 255), 255);
    },
    b256: function() {
      return bound(0, Math.round(this.b * 255), 255);
    },
    rClamped: function() {
      return bound(0, this.r, 1);
    },
    gClamped: function() {
      return bound(0, this.g, 1);
    },
    bClamped: function() {
      return bound(0, this.b, 1);
    },
    aClamped: function() {
      return bound(0, this.a, 1);
    },
    premultiplied: function() {
      return new Color(this.r * this.a, this.g * this.a, this.b * this.a, this.a);
    },
    demultiplied: function() {
      return new Color(this.r / this.a, this.g / this.a, this.b / this.a, this.a);
    },
    cssString: function() {
      var a;
      a = this.aClamped;
      return "rgba(" + [this.r256, this.g256, this.b256, a.toFixed(3).replace(/\.?0+$/, '')].join(', ') + ")";
    },
    rgbaString: function() {
      return "rgbColor(" + [this.r256, this.g256, this.b256, this.a256].join('/255, ') + "/255)";
    },
    hexString: function() {
      return "#" + this.rawHexString;
    },
    rgbaHexString: function() {
      return "#" + this.getRawRgbaHexString();
    },
    hex16String: function() {
      return "#" + hexString(this.r16, 1) + hexString(this.g16, 1) + hexString(this.b16, 1);
    },
    hslHexString: function() {
      return "#" + hexString(this.h256) + hexString(this.s256) + hexString(this.b256);
    },
    autoRgbaHexString: function() {
      if (colorFloatEq(1, this.a)) {
        return this.getHexString();
      } else {
        return this.rgbaHexString;
      }
    },
    rawHexString: function() {
      return hexString(this.r256) + hexString(this.g256) + hexString(this.b256);
    },
    rawRgbaHexString: function() {
      return hexString(this.r256) + hexString(this.g256) + hexString(this.b256) + hexString(this.a256);
    }
  });

  Color.prototype.inspect = function() {
    var a;
    a = colorFloatEq(1, this.a) ? this.hexString : this.rgbaHexString;
    return "rgbColor('" + a + "')";
  };

  Color.prototype.toString = function() {
    return this._htmlColorString || (this._htmlColorString = colorFloatEq(1, this.a) ? this.getHexString() : this.getCssString());
  };

  Color.prototype.getHueDelta = function(c) {
    var d;
    d = this.hue - c.hue;
    if (d < -.5) {
      return d + 1;
    } else if (d > .5) {
      return d - 1;
    } else {
      return d;
    }
  };

  Color.prototype.getHueDifference = function(c) {
    return Math.abs(this.getHueDelta(c));
  };

  Color.getter({
    plainObjects: function() {
      if (this.a < 1) {
        return this.rgbaHexString;
      } else {
        return this.hexString;
      }
    },
    inspectedObjects: function() {
      return "<color " + (colorFloatEq(1, this.a) ? this.hexString : this.rgbaHexString) + ">";
    }
  });

  Color.getter({
    h: function() {
      return this._hue != null ? this._hue : this._hue = this._computeHsl() && this._hue;
    },
    s: function() {
      return this._saturation != null ? this._saturation : this._saturation = this._computeHsl() && this._saturation;
    },
    l: function() {
      return this._lightness != null ? this._lightness : this._lightness = this._computeHsl() && this._lightness;
    },
    inverseL: function() {
      return 1 - this.l;
    },
    inverseS: function() {
      return 1 - this.s;
    },
    inverseH: function() {
      return 1 - this.h;
    },
    hue: function() {
      return this._hue != null ? this._hue : this._hue = this._computeHsl() && this._hue;
    },
    sat: function() {
      return this._saturation != null ? this._saturation : this._saturation = this._computeHsl() && this._saturation;
    },
    lit: function() {
      return this._lightness != null ? this._lightness : this._lightness = this._computeHsl() && this._lightness;
    },
    saturation: function() {
      return this._saturation != null ? this._saturation : this._saturation = this._computeHsl() && this._saturation;
    },
    lightness: function() {
      return this._lightness != null ? this._lightness : this._lightness = this._computeHsl() && this._lightness;
    },
    perceptualLightness: function() {
      var b, bWeight, bWeighted, g, gWeight, gWeighted, r, rWeight, rWeighted, ref;
      ref = this, r = ref.r, g = ref.g, b = ref.b;
      rWeighted = r * (rWeight = .7);
      gWeighted = g * (gWeight = .8);
      bWeighted = b * (bWeight = .3);
      if (gWeighted >= rWeighted && gWeighted >= bWeighted) {
        return gWeighted + (r + b) * .5 * (1 - gWeight);
      } else if (bWeighted >= rWeighted && bWeighted >= gWeighted) {
        return bWeighted + (r + g) * .5 * (1 - bWeight);
      } else {
        return rWeighted + (g + b) * .5 * (1 - rWeight);
      }
    },
    perceptualSaturation: function() {
      return Math.pow(this.perceptualLightness, 1 / 3) * this.saturation;
    },
    satLightness: function() {
      return (2 - this._saturation) * this._lightness * .5;
    }
  });

  Color.prototype._computeHsl = function() {
    var b, delta, g, maxRgb, minRgb, r, ref;
    if (this._hue != null) {
      return true;
    }
    ref = this, r = ref.r, g = ref.g, b = ref.b;
    maxRgb = this._lightness = max(r, g, b);
    minRgb = min(r, g, b);
    this._hue = (function() {
      if (maxRgb === minRgb) {
        return this._saturation = 0;
      } else {
        this._saturation = 1 - (minRgb / maxRgb);
        delta = maxRgb - minRgb;
        switch (maxRgb) {
          case r:
            return (g - b) / delta + (g >= b ? 0 : 6);
          case g:
            return (b - r) / delta + 2;
          case b:
            return (r - g) / delta + 4;
        }
      }
    }).call(this);
    this._hue /= 6;
    return true;
  };

  for (k in colorNamesMap) {
    v = colorNamesMap[k];
    colorNamesMap[k] = rgbColor(v);
  }

  return Color;

})(AtomicBase);


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*

With the exception of the setter methods, this is a pure-functional class.
 */

/*
Experiment: Instead of storing the matrix as 6 members, use a Float32Array:

  Bonus: if we order the 6 elements correctly, we can just pass the Float32Array directly to Webgl uniformMatrix3fv
  Result:
    FF is about 2x as fast with this implementation, but Chrome is about 10x slower (see below)
    Sticking with Members implementation for now.

On my Macbook pro Retina (2.6 GHz Intel Core i7)

Chrome 29.0.1547.57 (members)
  Matrix.translate 14,716,649/s
  matrix().translate 8,052,404/s
  transform point 3,922,725/s
  invert 12,733,472/s
  mul 16,146,097/s

Chrome 29.0.1547.57 (float32Array)
  Matrix.translate 926,402/s
  matrix().translate 463,791/s
  transform point 3,684,177/s
  invert 978,248/s
  mul 992,078/s

FF 23.0.1 (members)
  Matrix.translate 1,281,078/s
  matrix().translate 534,542/s
  transform point 768,224/s
  invert 1,374,788/s
  mul 1,413,206/s

FF 23.0.1 (float32Array)
  Matrix.translate 2,126,281/s
  matrix().translate 1,013,548/s
  transform point 832,604/s
  invert 2,524,903/s
  mul 2,669,331/s

NOTE! the order of the fields in the float32array for Webgl uniformMatrix3fv should be:
  @values[0] = @sx
  @values[1] = @shy
  @values[2] = @tx
  @values[3] = @shx
  @values[4] = @sy
  @values[5] = @ty
 */
var AtomicBase, Foundation, Matrix, Point, Rectangle, ceil, compact, defineModule, float32Eq, floor, inspect, isNumber, log, point, rect, simplifyNum, sqrt,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(19);

Point = __webpack_require__(25);

Rectangle = __webpack_require__(32);

point = Point.point;

rect = Rectangle.rect;

ceil = Math.ceil, floor = Math.floor, sqrt = Math.sqrt;

inspect = Foundation.inspect, simplifyNum = Foundation.simplifyNum, float32Eq = Foundation.float32Eq, compact = Foundation.compact, log = Foundation.log, isNumber = Foundation.isNumber, defineModule = Foundation.defineModule;

defineModule(module, Matrix = (function(superClass) {
  var cleanInspect, identityMatrix, intermediatResultMatrix, matrix, transform1D;

  extend(Matrix, superClass);

  function Matrix() {
    return Matrix.__super__.constructor.apply(this, arguments);
  }

  Matrix.defineAtomicClass({
    fieldNames: "sx sy shx shy tx ty"
  });

  Matrix.matrix = matrix = function(a, b, c, d, e, f) {
    if (a instanceof Matrix) {
      return a;
    } else if (a === null || a === void 0) {
      return identityMatrix;
    } else {
      return new Matrix(a, b, c, d, e, f);
    }
  };

  Matrix._cleanInspect = cleanInspect = function(pointName, s) {
    var out, r;
    out = pointName ? (r = new RegExp("([0-9])" + pointName, "g"), s.replace(r, "$1 * " + pointName).replace(/-1 \* /g, "-").replace(/\ \+ -/g, " - ").replace(/0\./g, ".")) : s.replace(/-1([A-Za-z]+)/g, "-$1").replace(/\ \+ -/g, " - ").replace(/0\./g, ".");
    return out;
  };

  Matrix.translate = function(a, b) {
    var x, y;
    if (isNumber(b)) {
      throw new Error("Matrix.translate no longer accepts two numbers. Use translateXY");
    }
    if (isNumber(a)) {
      x = y = a;
    } else {
      x = a.x, y = a.y;
    }
    return Matrix.translateXY(x, y);
  };

  Matrix.translateXY = function(x, y) {
    if (x === 0 && y === 0) {
      return identityMatrix;
    } else {
      return new Matrix(1, 1, 0, 0, x, y);
    }
  };

  Matrix.scale = function(a, b) {
    var x, y;
    if (isNumber(b)) {
      throw new Error("Matrix.scale no longer accepts two numbers. Use translateXY");
    }
    if (isNumber(a)) {
      x = y = a;
    } else {
      x = a.x, y = a.y;
    }
    return Matrix.scaleXY(x, y);
  };

  Matrix.scaleXY = function(sx, sy) {
    if (sx === 1 && sy === 1) {
      return identityMatrix;
    } else {
      return new Matrix(sx, sy, 0, 0, 0, 0);
    }
  };

  Matrix.rotate = function(radians) {
    var cr, sr;
    cr = Math.cos(radians);
    sr = Math.sin(radians);
    if (cr === 1 && sr === 0) {
      return identityMatrix;
    } else {
      return new Matrix(cr, cr, -sr, sr, 0, 0);
    }
  };

  Matrix.prototype.initDefaults = function() {
    this.sx = this.sy = 1;
    this.shy = this.shx = 0;
    this.tx = this.ty = 0;
    this._exactScale = this._exactScaler = null;
    return this;
  };

  Matrix.prototype._init = function(a, b, c, d, e, f) {
    this.initDefaults();
    if (a == null) {
      return;
    }
    if (a instanceof Point) {
      return this._initFromPoint(a);
    } else if (a instanceof Matrix) {
      return this._initFromMatrix(a);
    } else {
      this.sx = a - 0;
      if (b != null) {
        this.sy = b - 0;
      }
      if (c != null) {
        this.shx = c - 0;
      }
      if (d != null) {
        this.shy = d - 0;
      }
      if (e != null) {
        this.tx = e - 0;
      }
      if (f != null) {
        return this.ty = f - 0;
      }
    }
  };

  Matrix.prototype.getScale = function() {
    return this.getS();
  };

  Matrix.getter({
    t: function() {
      return point(this.tx, this.ty);
    },
    s: function() {
      return point(this.sx, this.sy);
    },
    sh: function() {
      return point(this.shx, this.shy);
    },
    xsv: function() {
      return point(this.sx, this.shx);
    },
    ysv: function() {
      return point(this.sy, this.shy);
    },
    xsvMagnitude: function() {
      return sqrt(this.sx * this.sx + this.shx * this.shx);
    },
    ysvMagnitude: function() {
      return sqrt(this.sy * this.sy + this.shy * this.shy);
    },
    exactScale: function() {
      return this._exactScale || (this._exactScale = point(this.xsv.magnitude, this.ysv.magnitude));
    },
    exactScaler: function() {
      return this._exactScaler || (this._exactScaler = (this.getXsvMagnitude() + this.getYsvMagnitude()) / 2);
    },
    inv: function() {
      return this.invert();
    },
    locationX: function() {
      return this.tx;
    },
    locationY: function() {
      return this.ty;
    },
    scaleX: function() {
      return this.sx;
    },
    scaleY: function() {
      return this.sy;
    },
    location: function() {
      return point(this.tx, this.ty);
    },
    rounded: function() {
      return this.getWithRoundedTranslation();
    },
    withRoundedTranslation: function() {
      if (this.translationIsIntegral) {
        return this;
      } else {
        return new Matrix(this.sx, this.sy, this.shx, this.shy, Math.round(this.tx), Math.round(this.ty));
      }
    },
    angle: function() {
      var p1, p2;
      p1 = this.transform(Point.point0);
      p2 = this.transform(new Point(0, 1));
      return (p2.sub(p1)).angle - Math.PI * .5;
    },
    float32Array: function() {
      return this.fillFloat32Array(new Float32Array(9));
    },
    isIdentity: function() {
      return float32Eq(this.sx, 1) && float32Eq(this.sy, 1) && float32Eq(this.shx, 0) && float32Eq(this.shy, 0) && float32Eq(this.tx, 0) && float32Eq(this.ty, 0);
    },
    isTranslateOnly: function() {
      return float32Eq(this.sx, 1) && float32Eq(this.sy, 1) && float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
    },
    translationIsIntegral: function() {
      return float32Eq(this.tx, Math.round(this.tx)) && float32Eq(this.ty, Math.round(this.ty));
    },
    isIntegerTranslateOnly: function() {
      return this.isTranslateOnly && float32Eq(this.tx, this.tx | 0) && float32Eq(this.ty, this.ty | 0);
    },
    isTranslateAndScaleOnly: function() {
      return float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
    },
    hasSkew: function() {
      return !this.getIsTranslateAndScaleOnly();
    },
    isTranslateAndPositiveScaleOnly: function() {
      return this.sx > 0 && this.sy > 0 && float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
    }
  });

  Matrix.prototype.fillFloat32Array = function(a) {
    a[0] = this.sx;
    a[1] = this.shx;
    a[2] = this.tx;
    a[3] = this.shy;
    a[4] = this.sy;
    a[5] = this.ty;
    return a;
  };

  Matrix.prototype.simplify = function() {
    return new Matrix(simplifyNum(this.sx), simplifyNum(this.sy), simplifyNum(this.shx), simplifyNum(this.shy), simplifyNum(this.tx), simplifyNum(this.ty));
  };

  Matrix.prototype.withAngle = function(a) {
    return this.rotate(a - this.angle);
  };

  Matrix.prototype.withScale = function(a, b) {
    var x, y;
    if (isNumber(a)) {
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    return this.scale(x / this.sx, y / this.sy);
  };

  Matrix.prototype.withLocation = function(a, b) {
    var x, y;
    if (isNumber(a)) {
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    if (x === this.tx && y === this.ty) {
      return this;
    } else {
      return new Matrix(this.sx, this.sy, this.shx, this.shy, x, y);
    }
  };

  Matrix.prototype.withLocationXY = function(x, y) {
    if (x === this.tx && y === this.ty) {
      return this;
    } else {
      return new Matrix(this.sx, this.sy, this.shx, this.shy, x, y);
    }
  };


  /*
  IN:
    amount: point or number
    into: t/f
   */

  Matrix.prototype.translate = function(amount, into) {
    var x, y;
    if (isNumber(amount)) {
      x = y = amount;
    } else {
      x = amount.x, y = amount.y;
    }
    if (isNumber(into)) {
      throw new Error("Illegal second input: number (" + into + "). Use translateXY.");
    }
    return this.translateXY(x, y, into);
  };

  Matrix.prototype.translateXY = function(x, y, into) {
    return this._into(into, this.sx, this.sy, this.shx, this.shy, this.tx + x, this.ty + y);
  };

  Matrix.prototype.rotate = function(radians, into) {
    var cr, sr;
    cr = Math.cos(radians);
    sr = Math.sin(radians);
    return this._into(into, this.sx * cr - this.shy * sr, this.shx * sr + this.sy * cr, this.shx * cr - this.sy * sr, this.sx * sr + this.shy * cr, this.tx * cr - this.ty * sr, this.tx * sr + this.ty * cr);
  };

  Matrix.prototype.scale = function(a, into) {
    var x, y;
    if (isNumber(into)) {
      throw new Error("Matrix.scale no longer accepts two numbers. Use translateXY");
    }
    if (isNumber(a)) {
      x = y = a;
    } else {
      x = a.x, y = a.y;
    }
    return this.scaleXY(x, y, into);
  };

  Matrix.prototype.scaleXY = function(x, y, into) {
    return this._into(into, this.sx * x, this.sy * y, this.shx * x, this.shy * y, this.tx * x, this.ty * y);
  };

  Matrix.getter({
    determinantReciprocal: function() {
      return 1.0 / (this.sx * this.sy - this.shy * this.shx);
    }
  });

  Matrix.prototype.invert = function(into) {
    var d;
    d = this.getDeterminantReciprocal();
    return this._into(into, d * this.sy, d * this.sx, d * -this.shx, d * -this.shy, d * (-this.tx * this.sy + this.ty * this.shx), d * (this.tx * this.shy - this.ty * this.sx));
  };

  Matrix.prototype.mul = function(m, into) {
    if (isNumber(m)) {
      return this._into(into, this.sx * m, this.sy * m, this.shx * m, this.shy * m, this.tx * m, this.ty * m);
    } else {
      return this._into(into, this.sx * m.sx + this.shy * m.shx, this.shx * m.shy + this.sy * m.sy, this.shx * m.sx + this.sy * m.shx, this.sx * m.shy + this.shy * m.sy, this.tx * m.sx + this.ty * m.shx + m.tx, this.tx * m.shy + this.ty * m.sy + m.ty);
    }
  };

  Matrix.prototype.div = function(m, into) {
    var multipler;
    multipler = isNumber(m) ? 1 / m : m.invert(intermediatResultMatrix);
    return this.mul(multipler, into);
  };

  Matrix.prototype.inspectX = function(pointName, nullForZeroString) {
    var pn;
    pn = pointName;
    pointName = pointName ? pointName + "." : "";
    if (!(this.sx || this.shx || this.tx)) {
      return (!nullForZeroString ? "0" : void 0);
    }
    return cleanInspect(pn, compact([this.sx === 1 ? pointName + "x" : this.sx ? "" + this.sx + pointName + "x" : void 0, this.shx === 1 ? pointName + "y" : this.shx ? "" + this.shx + pointName + "y" : void 0, this.tx ? "" + this.tx : void 0]).join(" + "));
  };

  Matrix.prototype.inspectY = function(pointName, nullForZeroString) {
    var pn;
    pn = pointName;
    pointName = pointName ? pointName + "." : "";
    if (!(this.sy || this.shy || this.ty)) {
      return (!nullForZeroString ? "0" : void 0);
    }
    return cleanInspect(pn, compact([this.sy === 1 ? pointName + "y" : this.sy ? "" + this.sy + pointName + "y" : void 0, this.shy === 1 ? pointName + "x" : this.shy ? "" + this.shy + pointName + "x" : void 0, this.ty ? "" + this.ty : void 0]).join(" + "));
  };

  Matrix.prototype.inspectBoth = function(pointName) {
    return "(" + (this.inspectX(pointName)) + ", " + (this.inspectY(pointName)) + ")";
  };

  Matrix.transform1D = transform1D = function(x, y, sx, shx, tx) {
    return x * sx + y * shx + tx;
  };


  /*
  IN: a: Point or any object where .x and .y are numbers
  IN: a: x (number; required), b: y (number, default: x)
   */

  Matrix.prototype.transform = function(a, b) {
    var x, y;
    if (isNumber(a)) {
      log.error("DEPRICATED: matrix.transform(x, y) - use matrix.transformXY");
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    return this.transformXY(x, y);
  };

  Matrix.prototype.transformX = function(x, y) {
    return transform1D(x, y, this.sx, this.shx, this.tx);
  };

  Matrix.prototype.transformY = function(x, y) {
    return transform1D(y, x, this.sy, this.shy, this.ty);
  };

  Matrix.prototype.transformXY = function(x, y) {
    return new Point(this.transformX(x, y), this.transformY(x, y));
  };

  Matrix.prototype.inverseTransform = function(a, b) {
    var d, shx, shy, sx, sy, tx, ty, x, y;
    if (isNumber(a)) {
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    d = this.getDeterminantReciprocal();
    sx = d * this.sy;
    sy = d * this.sx;
    shx = d * -this.shx;
    shy = d * -this.shy;
    tx = d * (-this.tx * this.sy + this.ty * this.shx);
    ty = d * (this.tx * this.shy - this.ty * this.sx);
    return new Point(transform1D(x, y, sx, shx, tx), transform1D(y, x, sy, shy, ty));
  };

  Matrix.prototype.transformVector = function(a, b) {
    var dx, dy;
    switch ((a != null) && a.constructor) {
      case false:
        dx = dy = 0;
        break;
      case Point:
        dx = a.x;
        dy = a.y;
        break;
      default:
        dx = a;
        dy = b;
    }
    return new Point(dx * this.sx + dy * this.shx, dy * this.sy + dx * this.shy);
  };

  Matrix.prototype.transformDifference = function(v1, v2) {
    var dx, dy;
    dx = v1.x - v2.x;
    dy = v1.y - v2.y;
    return new Point(dx * this.sx + dy * this.shx, dy * this.sy + dx * this.shy);
  };

  Matrix.prototype.transformBoundingRect = function(r, roundOut) {
    var bottom, h, left, right, top, w, x, x1, x2, x3, x4, y, y1, y2, y3, y4;
    if (roundOut == null) {
      roundOut = false;
    }
    r = rect(r);
    if (r.infinite || this.isIdentity) {
      return r;
    }
    if (this.shx === 0 && this.shy === 0) {
      x = r.x * this.sx + this.tx;
      y = r.y * this.sy + this.ty;
      w = r.w * this.sx;
      h = r.h * this.sy;
      if (w < 0) {
        x += w;
        w = -w;
      }
      if (h < 0) {
        y += h;
        h = -h;
      }
    } else {
      top = r.top, left = r.left, right = r.right, bottom = r.bottom;
      x1 = transform1D(left, top, this.sx, this.shx, this.tx);
      y1 = transform1D(top, left, this.sy, this.shy, this.ty);
      x2 = transform1D(right, top, this.sx, this.shx, this.tx);
      y2 = transform1D(top, right, this.sy, this.shy, this.ty);
      x3 = transform1D(right, bottom, this.sx, this.shx, this.tx);
      y3 = transform1D(bottom, right, this.sy, this.shy, this.ty);
      x4 = transform1D(left, bottom, this.sx, this.shx, this.tx);
      y4 = transform1D(bottom, left, this.sy, this.shy, this.ty);
      x = Math.min(x1, x2, x3, x4);
      w = Math.max(x1, x2, x3, x4) - x;
      y = Math.min(y1, y2, y3, y4);
      h = Math.max(y1, y2, y3, y4) - y;
    }
    if (roundOut) {
      right = ceil(x + w);
      bottom = ceil(y + h);
      x = floor(x);
      y = floor(y);
      w = right - x;
      h = bottom - y;
    }
    return new Rectangle(x, y, w, h);
  };

  Matrix.identityMatrix = identityMatrix = new Matrix;

  Matrix.matrix0 = new Matrix(0, 0, 0, 0, 0, 0);

  intermediatResultMatrix = new Matrix;

  Matrix.prototype._initFromMatrix = function(m) {
    this.sx = m.sx;
    this.sy = m.sy;
    this.shx = m.shx;
    this.shy = m.shy;
    this.tx = m.tx;
    this.ty = m.ty;
    return this;
  };

  Matrix.prototype._initFromPoint = function(p) {
    this.tx = p.x;
    this.ty = p.y;
    return this;
  };

  return Matrix;

})(AtomicBase));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var AtomicBase, Foundation, Perimeter, Point, floatEq, inspect, isPlainObject, isString, log, point, rect,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(19);

Point = __webpack_require__(25);

log = Foundation.log, inspect = Foundation.inspect, floatEq = Foundation.floatEq, isPlainObject = Foundation.isPlainObject, isString = Foundation.isString;

point = Point.point;

rect = __webpack_require__(32).rect;

module.exports = Perimeter = (function(superClass) {
  var k, namedPerimeters, perimeter, perimeter0, ref, v;

  extend(Perimeter, superClass);

  function Perimeter() {
    return Perimeter.__super__.constructor.apply(this, arguments);
  }

  Perimeter.defineAtomicClass({
    fieldNames: "left right top bottom"
  });

  Perimeter.perimeter = perimeter = function(a, b, c, d) {
    var p;
    if (a instanceof Perimeter) {
      return a;
    }
    if (isString(a) && (p = namedPerimeters[a])) {
      return p;
    }
    if ((b == null) && (floatEq(a, 0)) || !a) {
      return perimeter0;
    }
    return new Perimeter(a, b, c, d);
  };

  Perimeter.prototype._initFields = function() {
    return this.left = this.right = this.top = this.bottom = 0;
  };

  Perimeter.prototype._initFromObject = function(obj) {
    this._initFields();
    this.left = (obj.left || 0) + (obj.l || 0) + (obj.h || 0) + (obj.horizontal || 0);
    this.right = (obj.right || 0) + (obj.r || 0) + (obj.h || 0) + (obj.horizontal || 0);
    this.top = (obj.top || 0) + (obj.t || 0) + (obj.v || 0) + (obj.vertical || 0);
    return this.bottom = (obj.bottom || 0) + (obj.b || 0) + (obj.v || 0) + (obj.vertical || 0);
  };

  Perimeter.prototype._init = function(a, b, c, d) {
    var argLength;
    this._initFields();
    argLength = a != null ? b != null ? c != null ? d != null ? 4 : 3 : 2 : 1 : 0;
    switch (argLength) {
      case 0:
        return this.left = this.right = this.top = this.bottom = 0;
      case 1:
        return this.left = this.right = this.top = this.bottom = a;
      case 2:
        this.left = this.right = a;
        return this.top = this.bottom = b;
      case 4:
        this.left = a;
        this.right = b;
        this.top = c;
        return this.bottom = d;
      default:
        throw new Error("invalid number of arguments: " + (inspect(arguments)));
    }
  };

  Perimeter.getter({
    exportedValue: function() {
      var bottom, left, out, ref, right, top;
      ref = this, left = ref.left, right = ref.right, top = ref.top, bottom = ref.bottom;
      if ((left === right) && (left === top) && (left === bottom)) {
        return left;
      } else {
        out = {};
        if (left === right) {
          if (left !== 0) {
            out.h = left;
          }
        } else {
          if (left !== 0) {
            out.left = left;
          }
          if (right !== 0) {
            out.right = right;
          }
        }
        if (top === bottom) {
          if (top !== 0) {
            return out.v = top;
          }
        } else {
          if (top !== 0) {
            out.top = top;
          }
          if (bottom !== 0) {
            return out.bottom = bottom;
          }
        }
      }
    },
    width: function() {
      return this.left + this.right;
    },
    height: function() {
      return this.top + this.bottom;
    },
    w: function() {
      return this.left + this.right;
    },
    h: function() {
      return this.top + this.bottom;
    },
    needsTranslation: function() {
      return this.left !== 0 || this.top !== 0;
    }
  });

  Perimeter.prototype.subtractedFromSize = function(size) {
    var h, w;
    w = this.getWidth();
    h = this.getHeight();
    if (floatEq(w, 0) && floatEq(h, 0)) {
      return size;
    } else {
      return point(size.x - w, size.y - h);
    }
  };

  Perimeter.prototype.addedToSize = function(size) {
    var h, w;
    w = this.getWidth();
    h = this.getHeight();
    if (floatEq(w, 0) && floatEq(h, 0)) {
      return size;
    } else {
      return point(size.x + w, size.y + h);
    }
  };


  /*
  Named Instances
   */

  Perimeter.namedPerimeters = namedPerimeters = {
    perimeter0: perimeter0 = Object.freeze(new Perimeter(0))
  };

  ref = Perimeter.namedPerimeters;
  for (k in ref) {
    v = ref[k];
    Perimeter[k] = v;
  }

  Perimeter.prototype.pad = function(rectangle) {
    var bottom, h, left, ref1, right, top, w, x, y;
    x = rectangle.left, y = rectangle.top, w = rectangle.w, h = rectangle.h;
    ref1 = this, left = ref1.left, right = ref1.right, top = ref1.top, bottom = ref1.bottom;
    return rectangle.withRect(x + left, y + top, w - left - right, h - top - bottom);
  };

  return Perimeter;

})(AtomicBase);


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Aws4RestClient, Config, aws4, defineModule, formattedInspect, getAwsCredentials, getAwsServiceConfig, getEnv, isString, log, merge, objectWithout, ref, ref1, select, urlRegexp,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), objectWithout = ref.objectWithout, formattedInspect = ref.formattedInspect, select = ref.select, isString = ref.isString, defineModule = ref.defineModule, urlRegexp = ref.urlRegexp, getEnv = ref.getEnv, merge = ref.merge, log = ref.log, select = ref.select;

ref1 = Config = __webpack_require__(10), getAwsServiceConfig = ref1.getAwsServiceConfig, getAwsCredentials = ref1.getAwsCredentials;

aws4 = __webpack_require__(299);

defineModule(module, Aws4RestClient = (function(superClass) {
  var pathJoin;

  extend(Aws4RestClient, superClass);

  Aws4RestClient.singletonClass();


  /*
  IN:
    service: string (required)
    credentials: (optional)
      secretAccessKey:  "<your-secret-access-key>"
      accessKeyId:      "<your-access-key-id>"
      sessionToken:     "<your-session-token>"
  
  Art.Aws.Config
    If credentials isn't specified in options, credentials is taken from:
      Art.Aws.Config.getCredentials @service
      See: Art.Aws.Config
  
    Example config:
  
    Art: Aws:
       * elasticsearch
      elasticsearch: credenticals: {...}
  
  ENVIRONMENT
    if credential isn't supplied, they are looked for in "getEnv()".
  
    NOTE: getEnv() returns the parsed query-string in browsers and the shell-environment in node.
  
    Here are the env vars:
      secretAccessKey or AWS_SECRET_ACCESS_KEY
      accessKeyId     or AWS_ACCESS_KEY_ID
      sessionToken    or AWS_SESSION_TOKEN
   */

  function Aws4RestClient(options) {
    var ref2;
    Aws4RestClient.__super__.constructor.apply(this, arguments);
    if (!isString(options != null ? options.service : void 0)) {
      throw new Error("service required");
    }
    this.service = options.service, this.endpoint = options.endpoint, this.credentials = options.credentials;
    this.credentials || (this.credentials = getAwsCredentials(this.service));
    this.endpoint || (this.endpoint = (ref2 = getAwsServiceConfig(this.service)) != null ? ref2.endpoint : void 0);
  }

  pathJoin = function(base, path) {
    path = path ? path.replace(/^\//, '') : '';
    base = base ? base.replace(/\/$/, '') : '';
    return base + "/" + path;
  };

  Aws4RestClient.prototype.sign = function(options) {
    var __, body, headers, host, matched, method, path, port, protocol, query, ref2, ref3, url;
    url = options.url, headers = options.headers, body = options.body, method = options.method;
    if (!urlRegexp.test(url)) {
      if (!this.endpoint) {
        throw new Error("url does not have a host and no endpoint specified for service. " + (formattedInspect({
          service: this.service,
          url: url
        })));
      }
      url = pathJoin(this.endpoint, url);
    }
    ref2 = matched = url.match(urlRegexp), __ = ref2[0], protocol = ref2[1], __ = ref2[2], host = ref2[3], __ = ref2[4], port = ref2[5], path = (ref3 = ref2[6]) != null ? ref3 : '/', __ = ref2[7], query = ref2[8];
    if (!host) {
      throw new Error("unvalid url: " + (formattedInspect({
        url: url
      })));
    }
    if (port != null) {
      host = host + ":" + port;
    }
    if (query) {
      path = path + "?" + query;
    }
    return merge(options, {
      url: url,
      headers: this._getSignatureHeaders({
        method: method,
        host: host,
        service: this.service,
        path: path,
        headers: select(headers, "content-type", "Content-Type"),
        body: body
      })
    });
  };

  Aws4RestClient.prototype._getSignatureHeaders = function(signOptions) {
    return objectWithout(aws4.sign(signOptions, this.credentials).headers, "Host", "Content-Length");
  };

  Aws4RestClient.prototype._normalizedRestRequest = function(options) {
    return Aws4RestClient.__super__._normalizedRestRequest.call(this, this.sign(options));
  };

  return Aws4RestClient;

})((__webpack_require__(21)).RestClientClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {


/*
Local Web Console / Shell: http://localhost:8081/shell/

The AWS DynamoDb API is redundent and uses UpperCamelCase names all over.

Goals:
  create a wrapper API which:

  - elliminates redundencies
  - uses lowerCamelCase key names for JavaScript naming convention compatibility.

Strategy:
  Incremental. Not all commands will be updated to the "new" api.
  Instead, the API will always accept the unfiltered DynamoDb API with UpperCamelCase names.
  As I can, I'll create a lowerCamelCase API for each commant.

lowerCamelCase API:

METHODS
  createTable
    attributes:     # see translateAttributes
    key:            # see translateKey
    provisioning:   # see translateProvisioning
    globalIndexes:  # see
    localIndexes:

HELPERS
  translateAttributes
    attributes:
      myHashKeyName:    'string'
      myRangeKeyName:   'string'
      myNumberAttrName: 'number'
      myBinaryAttrName: 'binary'

  translateKey
    key:
      myHashKeyName:  'hash'
      myRangeKeyName: 'range'

      OR: "hashKeyField"
      OR: "hashKeyField/rangeKeyField"
        NOTE: you can use any string format that matches /[_a-zA-Z0-9]+/g

  translateProvisioning
    provisioning:
      read: 5
      write: 5

  translateGlobalIndexes
    globalIndexes:
      myIndexName:
        "hashKey"           # see translateKey
        "hashKey/rangeKey"  # see translateKey

        OR

        key:          # see translateKey
        projection:   # see translateProjection
        provisioning: # see translateProvisioning

  translateLocalIndexes
    localIndexes:
      myIndexName:
        "hashKey"           # see translateKey
        "hashKey/rangeKey"  # see translateKey

        OR

        key:          # see translateKey
        projection:   # see translateProjection
 */
var BaseClass, Config, CreateTable, DeleteItem, DynamoDb, GetItem, Promise, PutItem, Query, StreamlinedDynamoDbApi, TableApiBaseClass, UpdateItem, array, capitalize, config, decapitalize, decodeDynamoItem, diff, each, eq, formattedInspect, inspect, isBoolean, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, object, objectDiff, objectDiffReport, objectHasKeys, objectKeyCount, ref, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), merge = ref.merge, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isBoolean = ref.isBoolean, isString = ref.isString, isNumber = ref.isNumber, inspect = ref.inspect, capitalize = ref.capitalize, decapitalize = ref.decapitalize, lowerCamelCase = ref.lowerCamelCase, wordsArray = ref.wordsArray, array = ref.array, log = ref.log, eq = ref.eq, formattedInspect = ref.formattedInspect, objectHasKeys = ref.objectHasKeys, Promise = ref.Promise, objectDiff = ref.objectDiff, objectDiffReport = ref.objectDiffReport, object = ref.object, diff = ref.diff, objectKeyCount = ref.objectKeyCount, each = ref.each;

BaseClass = __webpack_require__(3).BaseClass;

config = (Config = __webpack_require__(10)).config;

StreamlinedDynamoDbApi = __webpack_require__(85);

Query = StreamlinedDynamoDbApi.Query, CreateTable = StreamlinedDynamoDbApi.CreateTable, PutItem = StreamlinedDynamoDbApi.PutItem, UpdateItem = StreamlinedDynamoDbApi.UpdateItem, DeleteItem = StreamlinedDynamoDbApi.DeleteItem, GetItem = StreamlinedDynamoDbApi.GetItem, TableApiBaseClass = StreamlinedDynamoDbApi.TableApiBaseClass;

decodeDynamoItem = TableApiBaseClass.decodeDynamoItem;

module.exports = DynamoDb = (function(superClass) {
  var nonInternalErrorsRegex;

  extend(DynamoDb, superClass);

  DynamoDb.singletonClass();

  function DynamoDb(options) {
    if (options == null) {
      options = {};
    }
    this._awsDynamoDb = new AWS.DynamoDB(merge(Config.getNormalizedConfig("dynamoDb", options)));
  }

  nonInternalErrorsRegex = /ConditionalCheckFailedException|ResourceNotFoundException/;

  DynamoDb.prototype.invokeAws = function(name, params) {
    return Promise.withCallback((function(_this) {
      return function(callback) {
        return _this._awsDynamoDb[name](params, callback);
      };
    })(this))["catch"]((function(_this) {
      return function(error) {
        if (config.verbose || !nonInternalErrorsRegex.test(error.message)) {
          log.error({
            "Art.Aws.DynamoDb": {
              method: name,
              status: "request was rejected",
              message: error.message,
              verbose: config.verbose,
              params: params,
              error: error
            }
          });
        }
        throw error;
      };
    })(this));
  };

  DynamoDb.bindAll = function(map) {
    var customMethod, name, results;
    results = [];
    for (name in map) {
      customMethod = map[name];
      results.push((function(_this) {
        return function(name, customMethod) {
          return _this.prototype[name] = customMethod || function(params) {
            return this.invokeAws(name, params);
          };
        };
      })(this)(name, customMethod));
    }
    return results;
  };

  DynamoDb.bindAll({
    createTable: function(params) {
      var e;
      try {
        return this.invokeAws("createTable", CreateTable.translateParams(merge({
          attributes: {
            id: 'string'
          },
          key: {
            id: 'hash'
          }
        }, params)));
      } catch (error1) {
        e = error1;
        log({
          createTableInputParams: params
        });
        throw e;
      }
    },
    createNewGlobalSecondaryIndexes: function(createTableParams) {
      var TableName;
      TableName = TableApiBaseClass.translateParams(createTableParams).TableName;
      return Promise.all([this.getTableChanges(createTableParams), this.getTableStatus(createTableParams)]).then((function(_this) {
        return function(arg) {
          var AttributeDefinitions, AttributeDefinitionsByName, GlobalSecondaryIndexUpdates, GlobalSecondaryIndexes, TableStatus, added, normalizedGsisByName, ref1, ref2, ref3, requiredAttributes;
          (ref1 = arg[0], GlobalSecondaryIndexes = ref1.GlobalSecondaryIndexes), (ref2 = arg[1], TableStatus = ref2.TableStatus);
          if (GlobalSecondaryIndexes) {
            added = GlobalSecondaryIndexes.added;
          }
          if (!(0 < objectKeyCount(added))) {
            return {
              info: "no new GlobalSecondaryIndexes"
            };
          }
          if (TableStatus !== "ACTIVE") {
            return {
              info: "Can't modify indexes until TableStatus is ACTIVE"
            };
          }
          ref3 = CreateTable.translateParams(createTableParams), GlobalSecondaryIndexes = ref3.GlobalSecondaryIndexes, TableName = ref3.TableName, AttributeDefinitions = ref3.AttributeDefinitions;
          normalizedGsisByName = object(GlobalSecondaryIndexes, {
            key: function(index) {
              return index.IndexName;
            }
          });
          requiredAttributes = {};
          AttributeDefinitionsByName = object(AttributeDefinitions, {
            key: function(arg1) {
              var AttributeName;
              AttributeName = arg1.AttributeName;
              return AttributeName;
            }
          });
          GlobalSecondaryIndexUpdates = array(added, function(arg1) {
            var IndexName, KeySchema;
            KeySchema = arg1.KeySchema, IndexName = arg1.IndexName;
            each(KeySchema, function(arg2) {
              var AttributeName;
              AttributeName = arg2.AttributeName;
              return requiredAttributes[AttributeName] = true;
            });
            return {
              Create: normalizedGsisByName[IndexName]
            };
          });
          AttributeDefinitions = array(requiredAttributes, function(truth, key) {
            return AttributeDefinitionsByName[key];
          });
          return _this.invokeAws("updateTable", {
            TableName: TableName,
            GlobalSecondaryIndexUpdates: GlobalSecondaryIndexUpdates,
            AttributeDefinitions: AttributeDefinitions
          }).then(function(info) {
            return {
              creating: added,
              info: info
            };
          });
        };
      })(this)).then((function(_this) {
        return function(out) {
          return _this.getTableStatus(createTableParams).then(function(status) {
            return merge(out, {
              status: status
            });
          });
        };
      })(this));
    },
    deleteOldGlobalSecondaryIndexes: function(createTableParams) {
      var TableName;
      TableName = TableApiBaseClass.translateParams(createTableParams).TableName;
      return Promise.all([this.getTableChanges(createTableParams), this.getTableStatus(createTableParams)]).then((function(_this) {
        return function(arg) {
          var GlobalSecondaryIndexUpdates, GlobalSecondaryIndexes, TableStatus, ref1, ref2, removed;
          (ref1 = arg[0], GlobalSecondaryIndexes = ref1.GlobalSecondaryIndexes), (ref2 = arg[1], TableStatus = ref2.TableStatus);
          if (GlobalSecondaryIndexes) {
            removed = GlobalSecondaryIndexes.removed;
          }
          if (!(0 < objectKeyCount(removed))) {
            return {
              info: "no old GlobalSecondaryIndexes"
            };
          }
          if (TableStatus !== "ACTIVE") {
            return {
              info: "Can't modify indexes until TableStatus is ACTIVE"
            };
          }
          GlobalSecondaryIndexUpdates = array(removed, function(arg1) {
            var IndexName;
            IndexName = arg1.IndexName;
            return {
              Delete: {
                IndexName: IndexName
              }
            };
          });
          return _this.invokeAws("updateTable", {
            TableName: TableName,
            GlobalSecondaryIndexUpdates: GlobalSecondaryIndexUpdates
          }).then(function(info) {
            return {
              deleting: removed,
              info: info
            };
          });
        };
      })(this)).then((function(_this) {
        return function(out) {
          return _this.getTableStatus(createTableParams).then(function(status) {
            return merge(out, {
              status: status
            });
          });
        };
      })(this));
    },

    /*
    IN: see Query.translateQueryParams
    OUT:
      DynamoDb standard output AND
      Same output with lowerCamelCase names:
        items: Items
        count: Count
        scannedCount: ScannedCount
        lastEvaluatedKey: LastEvaluatedKey
        consumedCapacity: ConsumedCapacity
     */
    query: function(params) {
      return this.invokeAws("query", Query.translateParams(params)).then(function(res) {
        var ConsumedCapacity, Count, Items, LastEvaluatedKey, ScannedCount, item;
        Items = res.Items, Count = res.Count, ScannedCount = res.ScannedCount, LastEvaluatedKey = res.LastEvaluatedKey, ConsumedCapacity = res.ConsumedCapacity;
        return merge(res, {
          items: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = Items.length; i < len; i++) {
              item = Items[i];
              results.push(decodeDynamoItem(item));
            }
            return results;
          })(),
          count: Count,
          scannedCount: ScannedCount,
          lastEvaluatedKey: LastEvaluatedKey,
          consumedCapacity: ConsumedCapacity
        });
      });
    },
    putItem: function(params) {
      return this.invokeAws("putItem", PutItem.translateParams(params)).then(function(res) {
        return merge(res, {
          item: decodeDynamoItem(res.Attributes)
        });
      });
    },
    deleteItem: function(params) {
      return this.invokeAws("deleteItem", params = DeleteItem.translateParams(params)).then(function(res) {
        return merge(res, {
          item: decodeDynamoItem(res.Attributes)
        });
      });
    },
    getItem: function(params) {
      return this.invokeAws("getItem", GetItem.translateParams(params)).then(function(res) {
        return {
          item: res.Item && decodeDynamoItem(res.Item)
        };
      });
    },
    updateItem: function(params) {
      return this.invokeAws("updateItem", UpdateItem.translateParams(params)).then(function(res) {
        return merge(res, {
          item: decodeDynamoItem(res.Attributes)
        });
      });
    },
    describeTable: function(params) {
      return this.invokeAws("describeTable", TableApiBaseClass.translateParams(params));
    },
    deleteTable: function(params) {
      return this.invokeAws("deleteTable", TableApiBaseClass.translateParams(params));
    },
    waitFor: function(params) {
      return this.invokeAws("waitFor", TableApiBaseClass.translateParams(params));
    },
    getTableChanges: function(newCreateTableParams) {
      var TableName, compareAttribues, compareIndexes;
      TableName = TableApiBaseClass.translateParams(newCreateTableParams).TableName;
      compareIndexes = function(newIndexes, currentIndexes) {
        var toByName;
        toByName = function(indexes) {
          return object(indexes, {
            key: function(index) {
              return index.IndexName;
            },
            "with": function(index) {
              var IndexName, KeySchema, Projection;
              IndexName = index.IndexName, KeySchema = index.KeySchema, Projection = index.Projection;
              return {
                IndexName: IndexName,
                KeySchema: KeySchema,
                Projection: Projection
              };
            }
          });
        };
        return objectDiffReport(toByName(newIndexes), toByName(currentIndexes), eq);
      };
      compareAttribues = function(newAttrs, currentAttrs) {
        var toByName;
        toByName = function(indexes) {
          return object(indexes, {
            key: function(index) {
              return index.AttributeName;
            }
          });
        };
        return objectDiffReport(toByName(newAttrs), toByName(currentAttrs), eq);
      };
      return this.describeTable({
        TableName: TableName
      }).then(function(currentTableDescription) {
        var GlobalSecondaryIndexes, KeySchema, LocalSecondaryIndexes, TableStatus, count, out, ref1;
        ref1 = currentTableDescription.Table, KeySchema = ref1.KeySchema, GlobalSecondaryIndexes = ref1.GlobalSecondaryIndexes, LocalSecondaryIndexes = ref1.LocalSecondaryIndexes, TableStatus = ref1.TableStatus;
        out = {
          KeySchema: compareAttribues(newCreateTableParams.KeySchema, KeySchema),
          GlobalSecondaryIndexes: compareIndexes(newCreateTableParams.GlobalSecondaryIndexes, GlobalSecondaryIndexes),
          LocalSecondaryIndexes: compareIndexes(newCreateTableParams.LocalSecondaryIndexes, LocalSecondaryIndexes)
        };
        count = 0;
        out = object(out, {
          when: function(value) {
            return (value != null) && ++count;
          }
        });
        if (count > 0) {
          out.TableStatus = TableStatus;
          return out;
        } else if (TableStatus !== "ACTIVE") {
          return {
            TableStatus: TableStatus
          };
        } else {
          return "up to date";
        }
      });
    },
    getTableStatus: function(params) {
      var TableName;
      TableName = TableApiBaseClass.translateParams(params).TableName;
      return this.describeTable({
        TableName: TableName
      }).then(function(arg) {
        var currentTableDescription;
        currentTableDescription = arg.Table;
        return {
          TableStatus: currentTableDescription.TableStatus,
          GlobalSecondaryIndexStatus: object(currentTableDescription.GlobalSecondaryIndexes, {
            key: function(index) {
              return index.IndexName;
            },
            "with": function(index) {
              return index.IndexStatus;
            }
          })
        };
      });
    },
    scan: function(params) {
      return this.invokeAws("scan", log("scanParams", TableApiBaseClass.translateParams(params))).then(function(res) {
        var Count, Items, ScannedCount, item;
        Items = res.Items, Count = res.Count, ScannedCount = res.ScannedCount;
        return {
          items: (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = Items.length; i < len; i++) {
              item = Items[i];
              results.push(decodeDynamoItem(item));
            }
            return results;
          })(),
          count: Count,
          scannedCount: ScannedCount
        };
      });
    },

    /*
    Non-table-operations
     */
    listTables: null,
    describeLimits: null,

    /*
    TODO: currently these only support the default DynamoDb API (with promises)
     */
    batchGetItem: null,
    batchWriteItem: null,
    updateTable: null
  });

  return DynamoDb;

})(BaseClass);


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(86);

module.exports.includeInNamespace(__webpack_require__(195)).addModules({
  Common: __webpack_require__(53),
  CreateTable: __webpack_require__(190),
  DeleteItem: __webpack_require__(191),
  GetItem: __webpack_require__(192),
  PutItem: __webpack_require__(193),
  Query: __webpack_require__(194),
  TableApiBaseClass: __webpack_require__(12),
  UpdateItem: __webpack_require__(196)
});


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var StreamlinedDynamoDbApi,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(54)).addNamespace('StreamlinedDynamoDbApi', StreamlinedDynamoDbApi = (function(superClass) {
  extend(StreamlinedDynamoDbApi, superClass);

  function StreamlinedDynamoDbApi() {
    return StreamlinedDynamoDbApi.__super__.constructor.apply(this, arguments);
  }

  return StreamlinedDynamoDbApi;

})(Neptune.PackageNamespace));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var StreamlinedSqsApi, config, findUrlRegExp, log, merge, object, pathJoin, present, ref;

ref = __webpack_require__(0), log = ref.log, findUrlRegExp = ref.findUrlRegExp, object = ref.object, present = ref.present, pathJoin = ref.pathJoin, merge = ref.merge;

config = __webpack_require__(10).config;

module.exports = StreamlinedSqsApi = (function() {
  var doesntStartLowercase, normalizeQueueUrl, removeLowerCaseParams;

  function StreamlinedSqsApi() {}

  StreamlinedSqsApi.normalizeQueueUrl = normalizeQueueUrl = function(queue) {
    var queueUrlPrefix, ref1;
    if (queue == null) {
      queue = config != null ? (ref1 = config.sqs) != null ? ref1.queueUrl : void 0 : void 0;
    }
    if (findUrlRegExp.test(queue)) {
      return queue;
    } else {
      queueUrlPrefix = config.queueUrlPrefix;
      if (!present(queueUrlPrefix)) {
        throw new Error("queue (config.Art.Aws.sqs.queueUrl) or queueUrlPrefix required");
      }
      return pathJoin(queueUrlPrefix, queue.replace(/[^-_a-zA-Z0-9]/g, '-'));
    }
  };

  doesntStartLowercase = /^[^a-z]/;

  removeLowerCaseParams = function(params) {
    return object(params, {
      when: function(v, k) {
        return doesntStartLowercase.test(k);
      }
    });
  };

  StreamlinedSqsApi.sqsCommands = {
    createQueue: {
      preprocess: function(params) {
        var name, visibilityTimeout;
        name = params.name, visibilityTimeout = params.visibilityTimeout;
        return merge(removeLowerCaseParams(params), {
          QueueName: name,
          Attributes: merge(params.Attributes, {
            VisibilityTimeout: visibilityTimeout
          })
        });
      },
      postprocess: function(arg) {
        var QueueUrl;
        QueueUrl = arg.QueueUrl;
        return QueueUrl;
      }
    },
    sendMessage: {
      preprocess: function(params) {
        var body, deduplicationId, delaySeconds, groupId, queue;
        body = params.body, queue = params.queue, delaySeconds = params.delaySeconds, deduplicationId = params.deduplicationId, groupId = params.groupId;
        return merge(removeLowerCaseParams(params), {
          QueueUrl: normalizeQueueUrl(queue),
          MessageBody: body,
          DelaySeconds: delaySeconds,
          MessageDeduplicationId: deduplicationId,
          MessageGroupId: groupId
        });
      },
      postprocess: function(data) {
        var MessageId;
        MessageId = data.MessageId;
        return merge(data, {
          id: MessageId
        });
      }
    },
    receiveMessage: {
      preprocess: function(params) {
        var limit, queue, visibilityTimeout, wait;
        queue = params.queue, visibilityTimeout = params.visibilityTimeout, wait = params.wait, limit = params.limit;
        return merge(removeLowerCaseParams(params), {
          QueueUrl: normalizeQueueUrl(queue),
          MaxNumberOfMessages: limit,
          VisibilityTimeout: visibilityTimeout,
          WaitTimeSeconds: wait != null ? wait : 5
        });
      },
      postprocess: function(data) {
        var Body, MessageId, Messages, ReceiptHandle, i, len, message, ref1, results;
        Messages = data.Messages;
        ref1 = Messages || [];
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          message = ref1[i];
          MessageId = message.MessageId, Body = message.Body, ReceiptHandle = message.ReceiptHandle;
          results.push(merge(message, {
            id: MessageId,
            body: Body,
            receiptHandle: ReceiptHandle
          }));
        }
        return results;
      }
    },
    deleteMessage: {
      preprocess: function(params) {
        var queue, receiptHandle;
        receiptHandle = params.receiptHandle, queue = params.queue;
        return merge(removeLowerCaseParams(params), {
          QueueUrl: normalizeQueueUrl(queue),
          ReceiptHandle: receiptHandle
        });
      }
    },
    listQueues: {
      preprocess: function(params) {
        var QueueNamePrefix;
        QueueNamePrefix = params.QueueNamePrefix;
        return merge(removeLowerCaseParams(params), {
          prefix: QueueNamePrefix
        });
      },
      postprocess: function(arg) {
        var QueueUrls;
        QueueUrls = arg.QueueUrls;
        return QueueUrls;
      }
    },
    purgeQueue: {
      preprocess: function(params) {
        return merge(removeLowerCaseParams(params), {
          QueueUrl: normalizeQueueUrl(params.queue)
        });
      }
    }
  };

  return StreamlinedSqsApi;

})();


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var Client,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(55)).addNamespace('Client', Client = (function(superClass) {
  extend(Client, superClass);

  function Client() {
    return Client.__super__.constructor.apply(this, arguments);
  }

  return Client;

})(Neptune.PackageNamespace));

__webpack_require__(199);


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var Configs,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(55)).addNamespace('Configs', Configs = (function(superClass) {
  extend(Configs, superClass);

  function Configs() {
    return Configs.__super__.constructor.apply(this, arguments);
  }

  return Configs;

})(Neptune.PackageNamespace));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var Pipelines,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(55)).addNamespace('Pipelines', Pipelines = (function(superClass) {
  extend(Pipelines, superClass);

  function Pipelines() {
    return Pipelines.__super__.constructor.apply(this, arguments);
  }

  return Pipelines;

})(Neptune.PackageNamespace));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var clone, concatInto, defineModule, each, formattedInspect, isFunction, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, mergeInto, object, ref, upperCamelCase,
  extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, object = ref.object, upperCamelCase = ref.upperCamelCase, lowerCamelCase = ref.lowerCamelCase, each = ref.each, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, clone = ref.clone, isString = ref.isString, mergeInto = ref.mergeInto, concatInto = ref.concatInto, formattedInspect = ref.formattedInspect, merge = ref.merge;


/*
Todo:
  validatedDeclarable / validatedExtendableProperty
    Which use Art.Validation

TODO:
  When we switch to ES6, we should make the
  class API look identical to the current instance API.

  That means declarable API looks like this:
    @extendableProperty foo: {}

     * extend:
    @foo: hi: 123

  The differnce is we add a ":".

  The benefit is it's a normal getter/setter pair:

    @foo = hi: 123

    log @foo

  The one diference is the "setter" is really an
  "extender"
 */

defineModule(module, function() {
  return function(superClass) {
    var ExtendablePropertyMixin;
    return ExtendablePropertyMixin = (function(superClass1) {
      var arrayPropertyExtender, defaultExtender, getOwnProperty, noOptions, objectPropertyExtender;

      extend1(ExtendablePropertyMixin, superClass1);

      function ExtendablePropertyMixin() {
        return ExtendablePropertyMixin.__super__.constructor.apply(this, arguments);
      }


      /*
      IN
        object: any object
        property: string, property name
        init:
          (object) -> returning initial value for object
          OR
            initial value is computed by:
            clone object[property] || init
      
      EFFECT:
        if object.hasOwnProperty property, return its current value
        otherwise, initialize and return it with init()
       */

      ExtendablePropertyMixin.getOwnProperty = getOwnProperty = function(object, property, init) {
        var ref1;
        if (object.hasOwnProperty(property)) {
          return object[property];
        } else {
          return object[property] = isFunction(init) ? init(object) : clone((ref1 = object[property]) != null ? ref1 : init);
        }
      };


      /*
      objectPropertyExtender
      
      IN: @ is set to the property-value to extend
      
      API 1:
        IN: map
        EFFECT: mergeInto propValue, map
      
      API 2:
        IN: key, value
        EFFECT: propValue[key] = valuee
      
      OUT: ignore
       */

      ExtendablePropertyMixin.objectPropertyExtender = objectPropertyExtender = function(toExtend, mapOrKey, value) {
        if (mapOrKey === void 0 || mapOrKey === null) {
          return toExtend;
        }
        if (isString(mapOrKey)) {
          toExtend[mapOrKey] = value;
        } else if (isPlainObject(mapOrKey)) {
          mergeInto(toExtend, mapOrKey);
        } else {
          log({
            mapOrKey: mapOrKey,
            value: value,
            type: mapOrKey != null ? mapOrKey.constructor : void 0
          });
          throw new Error("first value argument must be a plain object or string: " + (formattedInspect({
            key: mapOrKey,
            value: value
          })));
        }
        return toExtend;
      };


      /*
      arrayPropertyExtender
      
      IN: valueToExtend, value
        value:
          array: concatInto propValue, array
          non-array: propValue.push value
      
      NOTE: if you want to concat an array-as-a-value to the end of propValue, do this:
        arrayPropertyExtender.call propValue, [arrayAsValue]
      
      OUT: ignore
       */

      ExtendablePropertyMixin.arrayPropertyExtender = arrayPropertyExtender = function(toExtend, arrayOrValue) {
        if (isPlainArray(arrayOrValue)) {
          concatInto(toExtend, arrayOrValue);
        } else {
          toExtend.push(arrayOrValue);
        }
        return toExtend;
      };


      /*
      Extendable Properties
      
      EXAMPLE:
        class Foo extends BaseClass
          @extendableProperty foo: {}
      
      Extendable properties work like inheritance:
      
        When any subclass or instance extends an extendable property, they
        inherit a clone of the property from up the inheritance tree, and then
        add their own extensions without effecting the parent copy.
      
        With Object property types, this can just be a parallel prototype chain.
        (It isn't currently: if you modify a parent after extending it to a child,
        the child won't get updates.)
      
        BUT, you can also have array or other types of extend-properties, which
        JavaScript doesn't have any built-in mechanisms for inheriting.
      
      BASIC API:
      @extendableProperty: (map, options) -> ...
      
      IN:
        map: name: defaultValue
        options:
          declarable: true/false
            if true, slightly alters the created functions:
              for: @extendableProperty foo: ...
              generates:
                @foo
      
          extend:
            DEFAULTS:
              switch defaultValue
              when is Object then objectPropertyExtender
              when is Array  then arrayPropetyExtender
              else                defaultExtender
      
            (extendable, extendWithValues...) -> newExtendedOwnPropertyValue
              IN:
                extendable: the current, extended value, already cloned, so direct mutation is OK
                extendWithValues: 1 or more values passed into the extend funtion by the client.
                  Ex: for an array, this is either a single value or an array
                  Ex: for an object, this is either a single object or two args: key, value
              OUT: new property value to set own-property to
              EFFECT:
                Can be pure functional and just return the new, extended data.
                OR
                Can modify extendable directly, since it is an object/array/atomic value unique to the current class/instance.
                  If modifying extendable directly, be sure to return extendable.
                Regardless, the returned value becomes the new extendable prop's value.
      
      
      
      EFFECT: for each {foo: defaultValue} in map, extendableProperty:
        WARNING:
          !!! Don't modify the object returned by a getter !!!
      
          Getters only return the current, most-extended property value. It may not be extended to the
          current subclass or instance! Instead, call @extendFoo() if you wish to manually modify
          the extended property.
      
        declarable:
          getters:
            @getFoo:
            getFoo:
      
          extenders:
            @foo:
            foo:
      
        non-declarable:
      
          getters:
            @getFoo:
            @getter foo:
      
          extenders:
            @foo:
            @extendFoo:
            extendFoo:
      
            IN:
              0-args: nothing happens beyond the standard EFFECT
              1+args: passed to the "extend" function
      
            EFFECT: creates a extension (clone) of the property for the currnet class, subclass or instance
            OUT: the current, extendedPropValue
      
            API 1: IN: 0 args
              NO ADDITIONAL EFFECT - just returns the extended property
            API 2: IN: 1 or more args
              In addition to extending and returning the extended property:
              calls: propExtender extendedPropValue, args...
      
          NOTE: gthe prototype getters call the class getter for extension purposes.
            The result is each instance won't get its own version of the property.
            E.G. Interitance is done at the Class level, not the Instance level.
       */

      defaultExtender = function(toExtend, v) {
        if (v === void 0) {
          throw new Error("not expecting undefined");
        }
        return v;
      };

      noOptions = {};

      ExtendablePropertyMixin.extendableProperty = function(map, options) {
        var declarable, extend, noSetter, oldExtender;
        if (options == null) {
          options = noOptions;
        }
        if (isFunction(oldExtender = options)) {
          log.warn("DEPRICATED customPropertyExtender not supported, use extend: option ");
          options = {
            extend: function() {
              var args, extendable;
              extendable = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
              return oldExtender.apply(extendable, args);
            }
          };
        }
        extend = options.extend, declarable = options.declarable, noSetter = options.noSetter;
        return each(map, (function(_this) {
          return function(defaultValue, name) {
            var extenderName, getterName, instanceExtender, instanceGetter, internalName, propertyExtender, ucProp;
            name = lowerCamelCase(name);
            ucProp = upperCamelCase(name);
            internalName = _this.propInternalName(name);
            getterName = "get" + ucProp;
            extenderName = "extend" + ucProp;
            propertyExtender = (function() {
              if (extend != null) {
                return extend;
              } else if (isPlainObject(defaultValue)) {
                return objectPropertyExtender;
              } else if (isPlainArray(defaultValue)) {
                return arrayPropertyExtender;
              } else {
                if (defaultValue === void 0) {
                  throw new Error("defaultValue must not be undefined");
                }
                return defaultExtender;
              }
            })();
            _this[getterName] = function() {
              var ref1;
              return (ref1 = this.prototype[internalName]) != null ? ref1 : defaultValue;
            };
            _this[name] = _this[extenderName] = function(value) {
              var extendablePropValue;
              extendablePropValue = getOwnProperty(this.prototype, internalName, defaultValue);
              if (arguments.length > 0 && value !== void 0) {
                this.prototype[internalName] = propertyExtender.apply(null, [extendablePropValue].concat(slice.call(arguments)));
              }
              return extendablePropValue;
            };
            instanceGetter = function() {
              var ref1;
              return (ref1 = this[internalName]) != null ? ref1 : defaultValue;
            };
            instanceExtender = _this.prototype[extenderName] = function(value) {
              var extendablePropValue;
              extendablePropValue = getOwnProperty(this, internalName, defaultValue);
              if (arguments.length > 0 && value !== void 0) {
                this[internalName] = propertyExtender.apply(null, [extendablePropValue].concat(slice.call(arguments)));
              }
              return extendablePropValue;
            };
            if (declarable) {
              _this.prototype[getterName] = instanceGetter;
              return _this.prototype[name] = instanceExtender;
            } else {
              if (!noSetter) {
                _this.addSetter(name, instanceExtender);
              }
              return _this.addGetter(name, instanceGetter);
            }
          };
        })(this));
      };

      ExtendablePropertyMixin.declarable = function(map, options) {
        return this.extendableProperty(map, merge(options, {
          declarable: true
        }));
      };

      return ExtendablePropertyMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 92 */
/***/ (function(module, exports) {

var WebpackHotLoader;

module.exports = WebpackHotLoader = (function() {
  function WebpackHotLoader() {}


  /*
  IN:
    _module should be the CommonJS 'module'
    modulePostLoadAction: (moduleState) -> ignored internally, returned from @runHot
  
  OUT: modulePostLoadAction moduleState
  
  EFFECT:
    modulePostLoadAction is run every time the module is loaded.
  
    Initially, moduleState is {}.
  
    moduleState is the same object every load:
      modulePostLoadAction can modify moduleState and it will persist through every reload.
  
    modulePostLoadAction is responsible for any and all
    update actions required due to the module load.
  
  NOTE:
    If _module is not hot, modulePostLoadAction will be invoked once with an empty {}.
   */

  WebpackHotLoader.runHot = function(_module, modulePostLoadAction) {
    var base, moduleState;
    if (!(_module != null ? _module.hot : void 0)) {
      return modulePostLoadAction({});
    }
    moduleState = (((base = _module.hot).data || (base.data = {
      moduleState: {}
    }))).moduleState;
    _module.hot.accept();
    _module.hot.dispose(function(data) {
      return data.moduleState = moduleState;
    });
    return modulePostLoadAction(moduleState);
  };

  return WebpackHotLoader;

})();


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var CommunicationStatus,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(207)).addNamespace('CommunicationStatus', CommunicationStatus = (function(superClass) {
  extend(CommunicationStatus, superClass);

  function CommunicationStatus() {
    return CommunicationStatus.__super__.constructor.apply(this, arguments);
  }

  CommunicationStatus.version = __webpack_require__(288).version;

  return CommunicationStatus;

})(Neptune.PackageNamespace));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ConfigRegistry, Configuration, defineModule, log, merge, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, merge = ref.merge;

BaseObject = __webpack_require__(3).BaseObject;

ConfigRegistry = __webpack_require__(34);

defineModule(module, Configuration = (function(superClass) {
  extend(Configuration, superClass);

  function Configuration() {
    return Configuration.__super__.constructor.apply(this, arguments);
  }

  Configuration.abstractClass();

  Configuration.register = function() {
    return ConfigRegistry.registerConfig(this.getName(), this.getProps());
  };

  Configuration.postCreateConcreteClass = function(arg) {
    var hotReloaded;
    hotReloaded = arg.hotReloaded;
    this.register();
    if (hotReloaded) {
      ConfigRegistry.reload();
    }
    return Configuration.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };

  Configuration.getProps = function() {
    return this.getConcretePrototypeProperties();
  };

  return Configuration;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Lib, Promise, clone, compactFlatten, deepMerge, defineModule, expandPathedProperties, formattedInspect, getEnv, inspect, isPlainObject, isString, jsonParsableRegexp, log, merge, mergeInto, parseQuery, pushIfNotPresent, ref, upperCamelCase;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, inspect = ref.inspect, formattedInspect = ref.formattedInspect, merge = ref.merge, deepMerge = ref.deepMerge, mergeInto = ref.mergeInto, parseQuery = ref.parseQuery, pushIfNotPresent = ref.pushIfNotPresent, isPlainObject = ref.isPlainObject, isString = ref.isString, upperCamelCase = ref.upperCamelCase, expandPathedProperties = ref.expandPathedProperties, clone = ref.clone, compactFlatten = ref.compactFlatten, getEnv = ref.getEnv;

jsonParsableRegexp = /^(\[.*\]|\{.*\}|\".*\"|((-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|true|false|null))$/;

defineModule(module, Lib = (function() {
  var smartJsonDecode;

  function Lib() {}

  Lib.smartJsonDecode = smartJsonDecode = function(value) {
    if (isString(value) && jsonParsableRegexp.test(value)) {
      return JSON.parse(value);
    } else {
      return value != null ? value : null;
    }
  };

  Lib.getExternalEnvironment = function(externalEnvironment) {
    var artConfig, artConfigName, e, k, m, v;
    if (externalEnvironment == null) {
      externalEnvironment = getEnv();
    }
    artConfig = externalEnvironment.artConfig, artConfigName = externalEnvironment.artConfigName;
    artConfig = (function() {
      if (isPlainObject(artConfig)) {
        return artConfig;
      } else if (isString(artConfig)) {
        try {
          return JSON.parse(artConfig);
        } catch (error) {
          e = error;
          log.error("\nInvalid 'artConfig' from externalEnvironment. Must be valid JSON.\n\n" + (formattedInspect({
            externalEnvironment: externalEnvironment
          })) + "\n\nartConfig: " + (formattedInspect(artConfig)) + "\n\nerror: " + e + "\n");
          return null;
        }
      } else {
        return {};
      }
    })();
    for (k in externalEnvironment) {
      v = externalEnvironment[k];
      if (m = k.match(/^artConfig([\._])(.+)$/)) {
        if (m[1] === "_") {
          artConfig[m[2].replace(/_/g, '.')] = smartJsonDecode(v);
        } else {
          artConfig[m[2]] = smartJsonDecode(v);
        }
      }
    }
    return {
      artConfig: artConfig,
      artConfigName: artConfigName
    };
  };


  /*
  normalized:
    map standard aliases (dev and prod)
    upperCamelCase
   */

  Lib.normalizeArtConfigName = function(artConfigName) {
    switch (artConfigName) {
      case "dev":
        return "Development";
      case "prod":
        return "Production";
      default:
        return artConfigName && upperCamelCase(artConfigName);
    }
  };

  return Lib;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ConfigRegistry, Main, Promise, clone, compactFlatten, deepMerge, defineModule, expandPathedProperties, formattedInspect, getExternalEnvironment, inspect, isPlainObject, isString, log, merge, mergeInto, normalizeArtConfigName, parseQuery, pushIfNotPresent, ref, ref1, upperCamelCase,
  slice = [].slice;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, inspect = ref.inspect, formattedInspect = ref.formattedInspect, merge = ref.merge, deepMerge = ref.deepMerge, mergeInto = ref.mergeInto, parseQuery = ref.parseQuery, pushIfNotPresent = ref.pushIfNotPresent, isPlainObject = ref.isPlainObject, isString = ref.isString, upperCamelCase = ref.upperCamelCase, expandPathedProperties = ref.expandPathedProperties, clone = ref.clone, compactFlatten = ref.compactFlatten;

BaseObject = __webpack_require__(3).BaseObject;

ConfigRegistry = __webpack_require__(34);

ref1 = __webpack_require__(95), normalizeArtConfigName = ref1.normalizeArtConfigName, getExternalEnvironment = ref1.getExternalEnvironment;

defineModule(module, Main = (function() {
  var defaultArtConfigName;

  function Main() {}

  Main.artConfigName = defaultArtConfigName = "Development";

  Main.artConfig = {};


  /*
  IN: configureOptions:
    artConfigName: string
      can be passed in:
        as an argument
        via process.env
        via the browser query string
  
      default: "Development"
  
      EFFECT:
        @artConfigName =
          externalEnvironment.artConfigName ||
          artConfigName
  
    artConfig: JSON string OR plain object structure
      can be passed in:
        as an argument
        via process.env
        via the browser query string
  
      default: {}
  
      EFFECT:
        mergeInto @artConfig, deepMerge
          ConfigRegistry.configs[artConfigName]
          global.artConfig
          artConfig
          externalEnvironment.artConfig
  
  EFFECTS:
    callback @artConfig for callback in ConfigRegistry.configurables
  
  Note the priority order of artConfig sources:
  
  Priority:
    #1. externalEnvironment.artConfig
    #2. the artConfig passed into configure
  
  
  EXAMPLES:
     * artConfig = verbose: true
    ConfigRegistry.configure
      verbose: true
  
     * artConfig = verbose: true
     * artConfigName = "Production"
    ConfigRegistry.configure
      artConfigName: "Production"
      verbose: true
  
     * artConfig = verbose: true
     * artConfigName = "Production"
    ConfigRegistry.configure
      artConfigName: "Production"
      artConfig: verbose: true
  
  TEST INPUTS: the second and third inputs are env and
    queryString, and are only there as mocks for testing.
   */

  Main.configure = function() {
    var __testEnv, artConfigArgument, artConfigNameArgument, c, conf, configurable, configureOptions, externalEnvironment, i, len, obj, ref2, ref3, ref4, verbose;
    configureOptions = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    ref2 = Main.configureOptions = deepMerge.apply(null, configureOptions), artConfigNameArgument = ref2.artConfigName, artConfigArgument = ref2.artConfig, __testEnv = ref2.__testEnv;
    externalEnvironment = getExternalEnvironment(__testEnv);
    Main.artConfigName = externalEnvironment.artConfigName || artConfigNameArgument || global.artConfigName;
    Main.artConfigName = normalizeArtConfigName(Main.artConfigName);
    if (Main.artConfigName && !ConfigRegistry.configs[Main.artConfigName]) {
      throw new Error("no config registered with name: " + Main.artConfigName);
    }
    Main.artConfigName || (Main.artConfigName = defaultArtConfigName);
    Neptune.Art.Config.configName = Neptune.Art.configName = Main.artConfigName;
    Neptune.Art.Config.config = Neptune.Art.config = Main.artConfig;
    Main.resetCurrentConfig();
    ref3 = compactFlatten([
      (function() {
        var j, len, ref3, results;
        ref3 = ConfigRegistry.configurables;
        results = [];
        for (j = 0, len = ref3.length; j < len; j++) {
          configurable = ref3[j];
          results.push(configurable.getPathedDefaultConfig());
        }
        return results;
      })(), ConfigRegistry.configs[Main.artConfigName], global.artConfig, artConfigArgument, externalEnvironment.artConfig
    ]);
    for (i = 0, len = ref3.length; i < len; i++) {
      conf = ref3[i];
      expandPathedProperties(conf, Main.artConfig);
    }
    verbose = Main.artConfig.verbose;
    verbose || (verbose = (ref4 = Main.configureOptions) != null ? ref4.verbose : void 0);
    if (verbose) {
      log("------------- ConfigRegistry: inputs");
      log({
        ConfigRegistry: {
          configNames: Object.keys(ConfigRegistry.configs),
          configurables: (function() {
            var j, len1, ref5, results;
            ref5 = ConfigRegistry.configurables;
            results = [];
            for (j = 0, len1 = ref5.length; j < len1; j++) {
              c = ref5[j];
              results.push(c.namespacePath);
            }
            return results;
          })(),
          setConfigName: {
            algorithm: "select LAST non-null",
            inputs: {
              defaultArtConfigName: defaultArtConfigName,
              "global.artConfigName": global.artConfigName,
              "arguments.artConfigName": artConfigNameArgument,
              "environment.artConfigName": externalEnvironment.artConfigName
            }
          },
          setConfig: {
            algorithm: "deep, pathed merge-all, LAST has priority",
            inputs: (
              obj = {
                defaultConfigs: (function() {
                var j, len1, ref5, results;
                ref5 = ConfigRegistry.configurables;
                results = [];
                for (j = 0, len1 = ref5.length; j < len1; j++) {
                  configurable = ref5[j];
                  results.push(configurable.getPathedDefaultConfig());
                }
                return results;
              })()
              },
              obj["configs." + Main.artConfigName] = ConfigRegistry.configs[Main.artConfigName],
              obj["global.artConfig"] = global.artConfig,
              obj["arguments.artConfig"] = artConfigArgument,
              obj["environment.artConfig"] = externalEnvironment.artConfig,
              obj
            )
          }
        }
      });
      log("------------- ConfigRegistry: configuring Configurables...");
    }
    Main._configureAllConfigurables();
    if (verbose) {
      log("------------- ConfigRegistry: configured");
      log({
        Art: {
          configName: Main.artConfigName,
          config: Main.artConfig
        }
      });
      return log("------------- ConfigRegistry: done");
    }
  };

  Main.resetCurrentConfig = function() {
    var k, ref2, results, v;
    ref2 = Main.artConfig;
    results = [];
    for (k in ref2) {
      v = ref2[k];
      results.push(delete Main.artConfig[k]);
    }
    return results;
  };

  Main.reload = function() {
    return Main.configure(Main.configureOptions);
  };

  Main._configureAllConfigurables = function() {
    var configurable, i, len, ref2;
    ref2 = ConfigRegistry.configurables;
    for (i = 0, len = ref2.length; i < len; i++) {
      configurable = ref2[i];
      configurable.configure(this.artConfig);
    }
    return this._notifyConfigurablesConfigured();
  };

  Main._notifyConfigurablesConfigured = function() {
    var configurable, i, len, ref2, results;
    ref2 = ConfigRegistry.configurables;
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      configurable = ref2[i];
      results.push(configurable.configured());
    }
    return results;
  };

  return Main;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(213);


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var Art, EpochedState,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Art = __webpack_require__(214);

module.exports = Art.EpochedState || Art.addNamespace('EpochedState', EpochedState = (function(superClass) {
  extend(EpochedState, superClass);

  function EpochedState() {
    return EpochedState.__super__.constructor.apply(this, arguments);
  }

  return EpochedState;

})(Neptune.Base));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(222);


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Config, Filter, Promise, PusherFilter, Validator, config, cryptoRandomString, deepMerge, defineModule, each, formattedInspect, isFunction, isString, log, m, merge, objectHasKeys, ref, sendChanged,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), log = ref.log, each = ref.each, formattedInspect = ref.formattedInspect, deepMerge = ref.deepMerge, merge = ref.merge, defineModule = ref.defineModule, log = ref.log, Validator = ref.Validator, m = ref.m, isFunction = ref.isFunction, objectHasKeys = ref.objectHasKeys, Promise = ref.Promise, isString = ref.isString, cryptoRandomString = ref.cryptoRandomString;

Filter = __webpack_require__(13).Filter;

config = (Config = __webpack_require__(57)).config;

sendChanged = function(pipeline, key, payload) {
  var channel, pusherEventName, ref1;
  pusherEventName = config.pusherEventName;
  channel = Config.getPusherChannel(pipeline, key);
  if (config.verbose) {
    log({
      sendChanged: {
        channel: channel,
        payload: payload
      }
    });
  }
  return (ref1 = Config.pusherServer) != null ? ref1.trigger(channel, pusherEventName, payload || {}) : void 0;
};

defineModule(module, PusherFilter = (function(superClass) {
  extend(PusherFilter, superClass);

  function PusherFilter() {
    return PusherFilter.__super__.constructor.apply(this, arguments);
  }

  PusherFilter.location("server");

  PusherFilter.after({
    all: function(response) {
      switch (response.type) {
        case "create":
        case "update":
        case "delete":
          break;
        default:
          return response;
      }
      return (isString(response.session.artEryPusherSession) ? Promise.resolve(response) : response.withMergedSession({
        artEryPusherSession: cryptoRandomString(12)
      })).then(function(response) {
        return Promise.then(function() {
          var data, key, payload, pipeline, pipelineName, pipelineQuery, promises, queryName, request, session, type;
          type = response.type, key = response.key, data = response.data, pipelineName = response.pipelineName, request = response.request, pipeline = response.pipeline, session = response.session;
          data = merge(request.data, data, key && pipeline.toKeyObject(key));
          payload = {
            type: type,
            sender: session.artEryPusherSession,
            key: key || pipeline.toKeyString(data)
          };
          if (data.updatedAt) {
            payload.updatedAt = data.updatedAt;
          }
          promises = (function() {
            var ref1, results;
            ref1 = pipeline.queries;
            results = [];
            for (queryName in ref1) {
              pipelineQuery = ref1[queryName];
              if (key = pipelineQuery.toKeyString(data)) {
                results.push(sendChanged(queryName, key, payload));
              } else {
                results.push(void 0);
              }
            }
            return results;
          })();
          if (type !== "create") {
            promises.push(sendChanged(pipeline, data, payload));
          }
          return promises;
        }).then(function() {
          return response;
        });
      });
    }
  });

  return PusherFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Config, Pusher, activeSubscriptions, config, defineModule, log, merge, ref, session,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, log = ref.log, merge = ref.merge;

config = (Config = __webpack_require__(57)).config;

session = __webpack_require__(13).session;

Pusher = __webpack_require__(102);

activeSubscriptions = Pusher.activeSubscriptions = {};

Pusher.logActiveSubscriptions = function() {
  return log({
    activeSubscriptions: Object.keys(activeSubscriptions).sort()
  });
};

defineModule(module, function() {
  return function(superClass) {
    var PusherFluxModelMixin;
    return PusherFluxModelMixin = (function(superClass1) {
      extend(PusherFluxModelMixin, superClass1);

      function PusherFluxModelMixin() {
        this._processPusherChangedEvent = bind(this._processPusherChangedEvent, this);
        PusherFluxModelMixin.__super__.constructor.apply(this, arguments);
        this._channels = {};
        this._listeners = {};
      }

      PusherFluxModelMixin.prototype.fluxStoreEntryUpdated = function(arg) {
        var key, subscribers;
        key = arg.key, subscribers = arg.subscribers;
        if (subscribers.length > 0) {
          this._subscribe(key);
        }
        return PusherFluxModelMixin.__super__.fluxStoreEntryUpdated.apply(this, arguments);
      };

      PusherFluxModelMixin.prototype.fluxStoreEntryRemoved = function(arg) {
        var key;
        key = arg.key;
        this._unsubscribe(key);
        return PusherFluxModelMixin.__super__.fluxStoreEntryRemoved.apply(this, arguments);
      };

      PusherFluxModelMixin.prototype._getPusherChannel = function(key) {
        return Config.getPusherChannel(this.name, key);
      };

      PusherFluxModelMixin.prototype._subscribe = function(key) {
        var base, pusherClient, pusherEventName;
        pusherEventName = config.pusherEventName;
        pusherClient = Config.pusherClient;
        if (!pusherClient) {
          return;
        }
        (base = this._channels)[key] || (base[key] = pusherClient.subscribe(this._getPusherChannel(key)));
        if (!this._listeners[key]) {
          activeSubscriptions[this.name + " " + key] = true;
          return this._channels[key].bind(pusherEventName, this._listeners[key] = (function(_this) {
            return function(pusherData) {
              return _this._processPusherChangedEvent(pusherData, key);
            };
          })(this));
        }
      };

      PusherFluxModelMixin.prototype._unsubscribe = function(key) {
        var pusherClient, pusherEventName, ref1;
        pusherEventName = config.pusherEventName;
        pusherClient = Config.pusherClient;
        if (!(pusherClient && this._channels[key])) {
          return;
        }
        if (this._listeners[key]) {
          if ((ref1 = this._channels[key]) != null) {
            ref1.unbind(pusherEventName, this._listeners[key]);
          }
          delete this._listeners[key];
        }
        delete activeSubscriptions[this.name + " " + key];
        pusherClient.unsubscribe(this._getPusherChannel(key));
        return delete this._channels[key];
      };

      PusherFluxModelMixin.prototype._processPusherChangedEvent = function(event, channelKey) {
        var fluxRecord, key, model, sender, type, updatedAt;
        key = event.key, sender = event.sender, updatedAt = event.updatedAt, type = event.type;
        model = this.recordsModel || this;
        switch (type) {
          case "create":
          case "update":
            if (sender === session.data.artEryPusherSession) {
              log("saved 1 reload due to sender check! (model: " + this.name + ", key: " + key + ")");
              return;
            }
            if ((fluxRecord = model.fluxStoreGet(key)) && fluxRecord.updatedAt >= updatedAt) {
              log("saved 1 reload due to updatedAt check! (model: " + this.name + ", key: " + key + ")");
              return;
            }
            return model.loadPromise(key);
          case "delete":
            model.dataDeleted(key);
            return this.dataDeleted(channelKey, key);
          default:
            return log.error("PusherFluxModelMixin: _processPusherChangedEvent: unsupported type: " + type, {
              event: event
            });
        }
      };

      return PusherFluxModelMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var Pusher,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.EryExtensions.Pusher', Pusher = (function(superClass) {
  extend(Pusher, superClass);

  function Pusher() {
    return Pusher.__super__.constructor.apply(this, arguments);
  }

  Pusher.version = __webpack_require__(291).version;

  return Pusher;

})(Neptune.PackageNamespace));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var DataUpdatesFilter, Filter, Validator, deepMerge, defineModule, each, formattedInspect, isFunction, log, m, merge, objectHasKeys, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), each = ref.each, formattedInspect = ref.formattedInspect, deepMerge = ref.deepMerge, merge = ref.merge, defineModule = ref.defineModule, log = ref.log, Validator = ref.Validator, m = ref.m, isFunction = ref.isFunction, objectHasKeys = ref.objectHasKeys;

Filter = __webpack_require__(9);


/*
A) Populate context.dataUpdates
B) if Neptune.Art.Flux is defined, and this is the root request or resposne
   Perform 'local updates'
 */


/*
TODO:
  Eventually we will want a way to say that some record updates should not be returned client-side.
  First pass
    - data has already gone through the after-pipeline, so any after-filters can removed fields
      the current user can't see. TODO: create privacy filters
    - if data is empty, then don't add it to updates. Nothing to add anyway. DONE
 */

defineModule(module, DataUpdatesFilter = (function(superClass) {
  var getUpdatedUpdates;

  extend(DataUpdatesFilter, superClass);

  DataUpdatesFilter.location("both");

  function DataUpdatesFilter() {
    DataUpdatesFilter.__super__.constructor.apply(this, arguments);
    this.group = "outter";
  }

  getUpdatedUpdates = function(response, fields) {
    var base, field, key, obj, obj1, pipelineName, responseData, type;
    key = response.key, type = response.type, responseData = response.responseData;
    field = (function() {
      if (response.isRootRequest && type === "get") {
        return "dataUpdates";
      } else {
        switch (type) {
          case "create":
          case "update":
            return "dataUpdates";
          case "delete":
            return "dataDeletes";
        }
      }
    })();
    if (field && (responseData || key)) {
      pipelineName = response.pipelineName;
      responseData || (responseData = (typeof (base = response.pipeline).toKeyObject === "function" ? base.toKeyObject(key || responseData) : void 0) || {});
      key || (key = response.pipeline.toKeyString(responseData));
      fields[field] = deepMerge(fields[field], (
        obj = {},
        obj["" + pipelineName] = (
          obj1 = {},
          obj1["" + key] = responseData,
          obj1
        ),
        obj
      ));
    }
    return fields;
  };

  DataUpdatesFilter.after({
    all: function(response) {
      var dataDeletes, dataUpdates, ref1;
      if (response.isRootRequest) {
        if (response.location !== "server" && Neptune.Art.Flux) {
          this.applyFluxUpdates(response);
        }
        if (response.location !== "client") {
          ref1 = response.context, dataUpdates = ref1.dataUpdates, dataDeletes = ref1.dataDeletes;
          return response["with"]({
            props: merge(response.responseProps, {
              dataUpdates: dataUpdates,
              dataDeletes: dataDeletes
            })
          });
        } else {
          return response;
        }
      } else {
        this.addUpdatesToResponse(response);
        return response;
      }
    }
  });

  DataUpdatesFilter.prototype.applyFluxUpdates = function(response) {
    var context, dataDeletes, dataDeletesByKey, dataUpdates, dataUpdatesByKey, model, models, pipelineName, ref1, ref2, ref3, responseProps, results;
    responseProps = response.responseProps, context = response.context;
    dataUpdates = merge(context.dataUpdates, responseProps.dataUpdates);
    dataDeletes = merge(context.dataDeletes, responseProps.dataDeletes);
    ref1 = getUpdatedUpdates(response, {
      dataUpdates: dataUpdates,
      dataDeletes: dataDeletes
    }), dataUpdates = ref1.dataUpdates, dataDeletes = ref1.dataDeletes;
    models = Neptune.Art.Flux.models;
    for (pipelineName in dataUpdates) {
      dataUpdatesByKey = dataUpdates[pipelineName];
      if (isFunction((ref2 = (model = models[pipelineName])) != null ? ref2.dataUpdated : void 0)) {
        each(dataUpdatesByKey, function(data, key) {
          return model.dataUpdated(key, data);
        });
      }
    }
    results = [];
    for (pipelineName in dataDeletes) {
      dataDeletesByKey = dataDeletes[pipelineName];
      if (isFunction((ref3 = (model = models[pipelineName])) != null ? ref3.dataDeleted : void 0)) {
        results.push(each(dataDeletesByKey, function(data, key) {
          return model.dataDeleted(key, data);
        }));
      }
    }
    return results;
  };

  DataUpdatesFilter.prototype.addUpdatesToResponse = function(response) {
    return getUpdatedUpdates(response, response.context);
  };

  return DataUpdatesFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, LinkFieldsFilter, Promise, array, defineModule, each, formattedInspect, isPlainArray, isPlainObject, isString, log, merge, missing, normalizeFieldProps, ref, shallowClone, timeout, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), timeout = ref.timeout, array = ref.array, isPlainObject = ref.isPlainObject, formattedInspect = ref.formattedInspect, each = ref.each, wordsArray = ref.wordsArray, log = ref.log, defineModule = ref.defineModule, merge = ref.merge, isString = ref.isString, shallowClone = ref.shallowClone, isPlainArray = ref.isPlainArray, Promise = ref.Promise;

Filter = __webpack_require__(9);

normalizeFieldProps = __webpack_require__(17).normalizeFieldProps;

missing = __webpack_require__(8).missing;

defineModule(module, LinkFieldsFilter = (function(superClass) {
  var booleanProps;

  extend(LinkFieldsFilter, superClass);

  LinkFieldsFilter.location("server");

  function LinkFieldsFilter(options) {
    var fieldName, fieldProps, fields, props, ref1;
    fields = {};
    this._linkFields = LinkFieldsFilter.normalizeLinkFields(options.fields);
    ref1 = this._linkFields;
    for (fieldName in ref1) {
      fieldProps = ref1[fieldName];
      props = merge(fieldProps, {
        fieldType: "trimmedString"
      });
      delete props.idFieldName;
      fields[fieldProps.idFieldName] = normalizeFieldProps(props);
    }
    LinkFieldsFilter.__super__.constructor.call(this, merge(options, {
      fields: fields
    }));
  }

  LinkFieldsFilter.prototype.preprocessRequest = function(request) {
    var data, pipeline, postIncludeLinkedFieldData, processedData, ref1, session, type;
    type = request.type, pipeline = request.pipeline, data = (ref1 = request.data) != null ? ref1 : {}, session = request.session;

    /*
    Pass includedData from the requestProps to the ultimate responseProps.
    IncludedData is removed from 'data' so it isn't writen in this pipeline's record, but instead,
    if autoCreate/vivifiy is true, it is written to its own pipeline and linked in.
    
    postIncludeLinkedFieldData allows us to return the includedData in the response without
    re-reading the data back with additional requests.
     */
    postIncludeLinkedFieldData = null;
    processedData = merge(data);
    return Promise.all(array(this._linkFields, {
      when: function(arg, fieldName) {
        var idFieldName;
        idFieldName = arg.idFieldName;
        return !data[idFieldName] && data[fieldName];
      },
      "with": (function(_this) {
        return function(arg, fieldName, __, linkedFieldData) {
          var autoCreate, idFieldName, pipelineName;
          idFieldName = arg.idFieldName, autoCreate = arg.autoCreate, pipelineName = arg.pipelineName;
          return Promise.then(function() {
            if (linkedFieldData.id) {
              return linkedFieldData;
            } else if (autoCreate) {
              return request.subrequest(pipelineName, "create", {
                data: linkedFieldData
              });
            } else {
              throw new Error("New record-data provided for " + fieldName + ", but autoCreate is not enabled for this field. " + fieldName + ": " + (formattedInspect(linkedFieldData)));
            }
          }).then(function(linkedFieldData) {
            (postIncludeLinkedFieldData || (postIncludeLinkedFieldData = {}))[fieldName] = linkedFieldData;
            processedData[idFieldName] = linkedFieldData.id;
            return delete processedData[fieldName];
          });
        };
      })(this)
    })).then(function() {
      return request["with"]({
        data: processedData,
        props: merge(request.props, postIncludeLinkedFieldData && {
          postIncludeLinkedFieldData: postIncludeLinkedFieldData
        })
      });
    });
  };

  booleanProps = wordsArray("link required include autoCreate");

  LinkFieldsFilter.normalizeLinkFields = function(linkFields) {
    var lf;
    return each(linkFields, lf = {}, function(fieldProps, fieldName) {
      var autoCreate, include, link, props, ref1, required;
      ref1 = normalizeFieldProps(fieldProps), link = ref1.link, include = ref1.include, required = ref1.required, autoCreate = ref1.autoCreate;
      if (link) {
        lf[fieldName] = props = {
          pipelineName: isString(link) ? link : fieldName,
          idFieldName: fieldName + "Id"
        };
        if (autoCreate) {
          props.autoCreate = true;
        }
        if (include) {
          props.include = true;
        }
        if (required) {
          return props.required = true;
        }
      }
    });
  };

  LinkFieldsFilter.prototype.includeLinkedFields = function(response, data) {
    var fieldName, id, idFieldName, include, linkedData, pipelineName, postIncludeLinkedFieldData, promises, ref1, requestData, requestIncludeProp;
    requestData = response.requestData, (ref1 = response.requestProps, postIncludeLinkedFieldData = ref1.postIncludeLinkedFieldData);
    requestIncludeProp = response.rootRequest.props.include !== false && response.requestProps.include !== false;
    linkedData = shallowClone(data);
    promises = (function() {
      var ref2, ref3, results;
      ref2 = this._linkFields;
      results = [];
      for (fieldName in ref2) {
        ref3 = ref2[fieldName], idFieldName = ref3.idFieldName, pipelineName = ref3.pipelineName, include = ref3.include;
        if (include && (id = linkedData[idFieldName])) {
          results.push((function(_this) {
            return function(fieldName, idFieldName, pipelineName, include) {
              return Promise.then(function() {
                var linkData;
                if (id != null) {
                  if (linkData = (requestData != null ? requestData[fieldName] : void 0) || (postIncludeLinkedFieldData != null ? postIncludeLinkedFieldData[fieldName] : void 0)) {
                    return merge({
                      id: id
                    }, linkData);
                  } else if (requestIncludeProp) {
                    return response.cachedPipelineGet(pipelineName, id);
                  }
                }
              })["catch"](function(response) {
                if (response.status !== missing) {
                  log.error("LinkFieldsFilter: error including " + fieldName + ". " + idFieldName + ": " + id + ". pipelineName: " + pipelineName + ". Error: " + response, response.error);
                }
                return null;
              }).then(function(value) {
                if (value != null) {
                  return linkedData[fieldName] = value;
                }
              });
            };
          })(this)(fieldName, idFieldName, pipelineName, include));
        }
      }
      return results;
    }).call(this);
    return Promise.all(promises).then(function() {
      return linkedData;
    });
  };

  LinkFieldsFilter.before({
    create: function(request) {
      return this.preprocessRequest(request).then((function(_this) {
        return function(request) {
          return _this._validate("validateCreate", request);
        };
      })(this));
    },
    update: function(request) {
      return this.preprocessRequest(request).then((function(_this) {
        return function(request) {
          return _this._validate("validateUpdate", request);
        };
      })(this));
    }
  });

  LinkFieldsFilter.after({
    all: function(response) {
      return response.withTransformedRecords((function(_this) {
        return function(record) {
          return _this.includeLinkedFields(response, record);
        };
      })(this));
    }
  });

  return LinkFieldsFilter;

})(__webpack_require__(59)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, TimestampFilter, Validator, defineModule, log, m, ref, toSeconds,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, Validator = ref.Validator, m = ref.m, toSeconds = ref.toSeconds;

Filter = __webpack_require__(9);

defineModule(module, TimestampFilter = (function(superClass) {
  extend(TimestampFilter, superClass);

  function TimestampFilter() {
    TimestampFilter.__super__.constructor.apply(this, arguments);
    this.group = "outter";
  }

  TimestampFilter.before({
    create: function(request) {
      var now;
      return request.withMergedData(m({
        createdAt: toSeconds(now = Date.now()),
        updatedAt: toSeconds(now)
      }, request.originatedOnServer ? request.data : void 0));
    },
    update: function(request) {
      return request.withMergedData({
        updatedAt: toSeconds(Date.now())
      }, request.originatedOnServer ? request.data : void 0);
    }
  });

  TimestampFilter.fields({
    createdAt: "secondsTimestamp",
    updatedAt: "secondsTimestamp"
  });

  return TimestampFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AfterEventsFilter, DataUpdatesFilter, LinkFieldsFilter, TimestampFilter, Tools, UniqueIdFilter, UserOwnedFilter, ValidationFilter, Validator, defineModule, hasProperties, isFunction, isString, log, normalizeFieldProps, objectWithout, present, ref;

ref = __webpack_require__(2), present = ref.present, defineModule = ref.defineModule, log = ref.log, isString = ref.isString, isFunction = ref.isFunction, Validator = ref.Validator, hasProperties = ref.hasProperties, objectWithout = ref.objectWithout;

UniqueIdFilter = __webpack_require__(107);

TimestampFilter = __webpack_require__(105);

ValidationFilter = __webpack_require__(59);

LinkFieldsFilter = __webpack_require__(104);

UserOwnedFilter = __webpack_require__(108);

AfterEventsFilter = __webpack_require__(58);

DataUpdatesFilter = __webpack_require__(103);

normalizeFieldProps = Validator.normalizeFieldProps;

defineModule(module, Tools = (function() {
  function Tools() {}


  /*
  TODO: I want to refactor "userOwned":
  
    Instead of:
      userOwned: true
  
    I want to specify the owner-field as:
      user: "owner"
  
    That allows the field-name to be customized, but
    more importantly, it makes it look like all the
    other field defs (consistency).
  
    Last, if we treat it as any other field-declaration keyword, we can do:
      user: "include owner"
   */

  Tools.createDatabaseFilters = function(fields, PipelineClass) {
    var addValidationFilter, id, k, link, linkFields, otherFields, uniqueIdProps, userOwned, v;
    if (fields == null) {
      fields = {};
    }
    id = fields.id, userOwned = fields.userOwned;
    if (userOwned) {
      fields.user = "required link";
      if (isString(userOwned)) {
        log.error("DEPRICATED");
        fields.user = fields.user + " " + userOwned;
      }
      fields = objectWithout(fields, "userOwned");
    }
    if (id) {
      uniqueIdProps = id;
      fields = objectWithout(fields, "id");
    }
    linkFields = {};
    otherFields = {};
    addValidationFilter = false;
    for (k in fields) {
      v = fields[k];
      link = (v = normalizeFieldProps(v)).link;
      if (link) {
        linkFields[k] = v;
        otherFields[k] = "object";
      } else {
        addValidationFilter = true;
        otherFields[k] = v;
      }
    }
    return [
      hasProperties(linkFields) ? new LinkFieldsFilter({
        fields: linkFields
      }) : void 0, addValidationFilter ? new ValidationFilter({
        fields: otherFields,
        exclusive: true
      }) : void 0, new AfterEventsFilter, new DataUpdatesFilter, !(present(PipelineClass != null ? PipelineClass._keyFieldsString : void 0) && PipelineClass._keyFieldsString !== "id") ? new UniqueIdFilter(uniqueIdProps) : void 0, new TimestampFilter, userOwned ? new UserOwnedFilter(userOwned) : void 0
    ];
  };

  return Tools;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Crypto, FieldTypes, Filter, UniqueIdFilter, Uuid, ceil, defineModule, isString, log, randomBase62Character, randomString, ref, secret,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), randomBase62Character = ref.randomBase62Character, ceil = ref.ceil, defineModule = ref.defineModule, log = ref.log, randomString = ref.randomString, isString = ref.isString;

Filter = __webpack_require__(9);

Uuid = __webpack_require__(170);

Crypto = __webpack_require__(166);

FieldTypes = __webpack_require__(17).FieldTypes;

secret = randomString();

defineModule(module, UniqueIdFilter = (function(superClass) {

  /*
  choosing bits:
  
    bitsCalc = (maximumExpectedRecordCount, probabilityOfCollisions) ->
      ceil log(maximumExpectedRecordCount / probabilityOfCollisions) / log 2
  
    maximumExpectedRecordCount = 10 ** 12   # 1 trillion
    probabilityOfCollisions = 10 ** -9      # 1 in a billion (9-sigma)
  
    default = bitsCalc 10 ** 12, 10 ** -9   # == 70
  
  NOTE: probabilityOfCollisions means probabilityOfCollisions when you have
    maximumExpectedRecordCount records. The probabily goes down proportionally
    for smaller record counts.
  
  What if I pick bits too small? Greate news!
  
    With backends that accept strings as IDs (like DynamoDb), you can
    always increase the bits later, as your record-set gets bigger.
  
    The new Ids' length will be different from the old ids, and therefor,
    are guaranteed not to collide with them.
   */
  var log2_62, uuid;

  extend(UniqueIdFilter, superClass);

  log2_62 = Math.log(62) / Math.log(2);

  function UniqueIdFilter(options) {
    UniqueIdFilter.__super__.constructor.apply(this, arguments);
    this.bits = (options != null ? options.bits : void 0) || 70;
    if (!(this.bits <= 256)) {
      throw new Error("too many bits: " + this.bits + ". max = 256");
    }
    this.numChars = ceil(this.bits / log2_62);
    this.group = "outter";
  }

  UniqueIdFilter.uuid = uuid = function() {
    return Uuid.v4();
  };


  /*
  Returns a base-62 string consisting of characters: [a-zA-Z0-9]
   */

  UniqueIdFilter.getter({
    compactUniqueId: function() {
      return Crypto.createHmac('sha256', secret).update(uuid()).digest('base64').slice(0, this.numChars).replace(/[\/+=]/g, randomBase62Character);
    }
  });

  UniqueIdFilter.before({
    create: function(request) {
      return request.withMergedData({
        id: (function() {
          var ref1, ref2;
          if (request.originatedOnServer) {
            return ((ref1 = request.data) != null ? ref1.id : void 0) || this.compactUniqueId;
          } else {
            if ((ref2 = request.data) != null ? ref2.id : void 0) {
              throw new Error("specifying an ID for create is not allowed without request.originatedOnServer");
            }
            return this.compactUniqueId;
          }
        }).call(this)
      });
    }
  });

  UniqueIdFilter.fields({
    id: FieldTypes.id
  });

  return UniqueIdFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, Promise, UserOwnedFilter, Validator, defineModule, each, isPlainObject, isString, log, object, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), log = ref.log, object = ref.object, w = ref.w, defineModule = ref.defineModule, isPlainObject = ref.isPlainObject, isString = ref.isString, each = ref.each, Promise = ref.Promise;

Validator = __webpack_require__(17).Validator;

Filter = __webpack_require__(9);

defineModule(module, UserOwnedFilter = (function(superClass) {
  var expandPossiblyLinkedFields, isOwner, normallyPublicFields, ownerOnlyFilter, ownershipInfo, requireCanSetFields;

  extend(UserOwnedFilter, superClass);

  UserOwnedFilter.isOwner = isOwner = function(request, data) {
    var userId;
    userId = request.session.userId;
    data || (data = request.data);
    return userId && userId === (data != null ? data.userId : void 0);
  };

  UserOwnedFilter.ownershipInfo = ownershipInfo = function(request, data) {
    var userId;
    userId = request.session.userId;
    data || (data = request.data);
    return "(you are " + userId + ", record owner is " + (data != null ? data.userId : void 0) + ")";
  };

  function UserOwnedFilter(options) {
    var ref1;
    UserOwnedFilter.__super__.constructor.apply(this, arguments);
    ref1 = options || {}, this.userUpdatableFields = ref1.userUpdatableFields, this.userCreatableFields = ref1.userCreatableFields, this.publicFields = ref1.publicFields;
    this.group = "outter";
  }

  UserOwnedFilter.getter("userUpdatableFields userCreatableFields publicFields");

  normallyPublicFields = w("id userId createdAt updatedAt");

  expandPossiblyLinkedFields = function(fields) {
    var i, len, name, root, value;
    for (value = i = 0, len = fields.length; i < len; value = ++i) {
      name = fields[value];
      if (!(name.match(/Id$/))) {
        continue;
      }
      root = name.split(/Id$/)[0];
      if (fields[root] == null) {
        fields[root] = value;
      }
    }
    return fields;
  };

  UserOwnedFilter.setter({
    publicFields: function(fieldString) {
      var pfs;
      if (fieldString === true) {
        return this._publicFields = true;
      }
      this._publicFields = pfs = isPlainObject(fieldString) ? fieldString : isString(fieldString) ? object(w(fieldString), {
        "with": function() {
          return true;
        }
      }) : {};
      each(normallyPublicFields, function(field) {
        if (pfs[field] !== false) {
          return pfs[field] = true;
        }
      });
      return expandPossiblyLinkedFields(pfs);
    },
    userUpdatableFields: function(fieldString) {
      return this._userUpdatableFields = expandPossiblyLinkedFields(isPlainObject(fieldString) ? fieldString : isString(fieldString) ? object(w(fieldString), {
        "with": function() {
          return true;
        }
      }) : {});
    },
    userCreatableFields: function(fieldString) {
      this._userCreatableFields = expandPossiblyLinkedFields(isPlainObject(fieldString) ? fieldString : isString(fieldString) ? object(w(fieldString), {
        "with": function() {
          return true;
        }
      }) : {});
      return this._userCreatableFields.userId = true;
    }
  });

  UserOwnedFilter.prototype.requireCanSetFields = requireCanSetFields = function(request, allowedFields) {
    var k, ref1, v;
    if (!request.originatedOnServer) {
      ref1 = request.data;
      for (k in ref1) {
        v = ref1[k];
        if (!allowedFields[k]) {
          return Promise.resolve(request.clientFailureNotAuthorized("not allowed to " + request.type + " field: " + k + ". allowedFields: " + (Object.keys(allowedFields).join(', '))));
        }
      }
    }
    return Promise.resolve(request);
  };

  UserOwnedFilter.before({
    create: function(request) {
      var ref1;
      return request.withMergedData({
        userId: ((ref1 = request.data) != null ? ref1.userId : void 0) || request.session.userId
      }).then(function(requestWithUserId) {
        return requestWithUserId.requireServerOriginOr(isOwner(requestWithUserId), "to create a record you do not own " + (ownershipInfo(request)));
      }).then((function(_this) {
        return function(request) {
          return requireCanSetFields(request, _this.userCreatableFields);
        };
      })(this));
    },
    update: ownerOnlyFilter = function(request) {
      var key, ref1;
      key = request.key;
      return request.requireServerOriginOr(!((ref1 = request.data) != null ? ref1.userId : void 0) || isOwner(request), "to change a record's owner " + (ownershipInfo(request))).then(function() {
        if (request.originatedOnServer) {
          return request;
        } else {
          return request.cachedGet(request.pipelineName, key).then(function(currentRecord) {
            return request.requireServerOriginOr(isOwner(request, currentRecord), "to update a record you do not own " + (ownershipInfo(request)));
          });
        }
      }).then((function(_this) {
        return function(request) {
          return requireCanSetFields(request, _this.userUpdatableFields);
        };
      })(this));
    },
    "delete": ownerOnlyFilter
  });

  UserOwnedFilter.after({
    all: function(response) {
      var allowedFields, userId;
      if (response.originatedOnServer || this.publicFields === true) {
        return response;
      }
      userId = response.session.userId;
      allowedFields = this.publicFields;
      return response.withTransformedRecords({
        when: function(record) {
          return response.pipeline.isRecord(record) && record.userId !== userId;
        },
        "with": function(record) {
          var filteredRecord, keyCount;
          keyCount = 0;
          filteredRecord = object(record, {
            when: function(v, k) {
              return allowedFields[k];
            },
            "with": function(v, k) {
              keyCount++;
              return v;
            }
          });
          if (keyCount > 0) {
            return filteredRecord;
          }
        }
      });
    }
  });

  return UserOwnedFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var Filters,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Filters', Filters = (function(superClass) {
  extend(Filters, superClass);

  function Filters() {
    return Filters.__super__.constructor.apply(this, arguments);
  }

  return Filters;

})(Neptune.PackageNamespace));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var array, defineModule, each, formattedInspect, isPlainArray, isPlainObject, isString, log, object, present, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(2), defineModule = ref.defineModule, log = ref.log, present = ref.present, isPlainArray = ref.isPlainArray, isString = ref.isString, isPlainObject = ref.isPlainObject, formattedInspect = ref.formattedInspect, array = ref.array, object = ref.object, each = ref.each;


/*
@primaryKey and @keyFields are synonymous
Usage:

  class MyModel extends KeyFieldsMixin Pipeline # or FluxModel or whatever
     * 1 key
    @primaryKey "foo"
    @keyFields "foo"
    @keyFields ["foo"]

     * 2 keys
    @keyFields "foo/bar"
    @keyFields ["foo", "bar"]

     * 3 keys
    @keyFields "foo/bar/baz"   # compound key with 3 fields
    @keyFields ["foo", "bar', "baz"]

     * Default:
     * @keyFields "id"

Note that order matters. @keyFields is a lists of strings. Forward slash (/) is
used as a delimiter, so it shouldn't be in the names of your key-fields. Ideally
each key field name should match: /[-._a-zA-Z0-9]+/
 */

defineModule(module, function() {
  return function(superClass) {
    var KeyFieldsMixin;
    return KeyFieldsMixin = (function(superClass1) {
      var defaultKeyFieldsString, keyFields;

      extend(KeyFieldsMixin, superClass1);

      function KeyFieldsMixin() {
        return KeyFieldsMixin.__super__.constructor.apply(this, arguments);
      }

      KeyFieldsMixin.getKeyFields = function() {
        return this._keyFields;
      };

      KeyFieldsMixin.getKeyFieldsString = function() {
        return this._keyFieldsString;
      };

      KeyFieldsMixin.primaryKey = keyFields = function(a) {
        if (isString(a)) {
          return this._keyFields = (this._keyFieldsString = a).split("/");
        } else if (isPlainArray(a)) {
          return this._keyFieldsString = (this._keyFields = a).join("/");
        } else {
          throw new Error("invalid value: " + (formattedInspect(a)));
        }
      };

      KeyFieldsMixin.keyFields = keyFields;

      KeyFieldsMixin.getter({
        keyFieldsString: function() {
          return this["class"]._keyFieldsString;
        },
        keyFields: function() {
          return this["class"]._keyFields;
        }
      });

      KeyFieldsMixin.prototype.isRecord = function(data) {
        var j, keyField, len, ref1;
        ref1 = this.keyFields;
        for (j = 0, len = ref1.length; j < len; j++) {
          keyField = ref1[j];
          if (data[keyField] == null) {
            return false;
          }
        }
        return true;
      };

      KeyFieldsMixin.prototype.dataToKeyString = function(a) {
        this.validateKey(a);
        return array(this.keyFields, function(field) {
          return a[field];
        }).join("/");
      };

      KeyFieldsMixin.prototype.toKeyObject = function(a) {
        keyFields = this.keyFields;
        return this.validateKey(isPlainObject(a) ? object(this.keyFields, function(v) {
          return a[v];
        }) : isString(a) ? object(a.split("/"), {
          key: function(v, i) {
            return keyFields[i];
          }
        }) : {});
      };

      KeyFieldsMixin.prototype.dataWithoutKeyFields = function(data) {
        return data && object(data, {
          when: (function(_this) {
            return function(v, k) {
              return !(indexOf.call(_this.keyFields, k) >= 0);
            };
          })(this)
        });
      };

      KeyFieldsMixin.prototype.validateKey = function(key) {
        keyFields = this.keyFields;
        each(keyFields, (function(_this) {
          return function(field) {
            if (!present(key[field])) {
              throw new Error((_this["class"].getName()) + " missing key field(s): " + (formattedInspect({
                missing: field,
                keyFields: keyFields,
                key: key
              })));
            }
          };
        })(this));
        return key;
      };

      KeyFieldsMixin._keyFieldsString = defaultKeyFieldsString = "id";

      KeyFieldsMixin._keyFields = [defaultKeyFieldsString];

      return KeyFieldsMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Filter, Filters, Pipeline, PipelineQuery, PipelineRegistry, Promise, Request, Response, Session, arrayToTruthMap, compactFlatten, config, decapitalize, defineModule, each, escapeRegExp, formattedInspect, inspect, inspectedObjectLiteral, isClass, isFunction, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, mergeInto, missing, normalizeFieldProps, object, peek, pushIfNotPresent, ref, ref1, reverseForEach, success, w,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(0), each = ref.each, object = ref.object, compactFlatten = ref.compactFlatten, BaseObject = ref.BaseObject, reverseForEach = ref.reverseForEach, Promise = ref.Promise, log = ref.log, isPlainObject = ref.isPlainObject, inspect = ref.inspect, isString = ref.isString, isClass = ref.isClass, isFunction = ref.isFunction, inspect = ref.inspect, CommunicationStatus = ref.CommunicationStatus, merge = ref.merge, isPlainArray = ref.isPlainArray, decapitalize = ref.decapitalize, defineModule = ref.defineModule, mergeInto = ref.mergeInto, arrayToTruthMap = ref.arrayToTruthMap, lowerCamelCase = ref.lowerCamelCase, peek = ref.peek, inspectedObjectLiteral = ref.inspectedObjectLiteral, escapeRegExp = ref.escapeRegExp, formattedInspect = ref.formattedInspect, pushIfNotPresent = ref.pushIfNotPresent, w = ref.w;

normalizeFieldProps = __webpack_require__(17).normalizeFieldProps;

ref1 = __webpack_require__(8), success = ref1.success, missing = ref1.missing;

Response = __webpack_require__(62);

Request = __webpack_require__(37);

Filter = __webpack_require__(9);

Session = __webpack_require__(63);

config = __webpack_require__(11).config;

Filters = __webpack_require__(36);

PipelineQuery = __webpack_require__(112);

PipelineRegistry = __webpack_require__(60);


/*
TODO:
  Factor out all flux-related stuff into:
  class FluxReadyPipeline extends Pipeline

  DONT put it in Flux/
    WHY? Server-side, we won't include Flux/
 */

defineModule(module, Pipeline = (function(superClass) {
  var instantiateFilter, noOptions, preprocessFilter;

  extend(Pipeline, superClass);

  Pipeline.register = function() {
    this.singletonClass();
    return PipelineRegistry.register(this);
  };

  Pipeline.abstractClass();

  Pipeline.postCreateConcreteClass = function(arg) {
    var hotReloaded, ref2;
    hotReloaded = arg.hotReloaded;
    if (!hotReloaded) {
      this.register();
    }
    this._defineQueryHandlers();
    this._defineClientHandlerMethods();
    this._initFields();
    if ((ref2 = Neptune.Art.Ery.Flux) != null) {
      ref2.ArtEryFluxModel.createModel(this.getSingleton());
    }
    return Pipeline.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };

  Pipeline.instantiateFilter = instantiateFilter = function(filter) {
    if (isClass(filter)) {
      return new filter;
    } else if (isFunction(filter)) {
      return filter(this);
    } else if (filter instanceof Filter) {
      return filter;
    } else if (isPlainObject(filter)) {
      return new Filter(filter);
    } else {
      throw "invalid filter: " + (inspect(filter)) + " " + (filter instanceof Filter);
    }
  };

  Pipeline.getAliases = function() {
    return this._aliases || {};
  };

  Pipeline.addDatabaseFilters = function(options) {
    return this.filter(Filters.createDatabaseFilters(options, this));
  };

  Pipeline.prototype.toKeyString = function(key) {
    if (key == null) {
      return key;
    }
    if (isString(key)) {
      return key;
    } else if (this.dataToKeyString && isPlainObject(key)) {
      return this.dataToKeyString(key);
    } else {
      throw new Error("override toKeyString or dataToKeyString for non-string-keys like: " + (formattedInspect(key)));
    }
  };

  Pipeline.prototype.isRecord = function(data) {
    return data != null ? data.id : void 0;
  };

  Pipeline.extendableProperty({
    queries: {},
    filters: [],
    handlers: {},
    clientApiMethodList: [],
    fields: {},
    fluxModelMixins: [],
    publicRequestTypes: {}
  });

  Pipeline.publicRequestTypes = function(v) {
    return this.extendPublicRequestTypes(object(w(v), function() {
      return true;
    }));
  };


  /*
  @fluxModelMixin adds a mixin to fluxModelMixins
  
  When createing FluxModels for this pipeline (via ArtEryFluxModel.createModel for example),
  both the records model and each query-model will get these mixins.
  
  Example:
    class MyPipeline extends Pipeline
      @fluxModelMixin FluxModelMixinA
      @fluxModelMixin FluxModelMixinB
  
     * this action
    ArtEryFluxModel.defineModelsForAllPipelines()
  
     * defines this model:
    class MyPipeline extends FluxModelMixinB FluxModelMixinA ArtEryFluxModel
   */

  Pipeline.fluxModelMixin = function(mixin) {
    return this.extendFluxModelMixins(mixin);
  };


  /*
  define a single filter OR an array of filters to define.
  
  NOTE: the order of filter definitions matter:
    last-defined filters FIRST in the before-filter sequence
    last-defined filters LAST in the after-filter sequence
  
    Example request processing sequence:
  
      filterDefinedLast.beforeFilter
        filterDefinedSecond.beforeFilter
          filterDefinedFirst.beforeFilter
            handler
          filterDefinedFirst.afterFilter
        filterDefinedSecond.afterFilter
      filterDefinedLast.afterFilter
  
  IN:
    name: "myFilter"                    # only used for debug purposes
    location: "server"/"client"/"both"  # where the filter will be applied
    before: map:
      requestType: (request) ->
        OUT one of these (or a promise returning one of these):
          request
          - the same request if nothing was filtered
          - a new request with the new, filtered values
  
          response in the form of:
          - new Response
          - null        >> request.missing()
          - string      >> request.success data: message: string
          - plainObject >> request.success data: plainObject
          - plainArray  >> request.success data: plainArray
          NOTE, if a response is returned, it shortcircuits the handler and all other
            filters. The response is returned directly to the caller.
  
    after: map:
      requestType: (response) ->
        OUT: same or new response
           NOTE: all after-filters are applied if the handler generated the first response object
           UNLESS there is an error, in which case the error is returned directly.
   */

  Pipeline.filter = function(filter) {
    return this.extendFilters(preprocessFilter(filter));
  };


  /*
  add one or more handlers
  
  IN map:
    requestType: (request) ->
      IN: ArtEry.Request instance
      OUT:
        ArtEry.Response instance
      OR
        plain data which will be wrapped up in an ArtEry.Response instance
  
  @handler and @handlers are aliases.
   */

  Pipeline.handler = Pipeline.extendHandlers;

  Pipeline.handlers = Pipeline.extendHandlers;

  Pipeline.remoteServer = function(_remoteServer) {
    this._remoteServer = _remoteServer;
  };

  Pipeline.apiRoot = function(_apiRoot) {
    this._apiRoot = _apiRoot;
  };

  Pipeline.tableNamePrefix = function(_tableNamePrefix) {
    this._tableNamePrefix = _tableNamePrefix;
  };


  /*
  declare a query - used by ArtEryFlux
  
  IN: map:
    queryName: map:
      class properties for anonymous subclass of ArtEryQueryFluxModel
  
  queryName is used as both the ArtFlux model-name AND the ArtEry request-type:
    Example:
       * invoke query
      myPipeline.myQueryName key: queryKey
  
       * subscribe to Model in FluxComponent
      @subscriptions
        myQueryName: queryKey
   */

  Pipeline.query = function(map) {
    return this.extendQueries(object(map, function(options, queryName) {
      return new PipelineQuery(queryName, options);
    }));
  };


  /*
  aliases
  
  INPUT: zero or more strings or arrays of strings
    - arbitrary nesting of arrays is OK
    - nulls are OK, they are ignored
  OUTPUT: null
  
  NOTE: @aliases can only be called once
  
  example:
    class Post extends Pipeline
      @aliases "chapterPost"
  
  purpose:
    - used by ArtEryFluxComponent to make model aliases
      (see FluxModel.aliases)
   */

  Pipeline.aliases = function() {
    var map;
    this._aliases = each(arguments, map = {}, function(v, k) {
      return map[lowerCamelCase(v)] = true;
    });
    return this;
  };

  function Pipeline(_options) {
    this._options = _options != null ? _options : {};
    this.getPrefixedTableName = bind(this.getPrefixedTableName, this);
    Pipeline.__super__.constructor.apply(this, arguments);
  }

  Pipeline.prototype.getPrefixedTableName = function(tableName) {
    return "" + this.tableNamePrefix + tableName;
  };

  Pipeline.classGetter({
    pipelineName: function() {
      return this._pipelineName || decapitalize(this.getName());
    }
  });

  Pipeline.prototype.getLogName = function(requestType) {
    return requestType + "-handler";
  };

  Pipeline.getter("options", {
    pipelineName: function() {
      return this["class"].getPipelineName();
    },
    tableNamePrefix: function() {
      return this["class"]._tableNamePrefix || config.tableNamePrefix;
    },
    tableName: function() {
      return this.getPrefixedTableName(this.name);
    },
    normalizedFields: function() {
      var k, nf, ref2, v;
      nf = {};
      ref2 = this.fields;
      for (k in ref2) {
        v = ref2[k];
        nf[k] = normalizeFieldProps(v);
      }
      return nf;
    },
    name: function() {
      return this._name || (this._name = this._options.name || decapitalize(this["class"].getName()));
    },
    session: function() {
      return this._session || (this._session = this._options.session || Session.singleton);
    },
    handlerRequestTypesMap: function(into) {
      if (into == null) {
        into = {};
      }
      mergeInto(into, this.handlers);
      return into;
    },
    filterRequestTypesMap: function(into) {
      var filter, j, len, ref2;
      if (into == null) {
        into = {};
      }
      ref2 = this.filters;
      for (j = 0, len = ref2.length; j < len; j++) {
        filter = ref2[j];
        mergeInto(into, filter.beforeFilters);
      }
      return into;
    },
    requestTypesMap: function(into) {
      if (into == null) {
        into = {};
      }
      return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(into));
    },
    requestTypes: function() {
      return Object.keys(this.requestTypesMap);
    },
    aliases: function() {
      return Object.keys(this["class"].getAliases());
    },
    inspectedObjects: function() {
      return inspectedObjectLiteral(this.name);
    },
    isRemoteClient: function() {
      return !!this.remoteServer;
    },
    apiRoot: function() {
      return this["class"]._apiRoot || config._apiRoot;
    },
    remoteServer: function() {
      return this["class"]._remoteServer || config.remoteServer;
    },
    location: function() {
      if (this.remoteServer && config.location !== "server") {
        return "client";
      } else {
        return config.location;
      }
    },
    restPath: function() {
      return this._restPath || (this._restPath = "/" + config.apiRoot + "/" + this.name);
    },
    restPathRegex: function() {
      return this._restPathRegex || (this._restPathRegex = RegExp("^" + (escapeRegExp(this.restPath)) + "(?:-([a-z0-9_]+))?(?:\\/([^?]+))?(?=\\?|$)", "i"));
    },
    groupedFilters: function() {
      return this._groupedFilters || (this._groupedFilters = Pipeline.groupFilters(this.filters));
    },
    beforeFilters: function() {
      return this._beforeFilters || (this._beforeFilters = this.groupedFilters.slice().reverse());
    },
    afterFilters: function() {
      return this.groupedFilters;
    },
    status: function() {
      return "OK";
    },
    filterChain: function() {
      var filters, i;
      if (this._filterChain) {
        return this._filterChain;
      }
      filters = this.groupedFilters;
      return this._filterChain = (function() {
        var j, ref2;
        if (filters.length > 0) {
          for (i = j = ref2 = filters.length - 2; j >= 0; i = j += -1) {
            filters[i + 1].nextHandler = filters[i];
          }
          filters[0].nextHandler = this;
          return peek(filters);
        } else {
          return this;
        }
      }).call(this);
    }
  });

  Pipeline.groupFilters = function(filters) {
    var filter, group, groupLevel, groupLevels, j, l, len, len1, len2, m, ref2, sortedFilters;
    groupLevels = [];
    for (j = 0, len = filters.length; j < len; j++) {
      group = filters[j].group;
      pushIfNotPresent(groupLevels, group);
    }
    sortedFilters = [];
    ref2 = groupLevels.sort();
    for (l = 0, len1 = ref2.length; l < len1; l++) {
      groupLevel = ref2[l];
      for (m = 0, len2 = filters.length; m < len2; m++) {
        filter = filters[m];
        if (groupLevel === filter.group) {
          sortedFilters.push(filter);
        }
      }
    }
    return sortedFilters;
  };

  Pipeline.prototype.getBeforeFilters = function(request) {
    var filter, j, len, ref2, results;
    ref2 = this.beforeFilters;
    results = [];
    for (j = 0, len = ref2.length; j < len; j++) {
      filter = ref2[j];
      if (filter.getBeforeFilter(request)) {
        results.push(filter);
      }
    }
    return results;
  };

  Pipeline.prototype.getAfterFilters = function(request) {
    var filter, j, len, ref2, results;
    ref2 = this.afterFilters;
    results = [];
    for (j = 0, len = ref2.length; j < len; j++) {
      filter = ref2[j];
      if (filter.getAfterFilter(request)) {
        results.push(filter);
      }
    }
    return results;
  };

  Pipeline.prototype.createRequest = function(type, options) {
    if (isString(options)) {
      options = {
        key: options
      };
    }
    return Promise.resolve(options.session || this.session.loadedDataPromise).then((function(_this) {
      return function(sessionData) {
        return new Request(merge(options, {
          type: type,
          pipeline: _this,
          session: sessionData
        }));
      };
    })(this));
  };

  Pipeline.prototype.getRequestProcessingReport = function(location) {
    if (location == null) {
      location = this.location;
    }
    return object(this.requestTypes, (function(_this) {
      return function(requestType) {
        var filter;
        return compactFlatten([
          (function() {
            var j, len, ref2, results;
            ref2 = this.getBeforeFilters({
              requestType: requestType,
              location: location
            });
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              filter = ref2[j];
              results.push(inspectedObjectLiteral(filter.getName()));
            }
            return results;
          }).call(_this), inspectedObjectLiteral(location === "client" ? "[remote request]" : "[local handler]"), (function() {
            var j, len, ref2, results;
            ref2 = this.getAfterFilters({
              requestType: requestType,
              location: location
            });
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              filter = ref2[j];
              results.push(inspectedObjectLiteral(filter.getName()));
            }
            return results;
          }).call(_this)
        ]);
      };
    })(this));
  };

  Pipeline.getter({
    pipelineReport: function(processingLocation) {
      var out;
      out = {
        tableName: this.tableName,
        fields: object(this.fields, function(fieldProps) {
          return each(Object.keys(fieldProps).sort(), out = {}, function(k) {
            var v;
            v = fieldProps[k];
            if (!isFunction(v)) {
              return out[k] = v;
            }
          });
        })
      };
      if (processingLocation) {
        out[processingLocation + "Processing"] = this.getRequestProcessingReport("client");
      } else {
        out.clientSideRequestProcessing = this.getRequestProcessingReport("client");
        out.serverSideRequestProcessing = this.getRequestProcessingReport("server");
        out.serverlessDevelopmentRequestProcessing = this.getRequestProcessingReport("both");
      }
      return out;
    },
    apiReport: function(options) {
      var publicOnly, server;
      if (options == null) {
        options = {};
      }
      server = options.server, publicOnly = options.publicOnly;
      return object(this.requestTypes, {
        when: publicOnly && (function(_this) {
          return function(type) {
            return _this.getPublicRequestTypes()[type];
          };
        })(this),
        "with": (function(_this) {
          return function(type) {
            var method, obj, ref2, url;
            ref2 = Request.getRestClientParamsForArtEryRequest({
              server: _this.remoteServer || server,
              type: type,
              restPath: _this.restPath
            }), method = ref2.method, url = ref2.url;
            return (
              obj = {},
              obj["" + (method.toLocaleUpperCase())] = url,
              obj
            );
          };
        })(this)
      });
    }
  });

  Pipeline.prototype.handleRequest = function(request) {
    if (request.isResponse) {
      throw new Error("HARD DEPRICATED");
    }
    if (this.location === "client" && this.remoteServer) {
      return request.sendRemoteRequest(this.remoteServer);
    } else {
      return this.applyHandler(request, this.handlers[request.type]).then((function(_this) {
        return function(response) {
          if (!response.isResponse) {
            return response.failure(_this.pipelineName + "." + request.type + " request was not handled");
          } else {
            return response;
          }
        };
      })(this));
    }
  };

  preprocessFilter = function(filter) {
    var f, j, len, results;
    if (isPlainArray(filter)) {
      results = [];
      for (j = 0, len = filter.length; j < len; j++) {
        f = filter[j];
        if (f) {
          results.push(instantiateFilter(f));
        }
      }
      return results;
    } else {
      return instantiateFilter(filter);
    }
  };


  /*
  query handler-functions: (request) -> response or any other value allowed for handlers
   */

  Pipeline._defineQueryHandlers = function() {
    var k, pipelineQuery, ref2, results;
    ref2 = this.getQueries();
    results = [];
    for (k in ref2) {
      pipelineQuery = ref2[k];
      if (!(pipelineQuery instanceof PipelineQuery)) {
        throw new Error("pipelineQuery not a PipelineQuery");
      }
      if (!isFunction(pipelineQuery.query)) {
        throw new Error("pipelineQuery has no query");
      }
      results.push(this.extendHandlers(k, pipelineQuery.query));
    }
    return results;
  };

  Pipeline.prototype._normalizeRequest = function(request) {
    if (isPlainObject(request)) {
      return new Request(merge(request, {
        pipeline: this
      }));
    } else {
      return request;
    }
  };

  Pipeline.prototype._processRequest = function(request) {
    return this.filterChain.handleRequest(request).then(function(response) {
      if (!response.isResponse) {
        log.error({
          "not response!": response
        });
      }
      return response;
    });
  };


  /*
  IN:
    type: request type string
    options:
       * options are passed to new Request
       * options are passed to response.toResponse
  
  OUT: response.toPromise options
    (SEE Response#toPromise for valid options)
  
    With no options, this means:
    promise.then (response.data) ->
       * status == success
  
    promise.catch (errorWithInfo) ->
      {response} = errorWithInfo.info
       * status != success
   */

  noOptions = {};

  Pipeline.prototype._processClientRequest = function(type, options) {
    var returnResponseObject;
    if (options == null) {
      options = noOptions;
    }
    if (isString(options)) {
      options = {
        key: options
      };
    }
    returnResponseObject = options.returnResponseObject;
    return this.createRequest(type, options).then((function(_this) {
      return function(request) {
        return _this._processRequest(request);
      };
    })(this)).then((function(_this) {
      return function(response) {
        return _this._processResponseSession(response);
      };
    })(this)).then((function(_this) {
      return function(response) {
        return response.toPromise(options);
      };
    })(this));
  };

  Pipeline.prototype._processResponseSession = function(response) {
    var session;
    session = response.session;
    if (session) {
      this.session.data = session;
    }
    return response;
  };

  Pipeline._defineClientRequestMethod = function(requestType) {
    var base;
    if (indexOf.call(this.getClientApiMethodList(), requestType) < 0) {
      this.extendClientApiMethodList(requestType);
    }
    return (base = this.prototype)[requestType] || (base[requestType] = function(options) {
      return this._processClientRequest(requestType, options);
    });
  };

  Pipeline._defineClientHandlerMethods = function() {
    var handler, name, ref2, results;
    ref2 = this.getHandlers();
    results = [];
    for (name in ref2) {
      handler = ref2[name];
      results.push(this._defineClientRequestMethod(name));
    }
    return results;
  };

  Pipeline._initFields = function() {
    var filter, j, len, ref2, results;
    ref2 = this.getFilters();
    results = [];
    for (j = 0, len = ref2.length; j < len; j++) {
      filter = ref2[j];
      results.push(this.extendFields(filter.fields));
    }
    return results;
  };

  return Pipeline;

})(__webpack_require__(61)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, PipelineQuery, defineModule, formattedInspect, isFunction, isPlainObject, isString, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, isPlainObject = ref.isPlainObject, log = ref.log, BaseObject = ref.BaseObject, formattedInspect = ref.formattedInspect, isString = ref.isString, isFunction = ref.isFunction;

defineModule(module, PipelineQuery = (function(superClass) {
  extend(PipelineQuery, superClass);

  function PipelineQuery(queryName, options1) {
    var k, ref1, v;
    this.queryName = queryName;
    this.options = options1;
    if (isFunction(this.options)) {
      this.options = {
        query: this.options
      };
    }
    ref1 = this.options;
    for (k in ref1) {
      v = ref1[k];
      this[k] = v;
    }
    if (!(isFunction(this.query) && this.query.length > 0)) {
      throw new Error("query handler-function with at least one argument required. options: " + (formattedInspect(options)));
    }
  }

  PipelineQuery.getter({
    name: function() {
      return this.queryName;
    }
  });

  PipelineQuery.prototype.toKeyString = function(v) {
    if (v == null) {
      return null;
    }
    if (isPlainObject(v) && this.dataToKeyString) {
      return this.dataToKeyString(v);
    } else if (isString(v)) {
      return v;
    } else {
      throw new Error("PipelineQuery: invalid key: " + (formattedInspect(v)));
    }
  };

  return PipelineQuery;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(20);

module.exports.includeInNamespace(__webpack_require__(225)).addModules({
  ArtEryBaseObject: __webpack_require__(35),
  Config: __webpack_require__(11),
  Filter: __webpack_require__(9),
  KeyFieldsMixin: __webpack_require__(110),
  Pipeline: __webpack_require__(111),
  PipelineQuery: __webpack_require__(112),
  PipelineRegistry: __webpack_require__(60),
  Request: __webpack_require__(37),
  RequestHandler: __webpack_require__(61),
  RequestResponseBase: __webpack_require__(38),
  Response: __webpack_require__(62),
  Session: __webpack_require__(63),
  UpdateAfterMixin: __webpack_require__(228)
});

__webpack_require__(36);


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(230);


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var EpochClass, EventEpoch, defineModule, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log;

EpochClass = __webpack_require__(97).EpochClass;

defineModule(module, EventEpoch = (function(superClass) {
  extend(EventEpoch, superClass);

  function EventEpoch() {
    return EventEpoch.__super__.constructor.apply(this, arguments);
  }

  EventEpoch.singletonClass();

  EventEpoch.prototype.queue = function(event) {
    return this.queueItem(event);
  };

  EventEpoch.prototype.logEvent = function(name, id) {};

  return EventEpoch;

})(EpochClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*

TODO:
  handlEvent alternate signature:
    (type, functionReturningEventElement) ->

  The function would only be invoked if there are actually event handlers for the specified type.
 */
var BaseClass, Event, EventManager, Log, arrayWith, clone, defineModule, inspect, isFunction, nextTick, rawErrorLog, ref, throwErrorOutOfStack,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, Log = ref.Log, nextTick = ref.nextTick, isFunction = ref.isFunction, inspect = ref.inspect, clone = ref.clone, arrayWith = ref.arrayWith, throwErrorOutOfStack = ref.throwErrorOutOfStack;

BaseClass = __webpack_require__(3).BaseClass;

Event = __webpack_require__(64);

rawErrorLog = Log.rawErrorLog;

defineModule(module, EventManager = (function(superClass) {
  extend(EventManager, superClass);

  function EventManager(parent) {
    this.parent = parent;
    this.eventHandlers = {};
  }

  EventManager.prototype.hasHandler = function(type) {
    var handlers;
    return !!((handlers = this.eventHandlers[type]) && handlers.length > 0);
  };

  EventManager.prototype.on = function(handlerMap) {
    var action, results, type;
    results = [];
    for (type in handlerMap) {
      action = handlerMap[type];
      if (!(action)) {
        continue;
      }
      if (!isFunction(action)) {
        throw new Error("EventManager: action is not a function for " + (inspect(type)) + " event handler. (action: " + (inspect(action)) + ", parent: " + (inspect(this.parent)) + ")");
      }
      results.push(this.eventHandlers[type] = arrayWith(this.eventHandlers[type], {
        action: action,
        oneTime: false
      }));
    }
    return results;
  };

  EventManager.prototype.removeListeners = function(handlerMap) {
    var action, beforeCount, count, handler, handlers, type;
    count = 0;
    for (type in handlerMap) {
      action = handlerMap[type];
      if (!(handlers = this.eventHandlers[type])) {
        continue;
      }
      beforeCount = handlers.length;
      this.eventHandlers[type] = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = handlers.length; i < len; i++) {
          handler = handlers[i];
          if (handler.action !== action) {
            results.push(handler);
          }
        }
        return results;
      })();
      count = beforeCount - this.eventHandlers[type].length;
    }
    return count;
  };

  EventManager.prototype.onNext = function(handlerMap) {
    var action, base, results, type;
    results = [];
    for (type in handlerMap) {
      action = handlerMap[type];
      if ((base = this.eventHandlers)[type] == null) {
        base[type] = [];
      }
      results.push(this.eventHandlers[type].push({
        action: action,
        oneTime: true
      }));
    }
    return results;
  };

  EventManager.prototype.countOneTimeHandlersFor = function(eventType) {
    var count, handler, handlers, i, len;
    count = 0;
    if (handlers = this.eventHandlers[eventType]) {
      for (i = 0, len = handlers.length; i < len; i++) {
        handler = handlers[i];
        if (handler.oneTime) {
          count++;
        }
      }
    }
    return count;
  };

  EventManager.prototype.handleEvent = function(event) {
    if (typeof event === "string") {
      event = new Event(event);
    }
    return this.sendToHandlers(event.type, event);
  };

  EventManager.prototype.handleEvents = function(events) {
    var event, i, len, results;
    results = [];
    for (i = 0, len = events.length; i < len; i++) {
      event = events[i];
      results.push(this.handleEvent(event));
    }
    return results;
  };

  EventManager.prototype.sendToHandlers = function(eventType, event) {
    var action, error, firedOneTimeHandler, handler, handlers, i, len;
    handlers = this.eventHandlers[eventType];
    if (!(handlers && handlers.length > 0)) {
      return;
    }
    firedOneTimeHandler = false;
    for (i = 0, len = handlers.length; i < len; i++) {
      handler = handlers[i];
      try {
        if (handler.oneTime) {
          handler.remove = firedOneTimeHandler = true;
        }
        action = handler.action;
        action(event);
      } catch (error1) {
        error = error1;
        this.handleErrorInHandler(handler, event, error);
      }
    }
    if (firedOneTimeHandler) {
      return this.eventHandlers[event.type] = (function() {
        var j, len1, ref1, results;
        ref1 = this.eventHandlers[eventType];
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          handler = ref1[j];
          if (!handler.remove) {
            results.push(handler);
          }
        }
        return results;
      }).call(this);
    }
  };

  EventManager.prototype.handleErrorInHandler = function(handler, event, error) {
    if (event.type === "eventException") {
      rawErrorLog("exception in eventException handler.\nEvent:" + (inspect(event, 1)) + ".\n\nError:\n" + error.stack);
      return throwErrorOutOfStack(error);
    } else if (this.eventHandlers["eventException"]) {
      return this.handleEvent(new Event("eventException", {
        event: clone(event),
        exception: error,
        handler: handler
      }));
    } else {
      rawErrorLog("exception in handler AND no eventException handler. Error:");
      rawErrorLog(error);
      rawErrorLog("Event: " + (inspect(event, 1)));
      rawErrorLog("Stack:\n" + error.stack);
      return throwErrorOutOfStack(error);
    }
  };

  return EventManager;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Event, defineModule, eventEpoch, inspect, isFunction, isPlainObject, isString, log, ref, throwErrorOutOfStack,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, isString = ref.isString, isFunction = ref.isFunction, log = ref.log, isPlainObject = ref.isPlainObject, inspect = ref.inspect, throwErrorOutOfStack = ref.throwErrorOutOfStack;

Event = __webpack_require__(64);

eventEpoch = __webpack_require__(115).eventEpoch;


/*
to be used as a mixin via BaseObject's @include method

If this class is included directly, you must also implement the methods
  listed in "TO IMPLEMENT" below.
 */

defineModule(module, function() {
  return function(superClass) {
    var EventedBaseMixin;
    return EventedBaseMixin = (function(superClass1) {
      var typeFromEventOrType;

      extend(EventedBaseMixin, superClass1);

      function EventedBaseMixin() {
        return EventedBaseMixin.__super__.constructor.apply(this, arguments);
      }

      EventedBaseMixin.typeFromEventOrType = typeFromEventOrType = function(eventOrType) {
        return eventOrType && (eventOrType.type || eventOrType);
      };


      /*
      EFFECT: Queues an event to be handled next eventEpoch
      IN:
        eventOrType can be:
         * an instanceof Event or
         * a string representing the "type" of the event
            (a new Event will be created)
      
        eventPropertiesOrCreator can be:
         * null: only if eventOrType is an instanceof Event
         * Object: properties passed into: new Event eventOrType, eventPropertiesOrCreator
         * Function: returns null (indicating a noop) or a new instanceof Event
      
      OUT:
        true:   The event was queued.
        false:  There is no handler for the event. The event was ignored (discarded).
       */

      EventedBaseMixin.prototype.queueEvent = function(eventOrType, eventPropertiesOrCreator) {
        var eventType;
        eventType = typeFromEventOrType(eventOrType);
        if (eventType && this._hasEventHandler(eventType)) {
          eventEpoch.queue((function(_this) {
            return function() {
              return _this.handleEvent(eventOrType, eventPropertiesOrCreator);
            };
          })(this));
          return true;
        } else {
          return false;
        }
      };


      /*
      EFFECT:
        If there is no handler for the specified event-type:
          returns immediately without further processing.
        else
          event is normalized and handled immediately
      
      IN: SEE: normalizeEvent
      
      OUT: true if the event was actually handled
      
      IMPORTANT: This should only be called during an eventEpoch.
        This means:
          Usually, just don't call this directly. Use @queueEvent.
          If you need to call this directly, only do it from within an event handler.
        Examples reasons to call directly:
          - to do custom event routing
          - send a new event triggered from the first
       */

      EventedBaseMixin.prototype.handleEvent = function(eventOrType, eventPropertiesOrCreator) {
        var e, event, eventType;
        eventType = typeFromEventOrType(eventOrType);
        if (!(eventType && this._hasEventHandler(eventType) && (event = this.normalizeEvent(eventOrType, eventPropertiesOrCreator)))) {
          return false;
        }
        event.target = this;
        try {
          this._sendToEventHandler(event);
        } catch (error1) {
          e = error1;
          this._handleErrorInHandler(event, "unknown", e);
        }
        event.target = null;
        return true;
      };


      /*
      IN:
        (event)
          event: Event instance
      
        OR
      
        (eventType, eventPropertiesOrCreator)
          eventType: string
      
          eventPropertiesOrCreator:
            function, invoked immediately:
              () ->
                OUT:
                  event instance
                  OR
                  plain object - passed to Event constructor
            OR
              plain object - passed to Event constructor
            OR
              null
      
      OUT: Event instance or null
       */

      EventedBaseMixin.prototype.normalizeEvent = function(eventOrType, eventPropertiesOrCreator) {
        var e, eventCreator, eventType;
        if (eventOrType instanceof Event) {
          return eventOrType;
        } else {
          if (!isString(eventType = eventOrType)) {
            throw new Error("expected event or event-type-string");
          }
          if (isFunction(eventCreator = eventPropertiesOrCreator)) {
            e = eventCreator();
            switch (false) {
              case !(e instanceof Event):
                return e;
              case !isPlainObject(e):
                return new Event(eventType, e);
              case e == null:
                throw new Error("expecting event or plain-object");
                break;
              default:
                return null;
            }
          } else {
            return new Event(eventType, eventPropertiesOrCreator);
          }
        }
      };


      /*
      inputs: eventType is a string
      outputs: true if there is a handler for the specified type
       */

      EventedBaseMixin.prototype._hasEventHandler = function(eventType) {
        throw new Error("must implement");
      };


      /*
      inputs: an Event object with event.target set to @
      output: ignored
      
      - Called exclusively from handleEvent. Don't call manually.
      - This is where the event handler is actually called.
      - Only called during an eventEpoch.
      - Only called if @_hasEventHandler returned true for event.type
       */

      EventedBaseMixin.prototype._sendToEventHandler = function(event) {
        throw new Error("must implement");
      };

      EventedBaseMixin.prototype._handleErrorInHandler = function(event, handler, error) {
        console.log("EventedObjectBase: exception in handler. Error:", error);
        console.log("Event: " + (inspect(event, 1)));
        console.log("Handler:", handler);
        console.log("Stack:", error.stack);
        return throwErrorOutOfStack(error);
      };

      return EventedBaseMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var EventManager, EventedBaseMixin, defineModule, isFunction, isPlainObject, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, isFunction = ref.isFunction, log = ref.log, isPlainObject = ref.isPlainObject;

EventManager = __webpack_require__(116);

EventedBaseMixin = __webpack_require__(117);

defineModule(module, function() {
  return function(superClass) {
    var EventedMixin;
    return EventedMixin = (function(superClass1) {
      extend(EventedMixin, superClass1);

      function EventedMixin() {
        EventedMixin.__super__.constructor.apply(this, arguments);
        this._eventManager = null;
      }

      EventedMixin.getter({
        eventManager: function() {
          return this._eventManager || (this._eventManager = new EventManager(this));
        }
      });

      EventedMixin.prototype.on = function(handlerMap) {
        return this.eventManager.on(this.preprocessEventHandlers(handlerMap));
      };

      EventedMixin.prototype.onNext = function(handlerMap) {
        return this.eventManager.onNext(handlerMap);
      };

      EventedMixin.prototype.clearEventHandlers = function() {
        return this._eventManager = null;
      };

      EventedMixin.prototype.removeListeners = function(handlerMap) {
        var ref1;
        return (ref1 = this._eventManager) != null ? ref1.removeListeners(handlerMap) : void 0;
      };

      EventedMixin.prototype.preprocessEventHandlers = function(handlerMap) {
        return handlerMap;
      };

      EventedMixin.prototype._sendToEventHandler = function(event) {
        var ref1;
        return (ref1 = this._eventManager) != null ? ref1.handleEvent(event) : void 0;
      };

      EventedMixin.prototype._hasEventHandler = function(eventType) {
        var ref1;
        return (ref1 = this._eventManager) != null ? ref1.hasHandler(eventType) : void 0;
      };

      return EventedMixin;

    })(EventedBaseMixin(superClass));
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var Events,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(231)).addNamespace('Events', Events = (function(superClass) {
  extend(Events, superClass);

  function Events() {
    return Events.__super__.constructor.apply(this, arguments);
  }

  Events.version = __webpack_require__(292).version;

  return Events;

})(Neptune.PackageNamespace));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var DataUri, Promise, StandardLib, binary, isString, readAsDataURL;

StandardLib = __webpack_require__(0);

binary = __webpack_require__(14).binary;

readAsDataURL = __webpack_require__(65).readAsDataURL;

Promise = StandardLib.Promise, isString = StandardLib.isString;

module.exports = DataUri = (function() {
  var isDataUri;

  function DataUri() {}

  DataUri.isDataUri = isDataUri = function(dataString) {
    return isString(dataString) && dataString.slice(0, 5) === "data:";
  };


  /*
  IN: data can be any of
    File: HTML File object is read as ArrayBuffer
    DataURI string: if it is already a data-uri string it is just returned as a successful promise
    any type 'binary' accepts
  
  OUT:
    promise.then (dataUri) ->
    , (errorEventOrErrorObject) ->
   */

  DataUri.toDataUri = function(data) {
    if (!data) {
      throw new Error("data not set");
    }
    if (global.File && data instanceof global.File) {
      return readAsDataURL(data);
    }
    if (isDataUri(data)) {
      return Promise.resolve(data);
    }
    return binary(data).toBase64().then(function(base64) {
      return "data:image/png;base64," + base64;
    });
  };

  return DataUri;

})();


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, Binary, ClassSystem, Stream, binary,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ClassSystem = __webpack_require__(3);

Binary = __webpack_require__(39);

BaseObject = ClassSystem.BaseObject;

binary = __webpack_require__(14).binary;

module.exports = Stream = (function(superClass) {
  extend(Stream, superClass);

  Stream.stream = function(arg) {
    if (arg instanceof Stream) {
      return arg;
    } else if (arg instanceof ArrayBuffer) {
      return Stream.fromArrayBuffer(arg);
    } else if (arg instanceof Uint8Array) {
      return new Stream(arg);
    } else {
      return new Stream(binary(arg).bytes);
    }
  };

  Stream.fromArrayBuffer = function(arrayBuffer) {
    return new Stream(new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));
  };

  function Stream(byteView) {
    this.byteView = byteView;
    this.pos = 0;
  }

  Stream.prototype.readByte = function() {
    return this.byteView[this.pos++];
  };

  Stream.prototype.readAsi = function() {
    var ret, shift, val;
    ret = 0;
    shift = 0;
    val = 128;
    while (val >= 128) {
      val = this.readByte();
      ret += (val % 128) << shift;
      shift += 7;
    }
    return ret;
  };

  Stream.prototype.uint8Array = function() {
    return this.byteView;
  };

  Stream.prototype.read = function(length) {
    var begin, end;
    begin = this.pos;
    this.pos += length;
    end = this.pos;
    return new Stream(this.byteView.subarray(begin, end));
  };

  Stream.prototype.inspect = function() {
    return "{Stream pos=" + this.pos + " byteOffset=" + this.byteView.byteOffset + " length=" + this.byteView.length + "}";
  };

  Stream.prototype.readAsiString = function() {
    return this.read(this.readAsi());
  };

  Stream.prototype.done = function() {
    return this.pos >= this.byteView.length;
  };

  Stream.getter({
    isDone: function() {
      return this.pos >= this.byteView.length;
    },
    binaryString: function() {
      return binary(this.byteView);
    },
    inspectedString: function() {
      return this.binaryString.inspectedString;
    }
  });

  Stream.prototype.toString = function() {
    return this.binaryString.toString();
  };

  return Stream;

})(BaseObject);


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var base, base1, base10, base11, base2, base3, base4, base5, base6, base7, base8, base9, bound, genericSlice, ref, ref1;

bound = __webpack_require__(0).bound;

(base = Uint8Array.prototype).slice || (base.slice = genericSlice = function(start, end) {
  var i, j, length, out, outIndex, ref, ref1;
  if (end == null) {
    end = this.length;
  }
  if (start < 0) {
    start += this.length;
  }
  if (end < 0) {
    end += this.length;
  }
  start = bound(0, start, this.length);
  end = bound(0, end, this.length);
  out = new Uint8Array(length = end - start);
  outIndex = 0;
  for (i = j = ref = start, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
    out[outIndex++] = this[i];
  }
  return out;
});

(base1 = Int8Array.prototype).slice || (base1.slice = genericSlice);

(base2 = Uint8Array.prototype).slice || (base2.slice = genericSlice);

(base3 = Int16Array.prototype).slice || (base3.slice = genericSlice);

(base4 = Uint16Array.prototype).slice || (base4.slice = genericSlice);

(base5 = Int32Array.prototype).slice || (base5.slice = genericSlice);

(base6 = Uint32Array.prototype).slice || (base6.slice = genericSlice);

(base7 = Float32Array.prototype).slice || (base7.slice = genericSlice);

(base8 = Float64Array.prototype).slice || (base8.slice = genericSlice);

if ((ref = self.Uint8ClampedArray) != null) {
  (base9 = ref.prototype).slice || (base9.slice = genericSlice);
}

if ((ref1 = self.CanvasPixelArray) != null) {
  (base10 = ref1.prototype).slice || (base10.slice = genericSlice);
}

(base11 = ArrayBuffer.prototype).slice || (base11.slice = function(start, end) {
  return (new Uint8Array(this)).slice(start, end).buffer;
});


/***/ }),
/* 123 */
/***/ (function(module, exports) {

var Utf8;

module.exports = Utf8 = (function() {
  function Utf8() {}

  Utf8.toBuffer = function(string) {
    return new Uint8Array(this.toArray(string));
  };

  Utf8.toArray = function(string) {
    var char, i, out, uriEncoded;
    uriEncoded = encodeURIComponent(string);
    i = 0;
    out = (function() {
      var results;
      results = [];
      while (i < uriEncoded.length) {
        char = uriEncoded.charCodeAt(i++);
        if (char === 0x25) {
          i += 2;
          results.push(parseInt(uriEncoded.substr(i - 2, 2), 16));
        } else {
          results.push(char);
        }
      }
      return results;
    })();
    return out;
  };

  Utf8.toString = function(a) {
    var error, x, y;
    if (a === void 0) {
      return "<undefined>";
    }
    if (a === null) {
      return "<null>";
    }
    try {
      if (a instanceof ArrayBuffer) {
        a = new Uint8Array(a);
      }
      return decodeURIComponent(((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = a.length; j < len; j++) {
          x = a[j];
          y = x.toString(16);
          if (y.length < 2) {
            y = "0" + y;
          }
          y = "%" + y;
          results.push(y);
        }
        return results;
      })()).join(''));
    } catch (error1) {
      error = error1;
      console.warn(error.toString(), error);
      return "<" + a.length + " binary bytes>";
    }
  };

  return Utf8;

})();


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(39);

module.exports.includeInNamespace(__webpack_require__(235)).addModules({
  BinaryString: __webpack_require__(14),
  DataUri: __webpack_require__(120),
  EncodedImage: __webpack_require__(236),
  File: __webpack_require__(65),
  Stream: __webpack_require__(121),
  TypedarraySlicePolyfill: __webpack_require__(122),
  Utf8: __webpack_require__(123),
  WriteStream: __webpack_require__(237)
});


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var Dom, DomElementFactories, isString;

DomElementFactories = __webpack_require__(126);

isString = __webpack_require__(0).isString;

module.exports = Dom = (function() {
  function Dom() {}

  Dom.createElementFromHtml = function(html) {
    var div;
    div = document.createElement('div');
    div.innerHTML = html;
    return div.firstChild;
  };

  Dom.createDomElementFactories = DomElementFactories.createDomElementFactories;

  Dom.getDevicePixelRatio = function() {
    return ((self.devicePixelRatio != null) && self.devicePixelRatio) || 1;
  };

  Dom.zIndex = function(target, setZIndex) {
    var element, value;
    if (!(target instanceof HTMLElement)) {
      target = document.getElementById(target);
    }
    if (setZIndex !== void 0) {
      return target.style.zIndex = setZIndex;
    }
    element = target;
    while (element && element !== document) {
      switch (element.style.position) {
        case "absolute":
        case "relative":
        case "fixed":
          value = parseInt(element.style.zIndex);
          if (value < 0 || value > 0) {
            return value;
          }
      }
      element = element.parentElement;
    }
    return 0;
  };

  Dom.domElementOffset = function(element) {
    var body, box, clientLeft, clientTop, documentElement, e, left, scrollLeft, scrollTop, top;
    try {
      box = element.getBoundingClientRect();
    } catch (error) {
      e = error;
      return {
        top: 0,
        left: 0
      };
    }
    body = document.body, documentElement = document.documentElement;
    scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;
    scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;
    clientTop = documentElement.clientTop || body.clientTop || 0;
    clientLeft = documentElement.clientLeft || body.clientLeft || 0;
    top = box.top + scrollTop - clientTop;
    left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  };

  return Dom;

})();


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var DomElementFactories, supportLibs,
  slice = [].slice;

supportLibs = [__webpack_require__(0), __webpack_require__(135)];


/*
DomElementFactories allows for Art.React-style creation of DOM elements.

 * HOW TO LOAD:
 * -- IF: you are already using Art.Foundation
Foundation = require 'art-foundation'
{DomElementFactories} = Foundation.Browser

 * -- IF: You have the Art.Foundation NPM but only want DomElementFactories:
DomElementFactories = require 'art-foundation/dom_element_factories'

 * -- IF: You just have dom_element_factories.js
 * first, load it prior via a <script> tag, then:
 * window.DomElementFactories will be set.

Usage:

{Div, Span, B, Em} = DomElementFactories

mySharedTextStyle =
  style:
    fontSize: "16pt"
    color: "#444"
    fontFamily: "Times"

Div
  class: "foo"
  id:    "123"

Span
  class: "dude"
  "This is some really"
  B "bold"
  "text."
  "Also, here is some"
  Em "emphasized"
  "text."

Span mySharedTextStyle,
  internalHTML: "Or you can do <b>this</b> and <em>this</em>."

Div mySharedTextStyle,
  style:
    bottom:          0
    height:          "50px"
    left:            "100px"
    right:           "100px"
    position:        "fixed"
    backgroundColor: "white"
    textAlign:       "center"
  "Styles are easy, too."

VERSION HISTORY:
  1.1.1 - added H2-H6
  1.1.0 - new-lines in text-children become <BR> tags
  1.0.0 - initial
 */

module.exports = DomElementFactories = (function() {
  var isPlainObject, isString, j, k, len, mergeInto, ref, supportLib, v;

  function DomElementFactories() {}

  DomElementFactories.version = "1.1.1";

  DomElementFactories.src = "https://github.com/imikimi/art-foundation";

  for (j = 0, len = supportLibs.length; j < len; j++) {
    supportLib = supportLibs[j];
    for (k in supportLib) {
      v = supportLib[k];
      if (supportLib.hasOwnProperty(k) && k.match(/^[^_]/)) {
        DomElementFactories[k] = v;
      }
    }
  }

  DomElementFactories.isString = isString = function(obj) {
    return typeof obj === "string";
  };

  DomElementFactories.isPlainObject = isPlainObject = function(obj) {
    return obj.constructor === Object;
  };

  DomElementFactories.mergeInto = mergeInto = function(into, source) {
    if (into == null) {
      into = {};
    }
    for (k in source) {
      v = source[k];
      into[k] = v;
    }
    return into;
  };

  DomElementFactories.setDomElementProp = function(element, prop, value, oldValue) {
    var clearStyle, setStyle, style;
    switch (prop) {
      case "class":
        return element.className = value || "";
      case "id":
        return element.id = value || "";
      case "innerHTML":
        return element.innerHTML = value || "";
      case "on":
        if (!isPlainObject(value)) {
          throw new Error("object expected for 'on' property");
        }
        setStyle = function(eventType, newEventListener) {
          return element.addEventListener(eventType, newEventListener);
        };
        clearStyle = function(eventType, oldEventListener) {
          return element.removeEventListner(eventType, oldEventListener);
        };
        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
      case "style":
        if (!isPlainObject(value)) {
          throw new Error("object expected for 'style' property");
        }
        style = element.style;
        setStyle = function(k, v) {
          return style[k] = v;
        };
        clearStyle = function(k) {
          return style[k] = "";
        };
        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
      default:
        return element.setAttribute(prop, value);
    }
  };

  DomElementFactories.setDomElementProps = function(element, props) {
    var results;
    results = [];
    for (k in props) {
      v = props[k];
      results.push(this.setDomElementProp(element, k, v));
    }
    return results;
  };

  DomElementFactories.setDomElementChildren = function(element, children) {
    var child, i, l, len1, message, ref, ref1, ref2, results, text;
    results = [];
    for (l = 0, len1 = children.length; l < len1; l++) {
      child = children[l];
      if (isString(child)) {
        results.push((function() {
          var len2, m, ref, results1;
          ref = child.split("\n");
          results1 = [];
          for (i = m = 0, len2 = ref.length; m < len2; i = ++m) {
            text = ref[i];
            if (i > 0) {
              element.appendChild(document.createElement("br"));
            }
            results1.push(element.appendChild(document.createTextNode(text)));
          }
          return results1;
        })());
      } else {
        if (!(child instanceof Node)) {
          message = "DomElementFactory:" + nodeName + ": Child is not a string or instance of Node. Child: " + child;
          (typeof Neptune !== "undefined" && Neptune !== null ? (ref = Neptune.Art) != null ? (ref1 = ref.Foundation) != null ? (ref2 = ref1.log) != null ? typeof ref2.error === "function" ? ref2.error(message, child) : void 0 : void 0 : void 0 : void 0 : void 0) || console.log(message, child);
          throw new Error(message);
        }
        results.push(element.appendChild(child));
      }
    }
    return results;
  };


  /*
  IN: any combination of arrays and strings
  OUT: All element-names found in all strings are used to generate dom-element-factory-functions
    for elements with those names.
    The output is a plain Object where they keys are the upperCamelCase version of the element-names
    passed in. The values are the element-factories.
   */

  DomElementFactories.createDomElementFactories = function() {
    var list;
    list = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return DomElementFactories.createObjectTreeFactories({
      mergePropsInto: function(into, source) {
        var results;
        results = [];
        for (k in source) {
          v = source[k];
          results.push(into[k] = k === "style" ? mergeInto(into[k], v) : v);
        }
        return results;
      }
    }, list, function(nodeName, props, children) {
      var element;
      element = document.createElement(nodeName);
      DomElementFactories.setDomElementProps(element, props);
      DomElementFactories.setDomElementChildren(element, children);
      return element;
    });
  };

  DomElementFactories.allDomElementNames = "A Abbr Acronym Address Applet Area Article Aside Audio B Base BaseFont Bdi Bdo Big BlockQuote Body Br Button Canvas Caption Center Cite Code Col ColGroup DataList Dd Del Details Dfn Dialog Dir Div Dl Dt Em Embed FieldSet FigCaption Figure Font Footer Form Frame FrameSet H1 H2 H3 H4 H5 H6 Head Header Hr Html I IFrame Img Input Ins Kbd KeyGen Label Legend Li Link Main Map Mark Menu MenuItem Meta Meter Nav NoFrames NoScript Object Ol OptGroup Option Output P Param Pre Progress Q Rp Rt Ruby S Samp Script Section Select Small Source Span Strike Strong Style Sub Summary Sup Table TBody Td TextArea TFoot Th THead Time Title Tr Track Tt U Ul Var Video Wbr";

  ref = DomElementFactories.createDomElementFactories(DomElementFactories.allDomElementNames);
  for (k in ref) {
    v = ref[k];
    DomElementFactories[k] = v;
  }

  return DomElementFactories;

})();


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var Browser,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(41)).addNamespace('Browser', Browser = (function(superClass) {
  extend(Browser, superClass);

  function Browser() {
    return Browser.__super__.constructor.apply(this, arguments);
  }

  return Browser;

})(Neptune.PackageNamespace));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Promise, defineModule, isWebWorker, log, objectKeyCount, ref, workerRpc;

ref = __webpack_require__(0), defineModule = ref.defineModule, Promise = ref.Promise, log = ref.log, objectKeyCount = ref.objectKeyCount;

isWebWorker = __webpack_require__(40).isWebWorker;

workerRpc = __webpack_require__(132).workerRpc;


/*
AsyncLocalStorage defines a consistent API for localStorage across web-workers and the main thread.

API:
  AsyncLocalStorage.
    getItem:    (path)        -> promise.then -> item at path
    setItem:    (path, value) -> promise.then -> success
    removeItem: (path)        -> promise.then -> success
    clear:                    -> promise.then -> success
 */

defineModule(module, function() {
  var AsyncLocalStorage, LocalStorageShimForNode, localStorage;
  localStorage = global.localStorage;
  localStorage || (localStorage = LocalStorageShimForNode = (function() {
    function LocalStorageShimForNode() {}

    LocalStorageShimForNode.store = {};

    LocalStorageShimForNode.getItem = function(k) {
      return LocalStorageShimForNode.store[k];
    };

    LocalStorageShimForNode.setItem = function(k, v) {
      return LocalStorageShimForNode.store[k] = v;
    };

    LocalStorageShimForNode.removeItem = function(k) {
      return delete LocalStorageShimForNode.store[k];
    };

    LocalStorageShimForNode.clear = function() {
      return LocalStorageShimForNode.store = {};
    };

    LocalStorageShimForNode.key = function(i) {
      return Object.keys(LocalStorageShimForNode.store)[i];
    };

    LocalStorageShimForNode.getLength = function() {
      return objectKeyCount(LocalStorageShimForNode.store);
    };

    return LocalStorageShimForNode;

  })());
  if (isWebWorker) {
    return workerRpc.bindWithPromises({
      localStorage: ["getItem", "setItem", "removeItem", "clear", "key"]
    });
  } else {
    workerRpc.register({
      localStorage: localStorage
    });
    return AsyncLocalStorage = (function() {
      function AsyncLocalStorage() {}

      AsyncLocalStorage.getItem = function(path) {
        return Promise.then(function() {
          return localStorage.getItem(path);
        });
      };

      AsyncLocalStorage.setItem = function(path, value) {
        return Promise.then(function() {
          return localStorage.setItem(path, value);
        });
      };

      AsyncLocalStorage.removeItem = function(path) {
        return Promise.then(function() {
          return localStorage.removeItem(path);
        });
      };

      AsyncLocalStorage.clear = function() {
        return Promise.then(function() {
          return localStorage.clear();
        });
      };

      AsyncLocalStorage.key = function(index) {
        return Promise.then(function() {
          return localStorage.key(index);
        });
      };

      AsyncLocalStorage.getLength = function() {
        return Promise.then(function() {
          return localStorage.length;
        });
      };

      return AsyncLocalStorage;

    })();
  }
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var GlobalCounts, StandardLib, currentSecond, isPlainObject, log;

StandardLib = __webpack_require__(0);

isPlainObject = StandardLib.isPlainObject, currentSecond = StandardLib.currentSecond, log = StandardLib.log;

module.exports = GlobalCounts = (function() {
  var globalTime;

  function GlobalCounts() {}

  GlobalCounts.globalCounts = {};

  globalTime = null;

  GlobalCounts.resetGlobalCounts = function() {
    globalTime = currentSecond();
    return GlobalCounts.globalCounts = {};
  };

  GlobalCounts.globalCount = function(name, amount) {
    var k, last, results, v;
    if (amount == null) {
      amount = 1;
    }
    if (isPlainObject(amount)) {
      if (last = GlobalCounts.globalCounts[name]) {
        results = [];
        for (k in amount) {
          v = amount[k];
          results.push(last[k] += v);
        }
        return results;
      } else {
        return GlobalCounts.globalCounts[name] = amount;
      }
    } else {
      return GlobalCounts.globalCounts[name] = (GlobalCounts.globalCounts[name] || 0) + amount;
    }
  };

  GlobalCounts.countStep = function() {
    var nextTime;
    nextTime = currentSecond();
    if (nextTime - globalTime > .002) {
      log.error("GlobalCounts gap");
    }
    globalTime = nextTime;
    return GlobalCounts.globalCount("step");
  };

  return GlobalCounts;

})();


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, ProgressAdapter, Promise, StandardLib, isArray, isFunction, isNumber, log, max, min,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

BaseObject = ClassSystem.BaseObject;

isNumber = StandardLib.isNumber, isFunction = StandardLib.isFunction, isArray = StandardLib.isArray, log = StandardLib.log, max = StandardLib.max, min = StandardLib.min, Promise = StandardLib.Promise;

module.exports = ProgressAdapter = (function(superClass) {
  extend(ProgressAdapter, superClass);


  /*
  IN:
    stepWeights can be a positive integer or an aray of positive, real numbers.
  
      integer N: specifies progress will be made in N even steps from 0 to 1
  
      array of numbers A: specifies progress will be made in A.length steps which
        may not be even. Each step has its own "weight."
  
        Example: stepWeights = [850, 50, 100]
        Will become:
          steps:
            0: 0.00 to 0.85
            1: 0.85 to 0.90
            2: 0.90 to 1.00
  
        Example: stepWeights = [1, 2, 1]
        Will become:
          steps:
            0: 0.00 to 0.25
            1: 0.25 to 0.75
            2: 0.75 to 1.00
  
    progressCallback: progressCallback is a function which is invoked with a number
      between 0 and 1. It is invoked immediatly with 0, then it is invoked by makeProgress()
      and makeProgressCallback()(). It always increments or stays the same. It will
      never go backwards.
   */

  function ProgressAdapter(stepWeights, progressCallback1) {
    this.stepWeights = stepWeights;
    this.progressCallback = progressCallback1;
    if (!(isFunction(this.progressCallback) && (isArray(this.stepWeights) || isNumber(this.stepWeights)))) {
      throw new Error("invalid params");
    }
    this._currentStep = 0;
    this._generateSteps();
    this._currentProgress = 0;
    this._warningCount = 0;
    this.setCurrentProgress(0);
  }

  ProgressAdapter.getter("steps currentStep currentProgress warningCount", {
    currentProgressPercent: function() {
      return (this._currentProgress * 100 | 0) + "%";
    },
    currentProgressBase: function() {
      if (this._currentStep <= 0) {
        return 0;
      } else if (this._currentStep >= this._steps.length) {
        return 1;
      } else {
        return this._steps[this._currentStep];
      }
    }
  });

  ProgressAdapter.setter({
    currentProgress: function(p) {
      return typeof this.progressCallback === "function" ? this.progressCallback(min(1, this._currentProgress = max(p, this._currentProgress))) : void 0;
    }
  });

  ProgressAdapter.prototype.makeProgress = function() {
    this._currentStep++;
    if (this._currentStep > this._steps.length) {
      this._warningCount++;
      console.warn("ProgressAdapter: makeProgress/Callback called too many times!", {
        currentStep: this._currentStep,
        steps: this._steps,
        stepWeights: this.stepWeights
      });
    }
    return this.setCurrentProgress(this.currentProgressBase);
  };

  ProgressAdapter.prototype.makeProgressCallback = function() {
    var rangeEnd, rangeStart;
    this._finishLastProgress();
    rangeStart = this.currentProgressBase;
    this._currentStep++;
    rangeEnd = this.currentProgressBase;
    return (function(_this) {
      return function(progress) {
        return _this.setCurrentProgress(rangeStart + (rangeEnd - rangeStart) * progress);
      };
    })(this);
  };

  ProgressAdapter.prototype._finishLastProgress = function() {
    var progress;
    if (this._currentProgress < (progress = this.currentProgressBase)) {
      return this.setCurrentProgress(progress);
    }
  };

  ProgressAdapter.prototype._executePromiseSequence = function(sequence, lastResult, index, resolve) {
    if (index >= sequence.length) {
      this._finishLastProgress();
      return resolve(lastResult);
    }
    return Promise.resolve(sequence[index](lastResult, this.makeProgressCallback())).then((function(_this) {
      return function(nextResult) {
        return _this._executePromiseSequence(sequence, nextResult, index + 1, resolve);
      };
    })(this));
  };

  ProgressAdapter.prototype.executePromiseSequence = function(sequence) {
    return new Promise((function(_this) {
      return function(resolve) {
        return _this._executePromiseSequence(sequence, null, 0, resolve);
      };
    })(this));
  };


  /*
  IN: (progressCallback, promiseSequence) ->
     * stepWeights implicitly == promiseSequence.length
  IN: (progressCallback, stepWeights, promiseSequence) ->
   */

  ProgressAdapter.executePromiseSequence = function(progressCallback, a, b) {
    var pa, sequence, weights;
    if (b) {
      weights = a;
      sequence = b;
    } else {
      sequence = a;
      weights = sequence.length;
    }
    pa = new ProgressAdapter(weights, progressCallback);
    return pa.executePromiseSequence(sequence);
  };

  ProgressAdapter.prototype._generateSteps = function() {
    var i, j, len, numSteps, ref, s, step, total, w;
    if (isNumber(numSteps = this.stepWeights)) {
      return this._steps = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = numSteps; j < ref; i = j += 1) {
          results.push(i / numSteps);
        }
        return results;
      })();
    } else {
      total = 0;
      ref = this.stepWeights;
      for (j = 0, len = ref.length; j < len; j++) {
        w = ref[j];
        total += w;
      }
      step = 0;
      return this._steps = (function() {
        var k, len1, ref1, results;
        ref1 = this.stepWeights;
        results = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          w = ref1[k];
          s = step;
          step += w / total;
          results.push(s);
        }
        return results;
      }).call(this);
    }
  };

  return ProgressAdapter;

})(BaseObject);


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, SingleObjectTransaction, StandardLib, cloneByStructure, eq, inspect, removeFirstMatch, rubyTrue,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

cloneByStructure = StandardLib.cloneByStructure, removeFirstMatch = StandardLib.removeFirstMatch, eq = StandardLib.eq, inspect = StandardLib.inspect, rubyTrue = StandardLib.rubyTrue;

BaseObject = ClassSystem.BaseObject;

module.exports = SingleObjectTransaction = (function(superClass) {
  var setValues;

  extend(SingleObjectTransaction, superClass);

  function SingleObjectTransaction(a) {
    var options;
    SingleObjectTransaction.__super__.constructor.apply(this, arguments);
    this.object = (function() {
      if (a.constructor === Array) {
        if (a.length !== 2) {
          throw new Error("new SingleObjectTransaction: expected length-2 array like: [obj, optionsMap]");
        }
        this.options = a[1];
        return a[0];
      } else {
        this.options = {};
        return a;
      }
    }).call(this);
    if (this.object == null) {
      throw new Error("object must not be null or undefined");
    }
    this.props = [];
    this.from = {};
    options = this.options;
    if (options.properties) {
      this.addProperties(options.properties);
    }
    if (options.property) {
      this.addProp(options.property);
    }
    if (options.from) {
      this.addFromValues(options.from);
    }
    if (options.to) {
      this.addToValues(options.to);
    }
  }

  SingleObjectTransaction.prototype.toString = function() {
    return (inspect(this.object, 0)) + " from:" + (inspect(this.from, 1)) + " to:" + (inspect(this.to, 1));
  };

  SingleObjectTransaction.prototype.inspect = function(inspector) {
    var i, k, len, ref, results;
    if (!inspector) {
      return ClassSystem.Inspect.inspect(this);
    }
    inspector.put(this.object.classPathName + ":");
    ref = this.props;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      inspector.put("\n    " + k + ": ");
      if (rubyTrue(this.from && this.from[k])) {
        inspector.inspect(this.from[k], 1);
      }
      inspector.put(" ... ");
      if (rubyTrue(this.to && this.to[k])) {
        results.push(inspector.inspect(this.to[k], 1));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  SingleObjectTransaction.getter({
    properties: function() {
      return this.props;
    },
    hasToValues: function() {
      return !!this.to;
    },
    valuesChanged: function() {
      var fromValue, k, ref, toValue;
      ref = this.from;
      for (k in ref) {
        fromValue = ref[k];
        toValue = this.to[k];
        if (!eq(fromValue, toValue)) {
          return true;
        }
      }
      return false;
    }
  });

  SingleObjectTransaction.prototype.addFromValues = function(from) {
    var base, k, v;
    for (k in from) {
      v = from[k];
      this.addProp(k);
      this.from[k] = v;
    }
    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.from) : void 0;
  };

  SingleObjectTransaction.prototype.addToValues = function(to) {
    var base, k, v;
    this.to || (this.to = {});
    for (k in to) {
      v = to[k];
      this.addProp(k);
      this.to[k] = v;
    }
    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.to) : void 0;
  };

  SingleObjectTransaction.prototype.addProperties = function(props) {
    var i, len, prop, results, results1, v;
    if (props.constructor === Array) {
      results = [];
      for (i = 0, len = props.length; i < len; i++) {
        prop = props[i];
        results.push(this.addProp(prop));
      }
      return results;
    } else {
      results1 = [];
      for (prop in props) {
        v = props[prop];
        results1.push(this.addProp(prop));
      }
      return results1;
    }
  };

  SingleObjectTransaction.prototype.addProp = function(propName) {
    if (indexOf.call(this.props, propName) < 0) {
      return this.props.push(propName);
    }
  };

  SingleObjectTransaction.prototype.deleteProp = function(propName) {
    removeFirstMatch(this.props, propName);
    delete this.from[propName];
    return delete this.to[propName];
  };

  SingleObjectTransaction.prototype.saveValues = function(saveTo) {
    var getterName, i, len, metaProperties, prop, ref, ref1, value;
    this.clearOptimizations();
    metaProperties = this.object.metaProperties;
    ref = this.props;
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      if (!saveTo.hasOwnProperty(prop)) {
        value = saveTo[prop] = cloneByStructure((getterName = metaProperties != null ? (ref1 = metaProperties[prop]) != null ? ref1.getterName : void 0 : void 0) ? this.object[getterName]() : this.object[prop]);
      }
    }
    return null;
  };

  SingleObjectTransaction.prototype.saveFromValues = function() {
    return this.saveValues(this.from || (this.from = {}));
  };

  SingleObjectTransaction.prototype.saveToValues = function() {
    return this.saveValues(this.to || (this.to = {}));
  };

  SingleObjectTransaction._setValues = setValues = function(o, values, f) {
    var metaProperties, prop, ref, setterName, v;
    metaProperties = o.metaProperties;
    for (prop in values) {
      v = values[prop];
      if (f) {
        v = f(prop, v);
      }
      if (setterName = metaProperties != null ? (ref = metaProperties[prop]) != null ? ref.setterName : void 0 : void 0) {
        o[setterName](v);
      } else {
        o[prop] = v;
      }
    }
    return null;
  };

  SingleObjectTransaction.prototype.rollBack = function() {
    return setValues(this.object, this.from);
  };

  SingleObjectTransaction.prototype.rollForward = function() {
    return setValues(this.object, this.to);
  };

  SingleObjectTransaction.prototype.clearOptimizations = function() {
    return this.numberDeltas = this.interpolateToObjects = null;
  };

  SingleObjectTransaction.prototype.optimizeInterpolation = function() {
    var field, from, ref, results, to;
    this.numberDeltas = {};
    this.interpolateToObjects = {};
    this.nonInterpolatingFields = {
      to: {},
      from: {}
    };
    ref = this.from;
    results = [];
    for (field in ref) {
      from = ref[field];
      to = this.to[field];
      if (typeof from === "number") {
        results.push(this.numberDeltas[field] = to - from);
      } else if (typeof (from != null ? from.interpolate : void 0) === "function") {
        results.push(this.interpolateToObjects[field] = to);
      } else {
        this.nonInterpolatingFields.from[field] = from;
        results.push(this.nonInterpolatingFields.to[field] = to);
      }
    }
    return results;
  };

  SingleObjectTransaction.prototype.interpolateNumberFields = function(p) {
    return setValues(this.object, this.numberDeltas, (function(_this) {
      return function(field, delta) {
        return _this.from[field] + delta * p;
      };
    })(this));
  };

  SingleObjectTransaction.prototype.interpolateObjectFields = function(p) {
    var e;
    try {
      return setValues(this.object, this.interpolateToObjects, (function(_this) {
        return function(field, toObject) {
          return _this.from[field].interpolate(toObject, p);
        };
      })(this));
    } catch (error) {
      e = error;
      this.log("Art.Foundation.Transaction#interpolateObjectFields(p=" + p + "): error " + e + " deltas: " + (inspect(this.interpolateToObjects)) + " from:   " + (inspect(this.from)) + " to:     " + (inspect(this.to)));
      throw e;
    }
  };

  SingleObjectTransaction.prototype.setNonInterpolatingFields = function(p) {
    return setValues(this.object, this.nonInterpolatingFields[p >= 1 ? "to" : "from"]);
  };

  SingleObjectTransaction.prototype.interpolate = function(p) {
    if (!this.numberDeltas) {
      this.optimizeInterpolation();
    }
    this.interpolateNumberFields(p);
    this.interpolateObjectFields(p);
    return this.setNonInterpolatingFields(p);
  };

  SingleObjectTransaction.getter({
    noChanges: function() {
      return this.props.length === 0;
    }
  });

  SingleObjectTransaction.prototype.optimizeProperties = function() {
    var i, len, prop, ref, results;
    this.clearOptimizations();
    ref = this.props;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      if (!this.from.hasOwnProperty(prop) || !this.to.hasOwnProperty(prop) || eq(this.from[prop], this.to[prop])) {
        results.push(this.deleteProp(prop));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return SingleObjectTransaction;

})(BaseObject);


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, Promise, StandardLib, WebWorker, WorkerRpc, debugPrefix, isFunction, isPlainArray, isString, isWebWorker, log, mergeInto,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

WebWorker = __webpack_require__(40);

Promise = StandardLib.Promise, log = StandardLib.log, isPlainArray = StandardLib.isPlainArray, isFunction = StandardLib.isFunction, isString = StandardLib.isString, mergeInto = StandardLib.mergeInto;

BaseObject = ClassSystem.BaseObject;

isWebWorker = WebWorker.isWebWorker;


/*
WorkerRPC has two modes: singleton and instanced.

SINGLETON:
  Including WorkerRPC automatically creates the singleton instance.
  In a worker, the singleton automatically binds to the worker's self.onmessage and starts listenting.
  In workers or the browser, any handler registered with the singleton will be available to respond
  to any message received by the singleton OR ANY OTHER INSTANCE of WorkerRPC in that thread.
  You can think of the singleton as the global registry for handlers.

In practice:
  In browser:
     * to register all your handlers, call this one or more times:
    WorkerRpc.register ...

     * call for each each worker you want to listen for RPC calls from,
     * and bind any remote procedures you want to be able to invoke on that specific worker-thread
    aBoundWorker = new WorkerRpc worker,
      bind: ...
      bindWithPromises: ...

     * to make remote-procedure-calls to the worker:
     * NOTE: if registered with bindWithPromises, will return a promise for the RPC's result.
    aBoundWorker.MyWorkerNamespace.myWorkerFunction ...

  In worker:
     * to register all your handlers, call this one or more times:
    WorkerRpc.register ...

     * bind any remote procedures you want to be able to invoke on the browser-thread
    WorkerRpc.bind ...
    WorkerRpc.bindWithPromises ...

NOTES:
  registered functions are invoked with @/this set to the namespace. That way you can invoke
  callback functions you previously bound back to the specific worker that invoked the
  function with: @MyWorkerNamespace.myWorkerFunction()

Real world example:

  Suppose you want to access the localStorage object on the browser thread from your worker.
  The 6 lines of code below create the 'self.asyncLocalStorage' object which works just like
  'localStorage' except it returns Art.Foundation.Promises for the function results.

  browser: (before starting the worker)
    {WorkerRpc} = Art.Foundation
    WorkerRpc.register localStorage: localStorage
    new WorkerRpc workerSourcePath

  worker:
    {workerRpc} = Art.Foundation.WorkerRpc
    workerRpc.bindWithPromises localStorage: ["getItem", "setItem", "removeItem", "clear"]
    self.asyncLocalStorage = workerRpc.localStorage

  SBD: Isn't that nice! So streamlined!

General examples:

Usage with no return value expected:
  browser thread:

    new WorkerRpc (new Worker workerUrl),
      register:
        MyMainNamespace:
          doWork: (a) -> ...

  worker thread:

    {MyMainNamespace} = new WorkerRpc self,
      bind:
        MyMainNamespace: ["doWork"]

    MyMainNamespace.doWork myStructuredData

Usage with promises:

  browser thread:

    new WorkerRpc (new Worker workerUrl),
      register:
        MyMainNamespace:
          concatStrings: (a, b) ->
            a + b
             * equivelent to: Promise.resolve a + b
             * if the result is not a Promse, Promise.resolve(result) is automatically applied

  worker thread:

    {MyMainNamespace} = new WorkerRpc self,
      bindWithPromises:
        MyMainNamespace: ["concatStrings"]

    MyMainNamespace.concatStrings "hi ", "Shane"
    .then (result) ->
       * result == "hi Shane"

Usage with arbitrary response messages:

  Sometimes you want a handle to the workerRpc instance for the thread that just send
  you the message inside your registered response functions. You can access that
  via the global: WorkerRpc.lastMessageReceivedFrom.

  browser thread:

    new WorkerRpc (new Worker workerUrl),
      register:
        MyMainNamespace:
          doWorkAndRespond: (key) ->
            count == 0
            invokeThreeTimes =>
              count++
              WorkerRpc.lastMessageReceivedFrom.MyWorkerNamespace.respond key, count

  worker thread:

    {MyMainNamespace} = new WorkerRpc self,
      register:
        MyWorkerNamespace:
          respond: (key, count) -> console.log "MyWorkerNamespace#respond: #{key} #{count}"
      bind:
        MyMainNamespace: ["doWorkAndRespond"]

    MyMainNamespace.doWorkAndRespond "myKey"

Usage - add to global registery:

  WorkerRpc.register
    MyGlobalClass:
      doSomethingNoMatterWhoCalls: ->
        ...
 */

debugPrefix = isWebWorker ? "WorkerRpc(worker)" : "WorkerRpc(browser)";

module.exports = WorkerRpc = (function(superClass) {
  var workerRpcChannelIdString;

  extend(WorkerRpc, superClass);

  WorkerRpc.singletonClass();

  WorkerRpc.workerRpcChannelIdString = workerRpcChannelIdString = "Art.Foundation.WorkerRpcChannel";

  WorkerRpc.register = function(toRegister) {
    return WorkerRpc.singleton.register(toRegister);
  };

  WorkerRpc.bind = function(toBind) {
    return WorkerRpc.singleton._bind(toBind, false);
  };

  WorkerRpc.bindWithPromises = function(toBind) {
    return WorkerRpc.singleton._bind(toBind, true);
  };


  /*
  INPUT:
    thread:
      must implement onmessage= and postMessage or be null
      In a webworker, this gets set to self if it is null.
    options:
      bind: map # invokes: @bind map
      bindWithPromises: map # invokes: @bindWithPromises map
   */

  function WorkerRpc(thread, options) {
    if (isString(thread)) {
      log("WorkerRpc starting worker: " + thread);
      thread = new Worker(thread);
      log("WorkerRpc starting worker: " + thread + ", started?:", thread);
    }
    if (!(thread || self === self.window)) {
      thread = self;
    }
    this._reset();
    this._bindOnmessage(this._thread = thread);
    if (options) {
      this._applyOptions(options);
    }
  }

  WorkerRpc.prototype.register = function(toRegister) {
    var functionMap, namespaceName;
    if (!toRegister) {
      return;
    }
    for (namespaceName in toRegister) {
      functionMap = toRegister[namespaceName];
      if (this._registry.hasOwnProperty(namespaceName)) {
        mergeInto(this._registry[namespaceName], functionMap);
      } else {
        this._registry[namespaceName] = functionMap;
      }
    }
    return this._registry;
  };


  /*
  Creates functions to make specific remote-procedure-calls.
  
  IN:
    toBind: map to arrays of strings
      Each key in the map specifies a namespace.
      The array of strings specify the names of each RPC you want to be able to invoke.
  
  For a given namespaceName and functionName, this binds the function so you can
  invoke it as follows:
    @myNamespaceName.myFunctionName()
  
  The created functions are one-way. They return null as soon as the message has been sent
  to the remote thread. If you want the results, see @bindWithPromises
   */

  WorkerRpc.prototype.bind = function(toBind) {
    return this._bind(toBind, false);
  };


  /*
  Same as @bind except each function created will return a promise which will return
  the results return from the remote procedure call when they are ready.
   */

  WorkerRpc.prototype.bindWithPromises = function(toBind) {
    return this._bind(toBind, true);
  };

  WorkerRpc.prototype._bind = function(toBind, withPromises) {
    var functionName, functionNames, i, len, namespace, namespaceName, ref;
    if (!isFunction((ref = this._thread) != null ? ref.postMessage : void 0)) {
      throw new Error("@_thread.postMessage required for remote requests");
    }
    if (!toBind) {
      return;
    }
    namespace = null;
    for (namespaceName in toBind) {
      functionNames = toBind[namespaceName];
      if (!this.hasOwnProperty(namespaceName)) {
        this[namespaceName] = {};
      }
      namespace = this[namespaceName];
      for (i = 0, len = functionNames.length; i < len; i++) {
        functionName = functionNames[i];
        namespace[functionName] = withPromises ? this._newRemoteRequestFunctionWithPromise(namespaceName, functionName) : this._newRemoteRequestFunction(namespaceName, functionName);
      }
    }
    return namespace;
  };

  WorkerRpc.prototype._reset = function() {
    return this._registry = {
      promiseCallback: {
        success: (function(_this) {
          return function(promiseId, result) {
            return WorkerRpc._resolvePromise(promiseId, result);
          };
        })(this),
        error: (function(_this) {
          return function(promiseId, error) {
            return WorkerRpc._rejectPromise(promiseId, error);
          };
        })(this)
      }
    };
  };

  WorkerRpc.prototype._applyOptions = function(arg) {
    var bind, bindWithPromises, register;
    register = arg.register, bind = arg.bind, bindWithPromises = arg.bindWithPromises;
    this.register(register);
    this.bind(bind);
    this.bindWithPromises(bindWithPromises);
    return this;
  };

  WorkerRpc.prototype._send = function(namespaceName, functionName, promiseId, args) {
    return this._thread.postMessage([workerRpcChannelIdString, namespaceName, functionName, promiseId, args]);
  };

  WorkerRpc.prototype._newRemoteRequestFunctionWithPromise = function(namespaceName, functionName) {
    return (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return WorkerRpc._bindPromise(function(promiseId) {
          return _this._send(namespaceName, functionName, promiseId, args);
        });
      };
    })(this);
  };

  WorkerRpc.prototype._newRemoteRequestFunction = function(namespaceName, functionName) {
    return (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return _this._send(namespaceName, functionName, null, args);
      };
    })(this);
  };

  WorkerRpc.prototype._bindOnmessage = function(thread) {
    var handler;
    if (!thread) {
      return;
    }
    handler = (function(_this) {
      return function(arg) {
        var args, data, functionName, namespaceName, promiseId, testWorkerRpcChannelIdString;
        data = arg.data;
        if (!isPlainArray(data)) {
          return;
        }
        testWorkerRpcChannelIdString = data[0], namespaceName = data[1], functionName = data[2], promiseId = data[3], args = data[4];
        if (testWorkerRpcChannelIdString !== workerRpcChannelIdString) {
          return;
        }
        return _this._invokeLocalFunction(namespaceName, functionName, promiseId, args);
      };
    })(this);
    if (thread.addEventListener) {
      return thread.addEventListener('message', handler);
    } else {
      return thread.onmessage = handler;
    }
  };

  WorkerRpc.prototype._invokeLocalFunction = function(namespaceName, functionName, promiseId, args) {
    var localFunction, namespace, singleton;
    if (!((namespace = this._registry[namespaceName]) && (localFunction = namespace[functionName]))) {
      singleton = WorkerRpc.singleton;
      if (this !== singleton && (namespace = singleton._registry[namespaceName])) {
        localFunction = namespace[functionName];
      }
    }
    if (!localFunction) {
      console.warn(debugPrefix + "_onmessage: could not find: '" + namespaceName + "." + functionName + "'\n\nnamespaces: " + (Object.keys(this._registry).join(', ')) + "\nglobal namespaces: " + (singleton === this ? "(same)" : Object.keys(singleton._registry).join(', ')));
    }
    if (localFunction) {
      WorkerRpc.lastMessageReceivedFrom = this;
      return this._resolveOrRejectRemotePromise(promiseId, localFunction.apply(namespace, args));
    }
  };

  WorkerRpc.prototype._resolveOrRejectRemotePromise = function(promiseId, result) {
    if (promiseId == null) {
      return;
    }
    return Promise.resolve(result).then((function(_this) {
      return function(result) {
        return _this._send("promiseCallback", "success", null, [promiseId, result], function(error) {
          return _this._send("promiseCallback", "error", null, [promiseId, error]);
        });
      };
    })(this));
  };


  /*
  IN:   f: (promiseId) -> ignored
  OUT:  promise
  
  Creates a new promise, addes it to @_promises with a unique id, and invokes f, passing in
  the promise's id.
   */

  WorkerRpc._promises = {};

  WorkerRpc._nextPromiseId = 0;

  WorkerRpc._bindPromise = function(f) {
    var promise, promiseId;
    this._promises[promiseId = this._nextPromiseId++] = promise = Promise.newExternallyResolvable();
    f(promiseId);
    return promise;
  };

  WorkerRpc._resolvePromise = function(promiseId, result) {
    var ref;
    if ((ref = this._promises[promiseId]) != null) {
      ref.resolve(result);
    }
    return delete this._promises[promiseId];
  };

  WorkerRpc._rejectPromise = function(promiseId, error) {
    var ref;
    if ((ref = this._promises[promiseId]) != null) {
      ref.reject(error);
    }
    return delete this._promises[promiseId];
  };

  return WorkerRpc;

})(BaseObject);


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(134);

module.exports.includeInNamespace(__webpack_require__(248)).addModules({
  Analytics: __webpack_require__(243),
  AsyncLocalStorage: __webpack_require__(128),
  BatchLoader: __webpack_require__(244),
  GlobalCounts: __webpack_require__(129),
  InstanceFunctionBindingMixin: __webpack_require__(245),
  JsonStore: __webpack_require__(246),
  ProgressAdapter: __webpack_require__(130),
  SingleObjectTransaction: __webpack_require__(131),
  Stat: __webpack_require__(247),
  Transaction: __webpack_require__(249),
  WebWorker: __webpack_require__(40),
  WorkerRpc: __webpack_require__(132)
});


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var Tools,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(41)).addNamespace('Tools', Tools = (function(superClass) {
  extend(Tools, superClass);

  function Tools() {
    return Tools.__super__.constructor.apply(this, arguments);
  }

  return Tools;

})(Neptune.PackageNamespace));


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(252);


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var AsyncExtensions, Promise;

Promise = __webpack_require__(29);

module.exports = AsyncExtensions = (function() {
  var timeout;

  function AsyncExtensions() {}

  AsyncExtensions.timeout = timeout = function(ms, f) {
    return new Promise(function(resolve) {
      return setTimeout(function() {
        if (typeof f === "function") {
          f();
        }
        return resolve();
      }, ms);
    });
  };

  AsyncExtensions.requestAnimationFrame = self.requestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || self.msRequestAnimationFrame || function(f) {
    return setTimeout(f, 1000 / 60);
  };

  AsyncExtensions.nextTick = function(f) {
    return Promise.resolve().then(function() {
      return typeof f === "function" ? f() : void 0;
    });
  };

  AsyncExtensions.throwErrorOutOfStack = function(e) {
    console.log(e);
    return timeout(0, function() {
      throw e;
    });
  };

  AsyncExtensions.evalAndThrowErrorsOutOfStack = function(f) {
    var e;
    try {
      return f();
    } catch (error) {
      e = error;
      Neptune.Art.StandardLib.log.error("evalAndThrowErrorsOutOfStack", e);
      return AsyncExtensions.throwErrorOutOfStack(e);
    }
  };

  return AsyncExtensions;

})();


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {


/*
This current iteration of clone relies on some singleton variables shared across all invocations of clone.
This is fine as long as javascript stays single-threaded.
It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

FUTURE
A potentially better solution would be to create a new closer each time clone is called at the top-most level,
but when recursing, pass in a new function bound to that closure which is different from the global clone function.

populateClone would need to take an additional argument - the clone function to use for recursive cloning.
 */
var Clone, Map, Unique, byProperties, byStructure, clonedMap, inspect, topObject, uniquePropertyName;

Map = __webpack_require__(46);

Unique = __webpack_require__(71);

inspect = __webpack_require__(23).inspect;

uniquePropertyName = Unique.PropertyName;

clonedMap = null;

byStructure = false;

byProperties = false;

topObject = null;

module.exports = Clone = (function() {
  var clone, cloneArray, cloneByProperties, cloneByStructure, cloneObject, emptyClone;

  function Clone() {}

  cloneArray = function(array) {
    var clonedArray, i, index, len, value;
    clonedMap.set(array, clonedArray = array.slice());
    for (index = i = 0, len = clonedArray.length; i < len; index = ++i) {
      value = clonedArray[index];
      clonedArray[index] = clone(value);
    }
    return clonedArray;
  };

  cloneObject = function(obj) {
    var clonedObject, k, v;
    clonedMap.set(obj, clonedObject = emptyClone(obj));
    if ((obj !== topObject || !byProperties) && obj.populateClone) {
      obj.populateClone(clonedObject);
    } else {
      for (k in obj) {
        v = obj[k];
        clonedObject[k] = clone(v);
      }
    }
    return clonedObject;
  };

  Clone.emptyClone = emptyClone = function(obj) {
    if (obj.constructor === Array) {
      return [];
    } else {
      return Object.create(Object.getPrototypeOf(obj));
    }
  };

  Clone.clone = clone = function(obj, mode) {
    var clonedObject, got;
    switch (mode) {
      case "byStructure":
        byStructure = true;
        break;
      case "byProperties":
        byProperties = true;
    }
    if (obj === null || obj === void 0 || typeof obj !== "object") {
      return obj;
    }
    if (byStructure && (obj.constructor !== Array && obj.constructor !== Object)) {
      return obj;
    }
    if (clonedMap) {
      if (got = clonedMap.get(obj)) {
        return got;
      }
    } else {
      topObject = obj;
      clonedMap = new Map;
    }
    clonedObject = obj.constructor === Array ? cloneArray(obj) : cloneObject(obj);
    if (topObject === obj) {
      byStructure = false;
      byProperties = false;
      topObject = null;
      clonedMap = null;
    }
    return clonedObject;
  };

  Clone.cloneByProperties = cloneByProperties = function(obj) {
    return clone(obj, "byProperties");
  };

  Clone.cloneByStructure = cloneByStructure = function(obj) {
    return clone(obj, "byStructure");
  };

  return Clone;

})();


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var Merge, compactFlatten, isPlainObject;

compactFlatten = __webpack_require__(43).compactFlatten;

isPlainObject = __webpack_require__(26).isPlainObject;

module.exports = Merge = (function() {
  var deepMerge, merge, mergeInto, pureMerge;

  function Merge() {}


  /*
  
  merge "flattens" its arguments and then adds all keys from all objects in
  the list into a new object which is returned.
  
  return: new object
  
  The first object's keys are added first. If two or more objects have the same
  keys, the value set in the result is the last object's in the list with that key.
   */

  Merge.merge = merge = function() {
    return mergeInto({}, arguments);
  };


  /*
  The same as 'merge' with one difference:
  
  Instead of a new object, all objects are merged into the first object in the list.
  
  return: first object in the flattened list
  return: null if no source objects
   */

  Merge.mergeInto = mergeInto = function() {
    var j, k, len, result, source, sources, v;
    sources = compactFlatten(arguments);
    if (sources.length === 0) {
      return null;
    }
    result = sources[0] || {};
    for (j = 0, len = sources.length; j < len; j++) {
      source = sources[j];
      if (source !== result) {
        for (k in source) {
          v = source[k];
          if (v !== void 0) {
            result[k] = v;
          }
        }
      }
    }
    return result;
  };


  /*
  Just like mergeInfo except only merge into the result object
  UNLESS 'result' already has that property with a non-undefined value.
  
  if
    mergeInfo a, b is just like merge a, b except it modifies and returns a instead of returning a new object
  then
    mergeIntoUnless b, a is just like merge a, b except it modifies and returns b instead of returning a new object
  
  Note: mergeIntoUnless a, b, c, d, e, f is like merge f, e, d, c, b, a
   */

  Merge.mergeIntoUnless = function() {
    var i, j, k, ref, result, source, sources, v;
    sources = compactFlatten(arguments);
    if (sources.length === 0) {
      return null;
    }
    result = sources[0] || {};
    for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
      source = sources[i];
      for (k in source) {
        v = source[k];
        if (result[k] === void 0) {
          result[k] = v;
        }
      }
    }
    return result;
  };

  Merge.deepMerge = deepMerge = function() {
    var k, list, out, v, val;
    list = compactFlatten(arguments);
    out = merge(list);
    for (k in out) {
      v = out[k];
      if (isPlainObject(v)) {
        out[k] = deepMerge((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = list.length; j < len; j++) {
            val = list[j];
            results.push(val[k]);
          }
          return results;
        })());
      }
    }
    return out;
  };

  Merge.hasAllProps = function(o1, o2) {
    var k, v;
    for (k in o1) {
      v = o1[k];
      if (!o2.hasOwnProperty(k)) {
        return false;
      }
    }
    return true;
  };

  Merge.pureMerge = pureMerge = function() {
    var j, last, len, source, sources;
    sources = compactFlatten(arguments);
    if (sources.length === 0) {
      return null;
    }
    if (sources.length === 1) {
      return sources[0];
    }
    last = sources[sources.length - 1];
    for (j = 0, len = sources.length; j < len; j++) {
      source = sources[j];
      if (source !== last) {
        if (!Merge.hasAllProps(source, last)) {
          return Merge.merge(sources);
        }
      }
    }
    return last;
  };


  /*
  I might consider adding "o" - which works like Object-Tree constructors:
    First, it compact-flattens args
    Second, it gathers up and merges all plain-objects in its arguments list
    Last, all remaining items get added to the "children" list
  The question is, what does it return? Options:
  
    OPTION: If only plain-objects after compact-flatten, just return the merged object ELSE:
  
  Options if both objects and non-object values are present:
    a. return compactFlatten [plainObject, nonObjectValues]
    b. return merge plainObject, children: nonObjectValues
    c. return new MClass plainObject, nonObjectValues
      class MClass extends BaseObject
        @properties "props children"
        constructor: (@props, @children) ->
   */

  Merge.m = pureMerge;

  return Merge;

})();


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var StringCase, compactFlatten;

compactFlatten = __webpack_require__(43).compactFlatten;

module.exports = StringCase = (function() {
  function StringCase() {}

  StringCase.getCodeWords = function(str) {
    var _words, word, words;
    _words = str.match(/[a-zA-Z][a-zA-Z0-9]*|[0-9]+/g);
    if (!_words) {
      return [];
    }
    words = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = _words.length; i < len; i++) {
        word = _words[i];
        results.push(word.match(/(?:[A-Z]{2,}(?![a-z]))|[A-Z][a-z0-9]*|[a-z0-9]+/g));
      }
      return results;
    })();
    return compactFlatten(words);
  };

  StringCase.lowerCase = function(str) {
    return str != null ? str.toLocaleLowerCase() : void 0;
  };

  StringCase.upperCase = function(str) {
    return str != null ? str.toLocaleUpperCase() : void 0;
  };

  StringCase.capitalize = function(str) {
    return StringCase.upperCase(str.charAt(0)) + str.slice(1);
  };

  StringCase.decapitalize = function(str) {
    return StringCase.lowerCase(str.charAt(0)) + str.slice(1);
  };

  StringCase.getLowerCaseCodeWords = function(str) {
    var i, len, ref, results, word;
    ref = StringCase.getCodeWords(str);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      word = ref[i];
      results.push(StringCase.lowerCase(word));
    }
    return results;
  };

  StringCase.getCapitalizedCodeWords = function(str) {
    var i, len, ref, results, word;
    ref = StringCase.getCodeWords(str);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      word = ref[i];
      results.push(StringCase.capitalize(StringCase.lowerCase(word)));
    }
    return results;
  };

  StringCase.upperCamelCase = function(str, joiner) {
    var word;
    if (joiner == null) {
      joiner = "";
    }
    return ((function() {
      var i, len, ref, results;
      ref = this.getLowerCaseCodeWords(str);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        word = ref[i];
        results.push(this.capitalize(word));
      }
      return results;
    }).call(StringCase)).join(joiner);
  };

  StringCase.lowerCamelCase = function(str, joiner) {
    if (joiner == null) {
      joiner = "";
    }
    return StringCase.decapitalize(StringCase.upperCamelCase(str, joiner));
  };

  StringCase.snakeCase = function(str) {
    return (StringCase.getLowerCaseCodeWords(str)).join("_");
  };

  StringCase.dashCase = function(str) {
    return (StringCase.getLowerCaseCodeWords(str)).join("-");
  };

  StringCase.capitalizedDashCase = function(str) {
    return (StringCase.getCapitalizedCodeWords(str)).join("-");
  };

  return StringCase;

})();


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var Core,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(72)).addNamespace('Core', Core = (function(superClass) {
  extend(Core, superClass);

  function Core() {
    return Core.__super__.constructor.apply(this, arguments);
  }

  return Core;

})(Neptune.PackageNamespace));


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var dateFormat, isDate, isNumber, isString, march1973InMilliseconds, ref, toDate, toMilliseconds;

ref = __webpack_require__(26), isString = ref.isString, isNumber = ref.isNumber, isDate = ref.isDate;

march1973InMilliseconds = 100000000000;

module.exports = {
  dateFormat: dateFormat = __webpack_require__(160),
  formatDate: function(value, format) {
    return dateFormat(toDate(value), format);
  },

  /*
  IN:
    Date
    OR Number of Seconds since epoch-start
    OR Number of Milliseconds since epoch-start
  OUT:
    Number of Milliseconds since epoch-start
   */
  toMilliseconds: toMilliseconds = function(v) {
    if (v == null) {
      return v;
    }
    if (isString(v)) {
      v = v - 0;
    }
    if (isNumber(v)) {
      if (v < march1973InMilliseconds) {
        return v * 1000;
      } else {
        return v;
      }
    } else if (isDate(v)) {
      return v - 0;
    } else {
      throw new Error('invalid timestamp value: #{formattedInspect v}');
    }
  },

  /*
  IN:
    Date
    OR Number of Seconds since epoch-start
    OR Number of Milliseconds since epoch-start
  OUT:
    Number of Seconds since epoch-start
   */
  toSeconds: function(v) {
    if (v == null) {
      return v;
    }
    return (toMilliseconds(v) / 1000 + .5) | 0;
  },
  toDate: toDate = function(v) {
    if (v == null) {
      return v;
    }
    if (isDate(v)) {
      return v;
    } else {
      return new Date(toMilliseconds(v));
    }
  }
};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ErrorWithInfo, defineModule, formattedInspect, isFunction, mergeInto, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defineModule = __webpack_require__(22).defineModule;

formattedInspect = __webpack_require__(23).formattedInspect;

ref = __webpack_require__(7), mergeInto = ref.mergeInto, isFunction = ref.isFunction;

defineModule(module, ErrorWithInfo = (function(superClass) {
  extend(ErrorWithInfo, superClass);

  function ErrorWithInfo(message, info, name) {
    this.info = info;
    this.name = name;
    ErrorWithInfo.__super__.constructor.apply(this, arguments);
    this.name || (this.name = "ErrorWithInfo");
    mergeInto(this, this.info);
    this.message = message;
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = (new Error).stack;
    }
  }

  ErrorWithInfo.prototype.toString = function() {
    return [
      "ErrorWithInfo: " + this.message, formattedInspect({
        info: this.info
      }, "")
    ].join("\n\n");
  };

  return ErrorWithInfo;

})(Error));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 143 */
/***/ (function(module, exports) {

var Function;

module.exports = Function = (function() {
  function Function() {}

  Function.fastBind = function(fn, _this) {
    switch (fn.length) {
      case 0:
        return function() {
          return fn.call(_this);
        };
      case 1:
        return function(a) {
          return fn.call(_this, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(_this, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(_this, a, b, c);
        };
      case 4:
        return function(a, b, c, d) {
          return fn.call(_this, a, b, c, d);
        };
      case 5:
        return function(a, b, c, d, e) {
          return fn.call(_this, a, b, c, d, e);
        };
      case 6:
        return function(a, b, c, d, e, f) {
          return fn.call(_this, a, b, c, d, e, f);
        };
      case 7:
        return function(a, b, c, d, e, f, g) {
          return fn.call(_this, a, b, c, d, e, f, g);
        };
      case 8:
        return function(a, b, c, d, e, f, g, h) {
          return fn.call(_this, a, b, c, d, e, f, g, h);
        };
      case 9:
        return function(a, b, c, d, e, f, g, h, i) {
          return fn.call(_this, a, b, c, d, e, f, g, h, i);
        };
      case 10:
        return function(a, b, c, d, e, f, g, h, i, j) {
          return fn.call(_this, a, b, c, d, e, f, g, h, i, j);
        };
      default:
        return function() {
          return fn.apply(_this, arguments);
        };
    }
  };

  return Function;

})();


/*
PERFORMANCE 2017-09-22
  Faster with normal bind:
    Chrome: 4x
    Edge: 2x
  Faster with fastBind
    FF: 7.8x faster
    Safari:
      OSX:  12.4x
      iOS:  11x
  Android:
    S8 Samsung browser: fastBindFaster: 6.5
    S8: normalBindFaster: 4x
 */


/*
TODO:

The above options are not hot-reload compatible. However, this alternative would be:

  name = fn.name
  -> _this[name].apply _this, arguments

I need to perf-test this. Or, I need to finally start using a global "debug" mode that could use this
in debug mode and the faster(?), non hot-reload options in production mode.
 */


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var FormattedInspect, alignTabs, ansiRegex, ansiSafeStringLength, escapeForBlockString, escapeJavascriptString, formattedInspectArray, formattedInspectObject, formattedInspectRecursive, formattedInspectString, indentLength, indentString, inspect, isFunction, isNumber, isPlainArray, isPlainObject, isString, max, newLineWithIndentString, objectKeyCount, pad, postWhitespaceFormatting, ref, ref1, stripAnsi, stripTrailingWhitespace, toInspectedObjects;

ref = __webpack_require__(4), isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, isNumber = ref.isNumber;

max = Math.max;

ref1 = __webpack_require__(16), pad = ref1.pad, stripTrailingWhitespace = ref1.stripTrailingWhitespace, escapeJavascriptString = ref1.escapeJavascriptString;

inspect = __webpack_require__(69).inspect;

objectKeyCount = __webpack_require__(28).objectKeyCount;

toInspectedObjects = __webpack_require__(68).toInspectedObjects;

indentString = '  ';

indentLength = indentString.length;

newLineWithIndentString = "\n" + indentString;

formattedInspectObject = function(m, maxLineLength, options) {
  var finalInspectedValues, forceMultilineOutput, index, inspected, inspectedLength, inspectedValues, k, key, keyCount, objectStart, shouldBeOnOwnLine, v, value;
  inspectedLength = 0;
  forceMultilineOutput = false;
  shouldBeOnOwnLine = false;
  keyCount = 0;
  inspectedValues = (function() {
    var results;
    results = [];
    for (key in m) {
      value = m[key];
      keyCount++;
      inspected = formattedInspectRecursive(value, maxLineLength - indentLength, options);
      if (inspected.match(/\n/)) {
        inspected = inspected.match(/^\[\]/) ? "" + inspected : newLineWithIndentString + inspected.replace(/\n/g, newLineWithIndentString);
        if (!/\n\s*$/.test(inspected)) {
          inspected += "\n";
        }
      } else if (ansiSafeStringLength(inspected) > maxLineLength - (key.length + 2)) {
        inspected = "" + newLineWithIndentString + inspected + "\n";
      }
      if (!/^[-~!@\#$%^&*_+=|\\<>?\/.$\w\u007f-\uffff]+$/.test(key)) {
        key = inspect(key);
      }
      inspectedLength += ansiSafeStringLength(inspected) + key.length + 2;
      forceMultilineOutput || (forceMultilineOutput = shouldBeOnOwnLine);
      shouldBeOnOwnLine = inspected.length > 100 || !inspected.match(/^([^,:]|\(.*\)|\{.*\}|\".*\"|\'.*\'|\[.*\])*$/);
      results.push([key, inspected, value]);
    }
    return results;
  })();
  objectStart = "{}";
  if (options.color) {
    objectStart = objectStart.grey;
  }
  if (keyCount === 0) {
    return objectStart;
  } else {
    index = 0;
    finalInspectedValues = (function() {
      var j, len, ref2, results;
      results = [];
      for (j = 0, len = inspectedValues.length; j < len; j++) {
        ref2 = inspectedValues[j], k = ref2[0], v = ref2[1], value = ref2[2];
        key = k + ":";
        if (options.color) {
          key = key.blue;
        }
        results.push(key + "\t" + v);
      }
      return results;
    })();
    return finalInspectedValues.join(!forceMultilineOutput && maxLineLength >= inspectedLength + (inspectedValues.length - 1) * 2 ? ",\t" : "\n");
  }
};

formattedInspectArray = function(m, maxLineLength, options) {
  var arrayStart, i, inspected, inspectedHasNewlines, inspectedValues, inspectedValuesContainNewlines, j, lastWasArray, lastWasObject, len, lengthOfCommas, lengthOfInspectedValues, lengthOfStartBrackets, objectStart, objectsMustBeExplicit, oneLinerOk, value;
  lengthOfInspectedValues = 0;
  lastWasObject = false;
  lastWasArray = false;
  objectsMustBeExplicit = false;
  oneLinerOk = true;
  inspectedValuesContainNewlines = false;
  for (i = j = 0, len = m.length; j < len; i = ++j) {
    value = m[i];
    if (isPlainObject(value)) {
      if (i < m.length - 1) {
        oneLinerOk = false;
      }
      if (lastWasObject) {
        objectsMustBeExplicit = true;
      }
      lastWasObject = true;
    } else {
      lastWasObject = false;
    }
  }
  inspectedValues = (function() {
    var l, len1, results;
    results = [];
    for (l = 0, len1 = m.length; l < len1; l++) {
      value = m[l];
      if (lastWasArray) {
        oneLinerOk = false;
      }
      if (isPlainArray(value)) {
        lastWasArray = true;
      }
      inspected = formattedInspectRecursive(value, maxLineLength - indentLength, options);
      inspectedHasNewlines = /\n/.test(inspected);
      if (objectsMustBeExplicit && isPlainObject(value)) {
        objectStart = "{}";
        if (options.color) {
          objectStart = objectStart.grey;
        }
        inspected = inspectedHasNewlines ? "" + objectStart + newLineWithIndentString + (inspected.replace(/\n/g, newLineWithIndentString)) : objectStart + " " + inspected;
      }
      if (inspectedHasNewlines) {
        oneLinerOk = false;
        inspected = inspected.replace(/\n/g, newLineWithIndentString);
        if (!/\n\s*$/.test(inspected)) {
          inspected += "\n";
        }
      }
      lengthOfInspectedValues += ansiSafeStringLength(inspected);
      results.push(inspected);
    }
    return results;
  })();
  lengthOfCommas = (inspectedValues.length - 1) * 2;
  lengthOfStartBrackets = 3;
  arrayStart = "[]";
  if (options.color) {
    arrayStart = arrayStart.grey;
  }
  if (oneLinerOk && maxLineLength >= lengthOfStartBrackets + lengthOfCommas + lengthOfInspectedValues) {
    if (inspectedValues.length === 0) {
      return arrayStart;
    } else {
      return arrayStart + " " + (inspectedValues.join(",\t"));
    }
  } else {
    return arrayStart + "\n  " + (inspectedValues.join("\n  "));
  }
};

escapeForBlockString = (function(_this) {
  return function(str) {
    return String(str).replace(/[\\\0\b\f\r\t\v\u001b\u2028\u2029]/g, function(x) {
      switch (x) {
        case '\\':
          return '\\\\';
        case '\0':
          return "\\0";
        case '\b':
          return "\\b";
        case '\f':
          return "\\f";
        case '\r':
          return "\\r";
        case '\t':
          return "\\t";
        case '\v':
          return "\\v";
        case '\u2028':
          return "\\u2028";
        case '\u2029':
          return "\\u2029";
        case '\u001b':
          return '\\u001b';
      }
    });
  };
})(this);

formattedInspectString = function(m, options) {
  var out;
  out = m.match(/\n/) && !m.match(/\ (\n|$)/) ? ('"""' + newLineWithIndentString + escapeForBlockString(m).replace(/\n/g, newLineWithIndentString)).replace(/\ +\n/g, '\n') : escapeJavascriptString(m);
  if (options != null ? options.color : void 0) {
    return out.green;
  } else {
    return out;
  }
};

formattedInspectRecursive = function(m, maxLineLength, options) {
  var out;
  if (isPlainObject(m)) {
    return formattedInspectObject(m, maxLineLength, options);
  } else if (isPlainArray(m)) {
    return formattedInspectArray(m, maxLineLength, options);
  } else if (isString(m)) {
    return formattedInspectString(m, options);
  } else {
    out = inspect(m);
    if (options.color) {
      return out.yellow;
    } else {
      return out;
    }
  }
};


/*
TODO:

  special mode for a chunk of lines that all have this pattern:

    /^\s*([a-z]:\t)*[^\t]+$/

  Example:
    hi: there: my: friends: "my value"
    somethingElseIThough: indexAllMyThings: withThis: "foo"

  Currently that becomes:
    hi:                   there:            my:       friends: "my value"
    somethingElseIThough: indexAllMyThings: withThis: "foo"

  Which is pretty awkward. I want:
    hi: there: my: friends:                           "my value"
    somethingElseIThough: indexAllMyThings: withThis: "foo"

  Basically, replace all but the last tab with a space.

  But only if ALL lines in a chunk are this pattern.

  CounterExample:
    properties:
      autoTags:          type: "text", analyzer: "standard"
      autoText:          type: "text", analyzer: "english"
      updatedAt:         type: "long"
      createdAt:         type: "long"
      title:             type: "text", analyzer: "english"
      userId:            type: "keyword"
      lastPostCreatedAt: type: "long"
      lastPostId:        type: "keyword"
      lastChapterPostId: type: "keyword"
      postCount:         type: "integer"
      followerCount:     type: "integer"
      activityCount:     type: "long"
      messageCount:      type: "long"
      isProfileTopic:    type: "boolean"
      private:           type: "boolean"

  Should NOT look like this:
    properties:
      autoTags:                type: "text", analyzer: "standard"
      autoText:                type: "text", analyzer: "english"
      updatedAt: type:         "long"
      createdAt: type:         "long"
      title:                   type: "text", analyzer: "english"
      userId: type:            "keyword"
      lastPostCreatedAt: type: "long"
      lastPostId: type:        "keyword"
      lastChapterPostId: type: "keyword"
      postCount: type:         "integer"
      followerCount: type:     "integer"
      activityCount: type:     "long"
      messageCount: type:      "long"
      isProfileTopic: type:    "boolean"
      private: type:           "boolean"
 */

alignTabs = function(linesString, maxLineLength) {
  var alignedLines, el, elLength, elements, expandAmount, i, j, l, len, len1, line, lines, maxColumnSizes, maxColumnWidth, r, spaceAvailable, tabStops;
  if (maxLineLength == null) {
    maxLineLength = 10000;
  }
  tabStops = 1;
  lines = linesString.split("\n");
  maxColumnSizes = [];
  maxColumnWidth = maxLineLength / 2;
  for (j = 0, len = lines.length; j < len; j++) {
    line = lines[j];
    if ((elements = line.split("\t")).length > 1) {
      for (i = l = 0, len1 = elements.length; l < len1; i = ++l) {
        el = elements[i];
        if (!(i < elements.length - 1 && (i === 0 || ansiSafeStringLength(el) < maxColumnWidth))) {
          continue;
        }
        if (maxColumnSizes.length === i) {
          maxColumnSizes.push(0);
        }
        maxColumnSizes[i] = max(maxColumnSizes[i], ansiSafeStringLength(el) + 1);
      }
    }
  }
  alignedLines = (function() {
    var len2, n, results;
    results = [];
    for (n = 0, len2 = lines.length; n < len2; n++) {
      line = lines[n];
      spaceAvailable = maxLineLength - ansiSafeStringLength(line);
      elements = line.split("\t");
      r = (function() {
        var len3, o, results1;
        if (elements.length > 1) {
          results1 = [];
          for (i = o = 0, len3 = elements.length; o < len3; i = ++o) {
            el = elements[i];
            elLength = ansiSafeStringLength(el);
            if (i === elements.length - 1) {
              results1.push(el);
            } else if ((maxColumnSizes[i] != null) && (expandAmount = maxColumnSizes[i] - elLength - 1) <= spaceAvailable) {
              spaceAvailable -= expandAmount;
              results1.push(el + pad('', maxColumnSizes[i] - elLength));
            } else {
              spaceAvailable = 0;
              results1.push(el + " ");
            }
          }
          return results1;
        } else {
          return elements;
        }
      })();
      results.push(r.join(""));
    }
    return results;
  })();
  return alignedLines.join("\n");
};

ansiRegex = /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;

stripAnsi = function(str) {
  if (ansiRegex.test(str)) {
    return str.replace(ansiRegex, '');
  } else {
    return str;
  }
};

ansiSafeStringLength = function(str) {
  if (!isString(str)) {
    throw new Error("not string");
  }
  if (ansiRegex.test(str)) {
    str = str.replace(ansiRegex, '');
  }
  return str.length;
};

postWhitespaceFormatting = function(maxLineLength, string) {
  var alignTabsInSameIndentGroup, indent, j, lastIndent, len, line, outLines, ref2, sameIndentGroup;
  lastIndent = 0;
  sameIndentGroup = [];
  outLines = [];
  alignTabsInSameIndentGroup = function() {
    var str;
    if (!(0 < sameIndentGroup.length)) {
      return;
    }
    str = sameIndentGroup.join("\n");
    sameIndentGroup = [];
    return outLines.push(alignTabs(str, maxLineLength));
  };
  ref2 = string.split("\n");
  for (j = 0, len = ref2.length; j < len; j++) {
    line = ref2[j];
    line = line.replace(/\s+$/g, '');
    if (lastIndent !== (indent = ansiSafeStringLength(line.match(/^ *-?/)[0]))) {
      alignTabsInSameIndentGroup();
    }
    sameIndentGroup.push(line);
    lastIndent = indent;
  }
  alignTabsInSameIndentGroup();
  return outLines.join('\n');
};

module.exports = FormattedInspect = (function() {
  function FormattedInspect() {}

  FormattedInspect.ansiRegex = ansiRegex;

  FormattedInspect.stripAnsi = stripAnsi;

  FormattedInspect.ansiSafeStringLength = ansiSafeStringLength;

  FormattedInspect.alignTabs = alignTabs;

  FormattedInspect.formattedInspectString = formattedInspectString;

  FormattedInspect.formattedInspect = function(toInspect, options) {
    var error, maxLineLength, out, ref2, ref3;
    if (options == null) {
      options = {};
    }
    try {
      if (isNumber(options)) {
        options = {
          maxLineLength: options
        };
      }
      if (options.maxLineLength == null) {
        options.maxLineLength = ((ref2 = global.process) != null ? (ref3 = ref2.stdout) != null ? ref3.columns : void 0 : void 0) || 80;
      }
      maxLineLength = options.maxLineLength;
      return out = postWhitespaceFormatting(maxLineLength, formattedInspectRecursive(toInspectedObjects(toInspect), maxLineLength, options)).replace(/\n\n$/, "\n");
    } catch (error1) {
      error = error1;
      console.error(out = "Error in formattedInspect", {
        error: error,
        toInspect: toInspect,
        options: options
      });
      return out;
    }
  };

  return FormattedInspect;

})();


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(146);

module.exports.addModules({
  Array: __webpack_require__(262),
  Core: __webpack_require__(263),
  Object: __webpack_require__(264),
  String: __webpack_require__(265)
});


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var Inspected,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(45)).addNamespace('Inspected', Inspected = (function(superClass) {
  extend(Inspected, superClass);

  function Inspected() {
    return Inspected.__super__.constructor.apply(this, arguments);
  }

  return Inspected;

})(Neptune.PackageNamespace));


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

var PlainObjects, deepMap, hasKeys, inspectedObjectLiteral, isClass, isFunction, isPlainArray, isPlainObject, ref;

ref = __webpack_require__(4), deepMap = ref.deepMap, hasKeys = ref.hasKeys, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isFunction = ref.isFunction, isClass = ref.isClass;

inspectedObjectLiteral = __webpack_require__(44).inspectedObjectLiteral;

module.exports = PlainObjects = (function() {
  var toPlainObjects;

  function PlainObjects() {}

  PlainObjects.toPlainObjects = toPlainObjects = function(m) {
    var functionString, oldm, out, reducedFunctionString;
    if (m == null) {
      return m;
    }
    oldm = m;
    if (out = typeof m.getPlainObjects === "function" ? m.getPlainObjects() : void 0) {
      return out;
    } else if (isPlainObject(m) || isPlainArray(m)) {
      return deepMap(m, function(v) {
        return toPlainObjects(v);
      });
    } else if (isClass(m)) {
      return inspectedObjectLiteral("<" + (m.getName()) + ">");
    } else if (isFunction(m)) {
      functionString = "" + m;
      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
    } else {
      return m;
    }
  };

  return PlainObjects;

})();


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var Inspect, Log, callStack, containsPromises, deepResolve, disableLog, getEnv, isNode, isString, merge, peek, ref, ref1,
  slice = [].slice;

Inspect = __webpack_require__(45);

callStack = __webpack_require__(66).callStack;

isString = __webpack_require__(4).isString;

peek = __webpack_require__(42).peek;

merge = __webpack_require__(7).merge;

ref = __webpack_require__(29), deepResolve = ref.deepResolve, containsPromises = ref.containsPromises;

ref1 = __webpack_require__(27), isNode = ref1.isNode, getEnv = ref1.getEnv;

disableLog = getEnv().disableLog;

module.exports = Log = (function() {
  var getLogger, noOptions, promiseLogId, standardOptions;

  function Log() {}

  Log.contextString = function(stack, defaultContext) {
    var caller, context;
    if (stack && (caller = stack[1])) {
      if (caller.original) {
        return caller.original;
      } else {
        context = caller["function"] ? caller["class"] ? caller["class"] + "::" + caller["function"] + "()" : caller["function"] + "()" : defaultContext ? defaultContext + ":" : "";
        if (caller.sourceFileName) {
          return "at " + caller.sourceFileName + ("-" + caller.sourceLine + ": ") + context;
        }
      }
    } else {
      return "at " + (defaultContext || "(unknown context)");
    }
  };

  Log.autoSizedIndepect = function(toInspect, maxLength, maxDepth) {
    var depth, inspected;
    if (maxLength == null) {
      maxLength = 512;
    }
    if (maxDepth == null) {
      maxDepth = 10;
    }
    inspected = null;
    depth = maxDepth;
    while ((inspected = Inspect.inspectLean(toInspect, {
        maxDepth: depth,
        maxLength: maxLength
      })).match(/\.\.\.$/)) {
      depth--;
    }
    return inspected;
  };

  Log.loggedParamsString = function(params) {
    if (typeof params === "string") {
      return params;
    } else {
      return Log.autoSizedIndepect(params);
    }
  };

  Log.hideLogging = function() {
    return Log.loggingHidden = true;
  };

  Log.showLogging = function() {
    return Log.loggingHidden = false;
  };

  Log.rawLog = function() {
    if (!Log.loggingHidden) {
      return console.log.apply(console, arguments);
    }
  };

  Log.rawErrorLog = function() {
    var a, out, str;
    if (Log.loggingHidden) {
      return;
    }
    if (isNode && "".red) {
      str = arguments.length > 1 ? (out = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = arguments.length; i < len; i++) {
          a = arguments[i];
          results.push(a);
        }
        return results;
      }).apply(Log, arguments), out.join(' ')) : arguments[0];
      return console.error(str.red);
    } else {
      return console.error.apply(console, arguments);
    }
  };

  Log.rawWarningLog = function() {
    var a, out, str;
    if (Log.loggingHidden) {
      return;
    }
    if (isNode && "".red) {
      str = arguments.length > 1 ? (out = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = arguments.length; i < len; i++) {
          a = arguments[i];
          results.push(a);
        }
        return results;
      }).apply(Log, arguments), out.join(' ')) : arguments[0];
      return console.warn(str.yellow);
    } else {
      return console.warn.apply(console, arguments);
    }
  };

  noOptions = {};

  getLogger = function(arg) {
    var isError, isWarning;
    isError = arg.isError, isWarning = arg.isWarning;
    if (isError) {
      return Log.rawErrorLog;
    } else if (isWarning) {
      return Log.rawWarningLog;
    } else {
      return Log.rawLog;
    }
  };

  promiseLogId = 1;

  Log.logCore = function(m, stack, options) {
    if (options == null) {
      options = noOptions;
    }
    if (Log.alternativeLogger) {
      Log.alternativeLogger.logCore(m, stack, options);
    }
    if (options.resolvePromises) {
      return Log.log.resolvePromiseWrapper(m, function(toLog, label) {
        var obj1;
        return Log._logNow((
          obj1 = {},
          obj1["" + label] = toLog,
          obj1
        ), stack, options);
      });
    } else {
      return Log._logNow(m, stack, options);
    }
  };

  Log._logNow = function(m, stack, options) {
    var className, logger;
    className = options.className;
    logger = getLogger(options);
    if (isNode) {
      return logger(isString(m) ? m : Inspect.formattedInspect(m, merge({
        maxLineLength: process.stdout.columns
      }, options)));
    } else {
      return logger(m);
    }
  };

  standardOptions = isNode ? {
    color: true
  } : {};

  Log.log = function() {
    var args, ref2;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (disableLog) {
      return peek(args);
    } else {
      return (ref2 = Log.log).withOptions.apply(ref2, [standardOptions].concat(slice.call(args)));
    }
  };

  Log.log.resolvePromiseWrapper = function(m, logger) {
    var logId, toResolve;
    if (containsPromises(m)) {
      toResolve = m;
      logId = promiseLogId++;
      logger(m, "RESOLVING_" + logId, false);
      return deepResolve(toResolve).then((function(_this) {
        return function(resolvedM) {
          return logger(resolvedM, "RESOLVED_" + logId, true);
        };
      })(this))["catch"]((function(_this) {
        return function(rejected) {
          return logger(rejected, "REJECTED_" + logId, true, true);
        };
      })(this));
    } else {
      return logger(m, false);
    }
  };

  Log.log.withOptions = function() {
    var args, m, options;
    options = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    m = args.length === 1 ? args[0] : args;
    Log.logCore(m, callStack(), options);
    return peek(args);
  };


  /*
  
  IN:
    labelString, value
    OR object with one or more properties (usually just one)
      returns the last value of the objects last key-value pair
  
  EX:
    log.withLabel foo: myObject
     * out: myObject
  
    log.withLabel "foo", myObject
     * out: myObject
   */

  Log.log.withLabel = function(a, b) {
    var k, obj, ret, v;
    if (isString(a)) {
      obj = {};
      obj[a] = b;
      Log.log(obj);
      return b;
    } else {
      ret = null;
      for (k in a) {
        v = a[k];
        ret = v;
      }
      Log.log(obj);
      return ret;
    }
  };

  Log.log.labeled = Log.log.withLabel;

  Log.log.error = function() {
    var args, ref2;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref2 = Log.log).withOptions.apply(ref2, [{
      isError: true
    }].concat(slice.call(args)));
  };

  Log.log.warn = function() {
    var args, ref2;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref2 = Log.log).withOptions.apply(ref2, [{
      isWarning: true
    }].concat(slice.call(args)));
  };

  Log.logL = function(obj) {
    var k, ret, v;
    console.warn("DEPRICATED: logL. USE log.labeled");
    ret = null;
    for (k in obj) {
      v = obj[k];
      ret = v;
    }
    Log.log(obj);
    return ret;
  };

  return Log;

})();


/***/ }),
/* 149 */
/***/ (function(module, exports) {

var MapExtensions;

module.exports = MapExtensions = (function() {
  function MapExtensions() {}

  MapExtensions.iteratorToArray = function(iterator) {
    var obj, out;
    out = [];
    while (!(obj = iterator.next()).done) {
      out.push(obj.value);
    }
    return out;
  };

  MapExtensions.mapToKeysArray = function(map) {
    return MapExtensions.iteratorToArray(map.keys());
  };

  MapExtensions.mapToValuesArray = function(map) {
    return MapExtensions.iteratorToArray(map.values());
  };

  return MapExtensions;

})();


/***/ }),
/* 150 */
/***/ (function(module, exports) {

var ObjectDiff;

module.exports = ObjectDiff = (function() {
  var defaultEq;

  function ObjectDiff() {}

  defaultEq = function(a, b) {
    return a === b;
  };


  /*
  SBD this has been thouroughly benchmarked on Safari and Chrome as of 2015-11-06
  This is as fast as I could make it.
  
  IN:
    newObj:   the changed-to object   (must be set)
    oldObj:   the changed-from object (default: {})
    added:    (key, newValue) -> null
              called for each key in newObj that was not in oldObj
    removed:  (key, oldValue) -> null
              called for each key in oldObj that is not in newObj
    changed:  (key, newValue, oldValue) -> null
              called for each key in both where the value changed
    noChange: (key, value) -> null
              called for each key in both where the value stayed the same
    eqTester: (a, b) -> true if a is equal to b
              DEFAULT: use javascript ===
              provided for custom concepts of equality
    oldObjKeyCount: null or a the number of keys in oldObj
      This last field provides an opportunity for further performance improvement.
      If you have previously computed the number of keys in oldObj, pass it in.
      Counting the number of keys in an object can be slow. If we know the number
      of keys this routine can be more efficient.
  
      NOTE that this function returns the key-count of the new object. That way if you
      are calling objecfDiff several times over a sequence of object changes, can you keep
      the results from this function, you already have the oldObjKeyCount for the next call.
  
  OUT: newObjKeyCount - number of keys in the new object
   */

  ObjectDiff.objectDiff = function(newObj, oldObj, added, removed, changed, noChange, eqTester, oldObjKeyCount) {
    var k, newObjKeyCount, newValue, oldObjKeyCountIsAtLeast, oldValue;
    if (eqTester == null) {
      eqTester = defaultEq;
    }
    newObjKeyCount = 0;
    if (!oldObj) {
      for (k in newObj) {
        newValue = newObj[k];
        newObjKeyCount++;
        added(k, newValue);
      }
      return newObjKeyCount;
    }
    oldObjKeyCountIsAtLeast = 0;
    for (k in newObj) {
      newValue = newObj[k];
      newObjKeyCount++;
      if (typeof (oldValue = oldObj[k]) !== "undefined" || oldObj.hasOwnProperty(k)) {
        oldObjKeyCountIsAtLeast++;
        if (!eqTester(newValue, oldValue)) {
          changed(k, newValue, oldValue);
        } else {
          if (typeof noChange === "function") {
            noChange(k, newValue);
          }
        }
      } else {
        added(k, newValue);
      }
    }
    if (!(oldObjKeyCount != null) || oldObjKeyCountIsAtLeast !== oldObjKeyCount) {
      for (k in oldObj) {
        if (!(typeof newObj[k] !== "undefined" || newObj.hasOwnProperty(k))) {
          removed(k, oldObj[k]);
        }
      }
    }
    return newObjKeyCount;
  };


  /*
  IN:
    newObj, oldObj, eqTester >> see above
  OUT:
    no changes: null
    otherwise:
      added:    key: addedItem
      removed:  key: removedItem
      changed:  key: {oldItem, newItem}
   */

  ObjectDiff.objectDiffReport = function(newObj, oldObj, eqTester) {
    var added, changed, different, removed;
    added = {};
    removed = {};
    changed = {};
    different = null;
    ObjectDiff.objectDiff(newObj, oldObj, function(key, addedItem) {
      different = true;
      return added[key] = addedItem;
    }, function(key, removedItem) {
      different = true;
      return removed[key] = removedItem;
    }, function(key, newItem, oldItem) {
      different = true;
      return changed[key] = {
        oldItem: oldItem,
        newItem: newItem
      };
    }, null, eqTester);
    return different && {
      added: added,
      removed: removed,
      changed: changed
    };
  };

  return ObjectDiff;

})();


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

var Promise, PromisedFileReader;

Promise = __webpack_require__(29);

module.exports = PromisedFileReader = (function() {
  function PromisedFileReader() {}

  PromisedFileReader.readFileAsDataUrl = function(file) {
    return new Promise(function(resolve, reject) {
      var reader;
      reader = new FileReader;
      reader.readAsDataURL(file);
      reader.onload = (function(_this) {
        return function(e) {
          return resolve(e.target.result);
        };
      })(this);
      return reader.onerror = (function(_this) {
        return function(e) {
          return reject(error);
        };
      })(this);
    });
  };

  PromisedFileReader.readFileAsArrayBuffer = function(file) {
    return new Promise(function(resolve, reject) {
      var reader;
      reader = new FileReader;
      reader.readAsArrayBuffer(file);
      reader.onload = (function(_this) {
        return function(e) {
          return resolve(e.target.result);
        };
      })(this);
      return reader.onerror = (function(_this) {
        return function(e) {
          return reject(error);
        };
      })(this);
    });
  };

  return PromisedFileReader;

})();


/***/ }),
/* 152 */
/***/ (function(module, exports) {

var Ruby,
  hasProp = {}.hasOwnProperty;

module.exports = Ruby = (function() {
  var rubyTrue;

  function Ruby() {}

  Ruby.rubyTrue = rubyTrue = function(a) {
    return a !== void 0 && a !== null && a !== false;
  };

  Ruby.rubyFalse = function(a) {
    return a === void 0 || a === null || a === false;
  };

  Ruby.rubyOr = function(a, b) {
    var i, len;
    if (arguments.length === 2) {
      if (rubyTrue(a)) {
        return a;
      } else {
        return b;
      }
    } else {
      for (i = 0, len = arguments.length; i < len; i++) {
        a = arguments[i];
        if (rubyTrue(a)) {
          break;
        }
      }
      return a;
    }
  };

  Ruby.rubyAnd = function(a, b) {
    var i, len;
    if (arguments.length === 2) {
      if (rubyTrue(a)) {
        return b;
      } else {
        return a;
      }
    } else {
      for (i = 0, len = arguments.length; i < len; i++) {
        a = arguments[i];
        if (!rubyTrue(a)) {
          break;
        }
      }
      return a;
    }
  };

  Ruby.reopenInstanceProps = function(klass, instanceProps) {
    var k, results, v;
    results = [];
    for (k in instanceProps) {
      if (!hasProp.call(instanceProps, k)) continue;
      v = instanceProps[k];
      results.push(klass.prototype[k] = v);
    }
    return results;
  };

  Ruby.reopenClassProps = function(klass, classProps) {
    var k, results, v;
    results = [];
    for (k in classProps) {
      if (!hasProp.call(classProps, k)) continue;
      v = classProps[k];
      results.push(klass[k] = v);
    }
    return results;
  };

  return Ruby;

})();


/***/ }),
/* 153 */
/***/ (function(module, exports) {


/*
This current iteration of clone relies on some singleton variables shared across all invocations of clone.
This is fine as long as javascript stays single-threaded.
It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

FUTURE
A potentially better solution would be to create a new closer each time clone is called at the top-most level,
but when recursing, pass in a new function bound to that closure which is different from the global clone function.

populateClone would need to take an additional argument - the clone function to use for recursive cloning.
 */
var ShallowClone;

module.exports = ShallowClone = (function() {
  function ShallowClone() {}

  ShallowClone.extendClone = function(obj) {
    if (obj.constructor === Array) {
      return obj.slice();
    } else {
      return Object.create(obj);
    }
  };

  ShallowClone.shallowClone = function(obj) {
    var k, ret, v;
    if (!obj) {
      return obj;
    }
    if (obj.constructor === Array) {
      return obj.slice();
    } else {
      ret = {};
      for (k in obj) {
        v = obj[k];
        ret[k] = v;
      }
      return ret;
    }
  };

  return ShallowClone;

})();


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var Time, base, commaize, dateSecondMinusPerformanceSecond, initDateSecond, initPerformanceSecond;

commaize = __webpack_require__(24).commaize;

self.performance || (self.performance = {});

(base = self.performance).now || (base.now = self.performance.mozNow || self.performance.msNow || self.performance.oNow || self.performance.webkitNow || function() {
  return new Date().getTime();
});

initPerformanceSecond = self.performance.now() / 1000;

initDateSecond = new Date().getTime() / 1000;

dateSecondMinusPerformanceSecond = initDateSecond - initPerformanceSecond;

module.exports = Time = (function() {
  var currentSecond, multiples, timerStack;

  function Time() {}

  multiples = [["mo", 30 * 24 * 60 * 60], ["d", 24 * 60 * 60], ["h", 60 * 60], ["m", 60], ["s", 1], ["ms", .001], ["Î¼s", .000001], ["ns", .000000001]];

  Time.dateSecondToPerformanceSecond = function(dateSecond) {
    return dateSecond - dateSecondMinusPerformanceSecond;
  };

  Time.performanceSecondToDateSecond = function(performanceSecond) {
    return performanceSecond + dateSecondMinusPerformanceSecond;
  };

  Time.timeStampToPerformanceSecond = function(htmlEventTimeStamp) {
    return htmlEventTimeStamp / 1000 - dateSecondMinusPerformanceSecond;
  };

  Time.durationString = function(seconds) {
    var i, len, multiplier, name, ref;
    for (i = 0, len = multiples.length; i < len; i++) {
      ref = multiples[i], name = ref[0], multiplier = ref[1];
      if (seconds >= multiplier) {
        return "" + ((seconds / multiplier) | 0) + name;
      }
    }
    return "0";
  };

  Time.dateAgeInSeconds = function(date) {
    return ((new Date) - date) * .001;
  };

  Time.dateToSeconds = function(date) {
    return post.getTime() * .001;
  };

  Time.perTimeString = function(secondsPerRun) {
    var perTime;
    perTime = 1 / secondsPerRun;
    if (perTime > 100) {
      return (commaize(perTime | 0)) + "/s";
    } else if (perTime * 60 > 100) {
      return (commaize(perTime * 60 | 0)) + "/m";
    } else {
      return (commaize(perTime * 3600 | 0)) + "/h";
    }
  };

  Time.currentMillisecond = function() {
    return self.performance.now();
  };

  Time.currentSecond = currentSecond = function() {
    return self.performance.now() / 1000;
  };

  Time.currentDateSecond = function() {
    return new Date().getTime() / 1000;
  };

  Time.time = function(a, b) {
    var f, fResult, start, timeResult;
    f = b || a;
    start = currentSecond();
    fResult = f();
    timeResult = currentSecond() - start;
    if (b) {
      Neptune.Art.StandardLib.log("time: " + a + " took " + (Time.durationString(timeResult)));
      return fResult;
    } else {
      return timeResult;
    }
  };

  timerStack = [];

  Time.stackTime = function(f) {
    var start, subTimeTotal, timeResult, tsl;
    start = currentSecond();
    timerStack.push(0);
    f();
    subTimeTotal = timerStack.pop();
    timeResult = currentSecond() - start;
    if ((tsl = timerStack.length) > 0) {
      timerStack[tsl - 1] += timeResult;
    }
    return {
      count: 1,
      total: timeResult,
      subTimeTotal: subTimeTotal,
      remainder: timeResult - subTimeTotal
    };
  };

  Time.logTimeSinceLast = function(a) {
    var time;
    time = Time.currentSecond();
    console.log(a + " (" + (Time.lastTime ? Time.durationString(time - Time.lastTime) : void 0) + ")");
    return Time.lastTime = time;
  };

  return Time;

})();


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(272);


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var DataTypes, FieldTypes, anyDataType, arrayDataType, booleanDataType, dateDataType, emailRegexp, functionDataType, isDate, isHexColor, isId, isNumber, isString, jsonDataType, k, log, numberDataType, objectDataType, ref, ref1, stringDataType, toDate, toLowerCase, toMilliseconds, toSeconds, urlRegexp, v, validStatus;

ref = __webpack_require__(0), isString = ref.isString, isNumber = ref.isNumber, isDate = ref.isDate, isHexColor = ref.isHexColor, toMilliseconds = ref.toMilliseconds, toDate = ref.toDate, toSeconds = ref.toSeconds, toLowerCase = ref.toLowerCase, emailRegexp = ref.emailRegexp, urlRegexp = ref.urlRegexp, log = ref.log;

ref1 = DataTypes = __webpack_require__(48), booleanDataType = ref1.booleanDataType, numberDataType = ref1.numberDataType, stringDataType = ref1.stringDataType, objectDataType = ref1.objectDataType, arrayDataType = ref1.arrayDataType, functionDataType = ref1.functionDataType, dateDataType = ref1.dateDataType, anyDataType = ref1.anyDataType, jsonDataType = ref1.jsonDataType;

validStatus = __webpack_require__(8).validStatus;

isId = function(v) {
  return isString(v) && v.match(/^[-_a-z0-9]{1,100}$/i);
};

isHexColor = function(v) {
  return /^#([a-f0-9]{3})|([a-f0-9]{6})/i.test("" + v);
};


/*
standard FieldType props:
  validate: (v) -> true/false
  preprocess: (v1) -> v2
  required: true/false
  dataType: one of @DataTypes, default: 'string'

You can add your own, too, but they are ignored by this class.
 */

module.exports = FieldTypes = {
  boolean: {
    dataType: booleanDataType
  },
  number: {
    dataType: numberDataType
  },
  string: {
    dataType: stringDataType
  },
  object: {
    dataType: objectDataType
  },
  array: {
    dataType: arrayDataType
  },
  any: {
    dataType: anyDataType
  },
  json: {
    dataType: jsonDataType
  },
  count: {
    dataType: numberDataType,
    "default": 0
  },
  id: {
    required: true,
    validate: function(v) {
      return isId(v);
    }
  },
  date: {
    validate: function(v) {
      return isString(v) || (v instanceof Date);
    },
    preprocess: function(v) {
      if (isString(v)) {
        return new Date(v);
      } else {
        return v;
      }
    },
    dataType: dateDataType
  },
  timestamp: {
    dataType: numberDataType,
    validate: function(v) {
      return isNumber(v) || isDate(v);
    },
    preprocess: toMilliseconds,
    decode: toDate
  },
  secondsTimestamp: {
    dataType: numberDataType,
    validate: function(v) {
      return isNumber(v) || isDate(v);
    },
    preprocess: toSeconds,
    decode: toDate
  },
  color: {
    validate: function(v) {
      return isHexColor(v);
    },
    preprocess: function(v) {
      return "" + v;
    }
  },
  email: {
    validate: function(v) {
      return isString(v) && v.trim().match(emailRegexp);
    },
    preprocess: function(v) {
      return v.trim().toLowerCase();
    }
  },
  url: {
    validate: function(v) {
      return isString(v) && v.match(urlRegexp);
    },
    preprocess: function(v) {
      return normalizeUrl(v);
    }
  },
  communicationStatus: {
    validate: function(v) {
      return validStatus(v);
    }
  },
  trimmedString: {
    validate: function(v) {
      return isString(v);
    },
    preprocess: function(v) {
      v = v.trim();
      return v.length > 0 && v;
    },
    maxLength: 1024
  },
  "function": {
    dataType: functionDataType
  }
};

for (k in FieldTypes) {
  v = FieldTypes[k];
  v.fieldType = k;
  v.dataType || (v.dataType = stringDataType);
  v.validate || (v.validate = DataTypes[v.dataType].validate);
}


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, DataTypes, ErrorWithInfo, FieldTypes, Promise, Validator, array, arrayDataType, booleanDataType, clone, dateDataType, emailRegexp, formattedInspect, functionDataType, isDate, isPlainArray, isPlainObject, isString, log, merge, mergeIntoUnless, numberDataType, object, objectDataType, present, pushIfNotPresent, ref, ref1, select, shallowClone, stringDataType, toDate, toMilliseconds, toSeconds, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), merge = ref.merge, log = ref.log, BaseClass = ref.BaseClass, shallowClone = ref.shallowClone, isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, Promise = ref.Promise, formattedInspect = ref.formattedInspect, present = ref.present, select = ref.select, emailRegexp = ref.emailRegexp, mergeIntoUnless = ref.mergeIntoUnless, w = ref.w, clone = ref.clone, ErrorWithInfo = ref.ErrorWithInfo, array = ref.array, object = ref.object, isDate = ref.isDate, pushIfNotPresent = ref.pushIfNotPresent, toDate = ref.toDate, toMilliseconds = ref.toMilliseconds, toSeconds = ref.toSeconds;

ref1 = __webpack_require__(48), booleanDataType = ref1.booleanDataType, numberDataType = ref1.numberDataType, stringDataType = ref1.stringDataType, objectDataType = ref1.objectDataType, arrayDataType = ref1.arrayDataType, functionDataType = ref1.functionDataType, dateDataType = ref1.dateDataType;

FieldTypes = __webpack_require__(156);

BaseClass = __webpack_require__(3).BaseClass;

DataTypes = __webpack_require__(48);


/*
NOTES:

  validators are evaluated before preprocessors

  preprocessors should NOT throw validation-related errors

  TODO?: We could add postValidators to allow you to validate AFTER the preprocessor...

USAGE:
  new Validator validatorFieldsProps, options

    IN:
      validatorFieldsProps:
        plain object with zero or more field-validations defined:
          fieldName: fieldProps
      options:
        exclusive: true/false
          if true, only fields listed in validatorFieldsProps are allowed.

    fieldProps:
      string or plainObject
      string: selects fieldProps from one of the standard @FieldTypes (see below)
      plainObject: (all fields are optional)

        validate: (v) -> true/false
          whenever this field is included in an update OR create operation,
            validate() must return true
          NOTE: validate is evaluated BEFORE preprocess

        preprocess: (v1, forCreate) -> v2
          whenever this field is included in an update OR create operation,
            after validation succeeds,
            value = preprocess value
          NOTE: validate is evaluated BEFORE preprocess

        required: true/false/string
          if true/string
            when creating records, this field must be included
          if string
            fieldProps = merge fieldProps, FieldTypes[string]

        present: true/false
          if true
            when creating records, this field must be include and 'present' (see Art.Foundation.present)

        fieldType: string
          fieldProps = merge FieldTypes[string], fieldProps

        dataType: string
          sepecify which of the standard Json data-types this field contains
          This is not used by Validator itself, but is available for clients to reflect on field-types.
          Must be one of the values in: DataTypes

        instanceof: class
          in addition to passing validate(), if present, the value must also be an instance of the
          specified class

EXAMPLES:
  new
 */

module.exports = Validator = (function(superClass) {
  var fieldPropsWithGeneratedPostValidator, normalizeDepricatedProps, normalizeFieldProps, normalizeFieldTypeProp, normalizeInstanceOfProp, normalizePlainObjectProps, validateCreate, validateUpdate;

  extend(Validator, superClass);

  normalizeInstanceOfProp = function(ft) {
    var _instanceof, validate;
    if (_instanceof = ft["instanceof"]) {
      validate = ft.validate;
      return merge(ft, {
        validate: function(v) {
          return (v instanceof _instanceof) && (!validate || validate(v));
        }
      });
    } else {
      return ft;
    }
  };

  normalizePlainObjectProps = function(ft) {
    var k, out, subObject, v;
    out = null;
    for (k in ft) {
      v = ft[k];
      if (k !== "fields") {
        if (isPlainObject(subObject = v)) {
          if (!out) {
            out = shallowClone(ft);
          }
          out[k] = true;
          mergeIntoUnless(out, normalizePlainObjectProps(subObject));
        }
      }
    }
    return out || ft;
  };

  normalizeDepricatedProps = function(ft) {
    if (ft.requiredPresent) {
      throw new Error("DEPRICATED: requiredPresent. Use: present: true");
    }
    if (isString(ft.required)) {
      throw new Error("DEPRICATED: required can no longer specifiy the field-type. Use: required: fieldType: myFieldTypeString OR 'required myFieldTypeString'");
    }
    if (isString(ft.present)) {
      throw new Error("DEPRICATED: present can no longer specifiy the field-type. Use: present: fieldType: myFieldTypeString OR 'present myFieldTypeString'");
    }
    return ft;
  };

  normalizeFieldTypeProp = function(ft) {
    var fieldType, fields;
    fieldType = ft.fieldType, fields = ft.fields;
    if (fields) {
      fieldType || (fieldType = "object");
    }
    if (fieldType) {
      return merge(normalizeFieldProps(fieldType), ft);
    } else {
      return ft;
    }
  };

  Validator.normalizeFields = function(fields) {
    return object(fields, normalizeFieldProps);
  };

  Validator.normalizeFieldProps = normalizeFieldProps = function(ft) {
    var fieldProps, ftArray, processed, string, strings, subFt;
    fieldProps = (function() {
      var i, len, ref2;
      if (isPlainObject(ft)) {
        return normalizeFieldTypeProp(normalizeInstanceOfProp(normalizeDepricatedProps(normalizePlainObjectProps(ft))));
      } else if (isPlainArray(ftArray = ft)) {
        processed = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = ftArray.length; i < len; i++) {
            ft = ftArray[i];
            results.push(normalizeFieldProps(ft));
          }
          return results;
        })();
        return merge.apply(null, processed);
      } else if (isString(strings = ft)) {
        ft = {};
        ref2 = w(strings);
        for (i = 0, len = ref2.length; i < len; i++) {
          string = ref2[i];
          if (subFt = FieldTypes[string]) {
            ft.fieldType = string;
            mergeIntoUnless(ft, subFt);
          } else {
            ft[string] = true;
          }
        }
        return ft;
      } else if (ft === true) {
        return FieldTypes.any;
      } else {
        throw new Error("fieldType must be a string or plainObject. Was: " + (formattedInspect(ft)));
      }
    })();
    return fieldPropsWithGeneratedPostValidator(merge(FieldTypes[fieldProps.fieldType], fieldProps));
  };

  fieldPropsWithGeneratedPostValidator = function(fieldProps) {
    var fields, maxLength, minLength, postValidate, validator;
    postValidate = fieldProps.postValidate, maxLength = fieldProps.maxLength, minLength = fieldProps.minLength, fields = fieldProps.fields;
    if ((maxLength != null) || (minLength != null) || (fields != null)) {
      if (fields) {
        validator = new Validator(fields, {
          exclusive: true
        });
        fieldProps.preprocess = function(value, forCreate) {
          return validator.preprocessFields(value, forCreate);
        };
      }
      fieldProps.postValidate = function(value, fieldName, fields) {
        if (postValidate) {
          if (!postValidate(value, fieldName, fields)) {
            return false;
          }
        }
        if (value != null) {
          if ((maxLength != null) && value.length > maxLength) {
            return false;
          }
          if ((minLength != null) && value.length < minLength) {
            return false;
          }
          try {
            if (validator != null) {
              validator.validate(value);
            }
            return true;
          } catch (error1) {
            return false;
          }
        } else {
          return true;
        }
      };
    }
    return fieldProps;
  };

  function Validator(fieldDeclarationMap, options) {
    this._fieldProps = {};
    this._requiredFields = [];
    this.addFields(fieldDeclarationMap);
    if (options) {
      this.exclusive = options.exclusive, this.context = options.context;
    }
  }

  Validator.property("exclusive");

  Validator.prototype.addFields = function(fieldDeclarationMap) {
    var field, fieldOptions;
    for (field in fieldDeclarationMap) {
      fieldOptions = fieldDeclarationMap[field];
      fieldOptions = this._addField(field, fieldOptions);
      if (fieldOptions.required || fieldOptions.present) {
        pushIfNotPresent(this._requiredFields, field);
      }
    }
    return null;
  };

  Validator.getter({
    inspectedObjects: function() {
      return {
        Validator: this._fieldProps
      };
    }
  });

  Validator.prototype.preCreate = function(fields, options) {
    log.error("Validator.preCreate is DEPRICATED. Use .validate or .validateCreate");
    return Promise.resolve(fields).then((function(_this) {
      return function(fields) {
        return _this.preCreateSync(fields, options);
      };
    })(this));
  };

  Validator.prototype.preUpdate = function(fields, options) {
    log.error("Validator.preUpdate is DEPRICATED. Use .validateUpdate");
    return Promise.resolve(fields).then((function(_this) {
      return function(fields) {
        return _this.preUpdateSync(fields, options);
      };
    })(this));
  };

  Validator.prototype.validateSync = function() {
    throw new Error("DEPRICATED: use validate");
  };

  Validator.prototype.preCreateSync = function(fields, options) {
    if (fields == null) {
      fields = {};
    }
    log.error("preCreateSync is DEPRICATED. use .validateCreate or just .validate");
    return this.validateCreate(fields, options);
  };

  Validator.prototype.preUpdateSync = function(fields, options) {
    if (fields == null) {
      fields = {};
    }
    log.error("preUpdateSync is DEPRICATED. use validateUpdate");
    return this.validateUpdate(fields, options);
  };


  /*
  IN:
    fields: - the object to check
    options:
      context: string - included in validation errors for reference
      logErrors: false - if true, will log.error errors
  
  OUT: preprocessed fields - if they pass, otherwise error is thrown
  
  NOTE: missing fields are errors
   */

  Validator.prototype.validateCreate = validateCreate = function(fields, options) {
    var error, out, processedFields;
    if (fields == null) {
      fields = {};
    }
    processedFields = null;
    out = (function() {
      try {
        return this.requiredFieldsPresent(fields) && this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocessFields(fields, true));
      } catch (error1) {
        error = error1;
        return log.error({
          Validator: {
            error_in: {
              preCreateSync: {
                fields: fields,
                options: options,
                "this": this,
                error: error
              }
            }
          }
        });
      }
    }).call(this);
    return out || this._throwError(fields, processedFields, options, true);
  };

  Validator.prototype.validate = validateCreate;


  /*
  IN:
    fields: - the object to check
    options:
      context: string - included in validation errors for reference
      logErrors: false - if true, will log.error errors
  
  OUT: preprocessed fields - if they pass, otherwise error is thrown
  
  NOTE: missing fields are ignored
   */

  Validator.prototype.validateUpdate = validateUpdate = function(fields, options) {
    var error, out, processedFields;
    if (fields == null) {
      fields = {};
    }
    out = (function() {
      try {
        return this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocessFields(fields));
      } catch (error1) {
        error = error1;
        return log.error({
          Validator: {
            error_in: {
              preUpdateSync: {
                fields: fields,
                options: options,
                "this": this,
                error: error
              }
            }
          }
        });
      }
    }).call(this);
    return out || this._throwError(fields, processedFields, options);
  };

  Validator.prototype._throwError = function(fields, processedFields, options, forCreate) {
    var errors, info, message, messageFields;
    info = {
      errors: errors = {}
    };
    messageFields = [];
    array(this.invalidFields(fields), messageFields, (function(_this) {
      return function(f) {
        errors[f] = "invalid";
        if (_this.exclusive && !_this._fieldProps[f]) {
          return "unexpected '" + f + "' field";
        } else {
          return "invalid " + f;
        }
      };
    })(this));
    array(this.postInvalidFields(processedFields), messageFields, (function(_this) {
      return function(f) {
        errors[f] = "invalid";
        return "invalid processed " + f;
      };
    })(this));
    forCreate && array(this.missingFields(fields), messageFields, function(f) {
      errors[f] = "missing";
      return "missing " + f;
    });
    message = "Invalid fields for " + ((options != null ? options.context : void 0) || this.context || "Validator") + " " + (forCreate ? 'create' : 'update') + ": " + (messageFields.join(', '));
    info.fields = fields;
    throw new ErrorWithInfo(message, info);
  };

  Validator.prototype.presentFieldPostValid = function(fields, fieldName, value) {
    var fieldProps, postValidate;
    if (fieldProps = this._fieldProps[fieldName]) {
      postValidate = fieldProps.postValidate;
      return !postValidate || (value == null) || value === null || value === void 0 || postValidate(value, fieldName, fields);
    } else {
      return true;
    }
  };

  Validator.prototype.presentFieldValid = function(fields, fieldName, value) {
    var fieldProps, validate;
    if (fieldProps = this._fieldProps[fieldName]) {
      validate = fieldProps.validate;
      return !validate || (value == null) || value === null || value === void 0 || validate(value, fieldName, fields);
    } else {
      return !this.exclusive;
    }
  };

  Validator.prototype.requiredFieldPresent = function(fields, fieldName) {
    var fieldProps;
    if (!(fieldProps = this._fieldProps[fieldName])) {
      return true;
    }
    if (fieldProps.required && (fields[fieldName] == null)) {
      return false;
    }
    if (fieldProps.present && !present(fields[fieldName])) {
      return false;
    }
    return true;
  };

  Validator.prototype.presentFieldsValid = function(fields) {
    var fieldName, fieldValue;
    for (fieldName in fields) {
      fieldValue = fields[fieldName];
      if (!this.presentFieldValid(fields, fieldName, fieldValue)) {
        return false;
      }
    }
    return true;
  };

  Validator.prototype.requiredFieldsPresent = function(fields) {
    var fieldName, fieldValue, ref2;
    ref2 = this._fieldProps;
    for (fieldName in ref2) {
      fieldValue = ref2[fieldName];
      if (!this.requiredFieldPresent(fields, fieldName)) {
        return false;
      }
    }
    return true;
  };

  Validator.prototype.postValidateFields = function(fields) {
    var fieldName, fieldValue;
    for (fieldName in fields) {
      fieldValue = fields[fieldName];
      if (!this.presentFieldPostValid(fields, fieldName, fieldValue)) {
        return false;
      }
    }
    return fields;
  };

  Validator.prototype.preprocessFields = function(fields, applyDefaults) {
    var fieldName, oldValue, preprocess, processedFields, props, value;
    processedFields = null;
    if (applyDefaults) {
      fields || (fields = {});
    }
    fields && (function() {
      var ref2, results;
      ref2 = this._fieldProps;
      results = [];
      for (fieldName in ref2) {
        props = ref2[fieldName];
        preprocess = props.preprocess;
        value = void 0 !== (oldValue = fields[fieldName]) ? oldValue : applyDefaults && props["default"];
        if (preprocess && (value != null)) {
          value = preprocess(value, applyDefaults);
        }
        if (value !== oldValue) {
          processedFields || (processedFields = shallowClone(fields));
          results.push(processedFields[fieldName] = value);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }).call(this);
    return processedFields || fields || {};
  };

  Validator.prototype.invalidFields = function(fields) {
    var k, results, v;
    results = [];
    for (k in fields) {
      v = fields[k];
      if (!this.presentFieldValid(fields, k, v)) {
        results.push(k);
      }
    }
    return results;
  };

  Validator.prototype.postInvalidFields = function(fields) {
    var k, results, v;
    results = [];
    for (k in fields) {
      v = fields[k];
      if (!this.presentFieldPostValid(fields, k, v)) {
        results.push(k);
      }
    }
    return results;
  };

  Validator.prototype.missingFields = function(fields) {
    var i, k, len, ref2, results;
    ref2 = this._requiredFields;
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      k = ref2[i];
      if (!this.requiredFieldPresent(fields, k)) {
        results.push(k);
      }
    }
    return results;
  };

  Validator.prototype._addField = function(field, options) {
    return this._fieldProps[field] = normalizeFieldProps(options);
  };

  return Validator;

})(BaseClass);


/***/ }),
/* 158 */
/***/ (function(module, exports) {

var ArrayCompactFlatten, arraySlice, doFlattenInternal, flattenIfNeeded, isArguments, isArrayOrArguments, isPlainArray, keepAll, keepUnlessNullOrUndefined, needsFlatteningOrCompacting;

arraySlice = Array.prototype.slice;

isArguments = function(o) {
  return o && (typeof o.callee === "function") && (typeof o.length === "number");
};

isPlainArray = (function(_this) {
  return function(o) {
    return (o != null) && o.constructor === Array;
  };
})(this);

isArrayOrArguments = function(o) {
  return o && (isPlainArray(o) || isArguments(o));
};

doFlattenInternal = function(array, keepTester, output) {
  var a, i, len;
  output || (output = []);
  for (i = 0, len = array.length; i < len; i++) {
    a = array[i];
    if (isArrayOrArguments(a)) {
      flattenIfNeeded(a, keepTester, output);
    } else if (keepTester(a)) {
      output.push(a);
    }
  }
  return output;
};

needsFlatteningOrCompacting = function(array, keepTester) {
  var a, i, len;
  for (i = 0, len = array.length; i < len; i++) {
    a = array[i];
    if (isArrayOrArguments(a) || !keepTester(a)) {
      return true;
    }
  }
  return false;
};

flattenIfNeeded = function(array, keepTester, output) {
  var i, len, v;
  if (needsFlatteningOrCompacting(array, keepTester)) {
    return doFlattenInternal(array, keepTester, output);
  } else if (output) {
    for (i = 0, len = array.length; i < len; i++) {
      v = array[i];
      output.push(v);
    }
    return output;
  } else if (array.constructor !== Array) {
    return arraySlice.call(array);
  } else {
    return array;
  }
};

keepAll = function() {
  return true;
};

keepUnlessNullOrUndefined = function(a) {
  return a !== null && a !== void 0;
};

module.exports = ArrayCompactFlatten = (function() {
  function ArrayCompactFlatten() {}

  ArrayCompactFlatten.isPlainArray = isPlainArray;

  ArrayCompactFlatten.compact = function(array, keepTester) {
    var a, i, len;
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    for (i = 0, len = array.length; i < len; i++) {
      a = array[i];
      if (!keepTester(a)) {
        return (function() {
          var j, len1, results;
          results = [];
          for (j = 0, len1 = array.length; j < len1; j++) {
            a = array[j];
            if (keepTester(a)) {
              results.push(a);
            }
          }
          return results;
        })();
      }
    }
    return array;
  };

  ArrayCompactFlatten.flatten = function(firstArg) {
    return flattenIfNeeded(arguments.length === 1 ? isArrayOrArguments(firstArg) ? firstArg : [firstArg] : arguments, keepAll);
  };

  ArrayCompactFlatten.compactFlatten = function(array, keepTester) {
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    return flattenIfNeeded(array, keepTester);
  };

  return ArrayCompactFlatten;

})();


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {


/*
TODO: Make NN ugifly-mangler friendly. In order to do that, we need
to stop using the function.name attribute.

OLD:
  I think we can do that with one change: addNamespace needs to
  change to take a name argument: @addNamespace: (name, namespace) ->

NEW:
  Ok, that's done. Now I need to revisit the mangler issue.
  Did this fix it?
 */
var ArtStandardLibCore, Namespace, isClass, isExtendedClass, isFunction, isPlainArray, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(259), isClass = ref.isClass, isFunction = ref.isFunction, isPlainArray = ref.isPlainArray, isExtendedClass = ref.isExtendedClass;

ArtStandardLibCore = null;

module.exports = Namespace = (function() {
  var excludedPropNames, isPathedNamespace;

  function Namespace() {}

  Namespace.isNamespace = function(klass) {
    return (klass != null ? klass.prototype : void 0) instanceof Namespace;
  };

  Namespace.allNamespaces = {};

  Namespace.getAllNamespacePaths = function() {
    return Object.keys(Namespace.allNamespaces).sort();
  };

  Namespace.toString = function() {
    return this.namespacePath;
  };

  Namespace.inspect = function() {
    return this.namespacePath;
  };

  Namespace.namespacePath = "Neptune.Namespace";

  Namespace.namespace = null;

  Namespace.namespaces = {};

  Namespace.modules = {};

  Namespace.getNamespacePath = function() {
    return this.namespacePath;
  };

  Namespace.getNamespaceNames = function() {
    return Object.keys(this.namespaces).sort();
  };

  Namespace.getModuleNames = function() {
    return Object.keys(this.modules).sort();
  };

  Namespace.getNeptuneLib = function() {
    return ArtStandardLibCore || (ArtStandardLibCore = __webpack_require__(258));
  };

  Namespace.getInspectedObjects = function(includeModules) {
    var name, namespace, obj;
    if (includeModules == null) {
      includeModules = true;
    }
    return (
      obj = {},
      obj["" + this.namespacePath] = this.getNeptuneLib().merge(this.version ? {
        version: this.version
      } : void 0, (function() {
        var ref1, results;
        ref1 = this.namespaces;
        results = [];
        for (name in ref1) {
          namespace = ref1[name];
          results.push(namespace.getInspectedObjects(includeModules));
        }
        return results;
      }).call(this), includeModules && this.getModuleNames().length > 0 ? {
        modules: this.getModuleNames().join(', ')
      } : void 0),
      obj
    );
  };

  Namespace.getVersions = function() {
    var key, out, recurse, ref1, subnamespace;
    out = {};
    if (this === Neptune) {
      out.NeptuneNamespacesRuntime = this.version;
    }
    ref1 = this.namespaces;
    for (key in ref1) {
      subnamespace = ref1[key];
      if (0 < Object.keys(recurse = subnamespace.getVersions()).length) {
        out[key] = recurse;
      }
      if (subnamespace.version != null) {
        out[key] || (out[key] = subnamespace.version);
      }
    }
    return out;
  };


  /*
  IN:
    "Foo" -> vivifies @Foo
    "Foo.Bar" ->  vivifies @Foo.Bar
    OR: ["Foo", "Bar", "Baz"] ->  vivifies @Foo.Bar.Baz
   */

  Namespace.vivifySubnamespace = function(name) {
    var PathedNamespace, base, j, len, namespace, path;
    if (isPathedNamespace(name)) {
      name = name.split('.');
    }
    if (isPlainArray(path = name)) {
      namespace = this;
      for (j = 0, len = path.length; j < len; j++) {
        name = path[j];
        namespace = namespace.vivifySubnamespace(name);
      }
      return namespace;
    } else {
      return (base = this.namespaces)[name] || (base[name] = this[name] = PathedNamespace = (function(superClass) {
        extend(PathedNamespace, superClass);

        function PathedNamespace() {
          return PathedNamespace.__super__.constructor.apply(this, arguments);
        }

        return PathedNamespace;

      })(Namespace._init(name, this)));
    }
  };

  Namespace.isPathedNamespace = isPathedNamespace = function(name) {
    return /\./.test(name);
  };

  Namespace.addVersionedNamespace = function(name, namespace) {
    var version, versions;
    if (!namespace) {
      return;
    }
    if (!(versions = (this.versionedNamespaces || (this.versionedNamespaces = {}))[name])) {
      versions = this.versionedNamespaces[name] = {};
      this.addVersionedNamespace(name, this.namespaces[name]);
    }
    version = namespace.version;
    console.warn(("NN: adding " + this.namespacePath + ".versionedNamespaces." + name + "['" + version + "']") + (namespace === this.namespaces[name] ? " (default)" : ""));
    if (version == null) {
      throw new Error("expecting namespace '" + name + "' in '" + this.namespacePath + "'' to have a version");
    }
    if (versions[version]) {
      console.warn("NN: versionedNamespace " + name + " already added for version " + version + ". Not added again.");
    } else {
      versions[version] = namespace;
    }
    return namespace;
  };

  Namespace.addNamespace = function(name, namespace) {
    var existingNamespace, j, path, ref1;
    if (isPathedNamespace(name)) {
      ref1 = name.split("."), path = 2 <= ref1.length ? slice.call(ref1, 0, j = ref1.length - 1) : (j = 0, []), name = ref1[j++];
      this.vivifySubnamespace(path).addNamespace(name, namespace);
    } else if (existingNamespace = this.namespaces[name]) {
      if (!((namespace.prototype instanceof Neptune.PackageNamespace) && (existingNamespace.prototype instanceof Neptune.PackageNamespace))) {
        throw new Error("PathedNamespace vs PackageNamespaces conflict for: " + this.namespacePath + "." + name + "'.");
      }
      this.addVersionedNamespace(name, namespace);
    } else {
      this.allNamespaces[namespace.namespacePath] = this.namespaces[name] = this[name] = namespace._init(name, this);
    }
    return namespace;
  };

  Namespace.addModules = function(map) {
    var modName, module, name;
    for (name in map) {
      module = map[name];
      this._setChildNamespaceProps(name, module);
      if (isExtendedClass(module) && name !== (modName = module.getName())) {
        console.warn("NN: module name (" + this.namespacePath + "." + name + ") does not match module.exports.getName(): " + modName);
      }
      if (!name.match(/^-/)) {
        this.modules[name] = this[name] = module;
      }
    }
    return this;
  };


  /*
  IN: any combination of objects or arrays
    object: all properties in the object are added to the namespace
  
    array: [fromObject, property names as one or more strings]
      for propName in every sub-string in args matching: /[0-9a-z_]+/ig
        @_addToNamespace propName, fromObject
  
      Each string is parsed to find everything that matches: /[0-9a-z_]+/ig
      All resulting property names are concated into a one list.
      Every property in fromObject that matches one of the property-names is added to the namespace.
   */

  Namespace.includeInNamespace = function() {
    var arg, args, fromObject, i, j, k, l, len, len1, propName, ref1, ref2, v;
    args = arguments.length === 1 && isPlainArray(arguments[0]) ? arguments[0] : arguments;
    for (j = 0, len = args.length; j < len; j++) {
      arg = args[j];
      if (arg != null) {
        if (isPlainArray(arg)) {
          fromObject = arg[0];
          for (i = k = 1, ref1 = arg.length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {
            ref2 = arg[i].match(/[0-9a-z_]+/ig);
            for (l = 0, len1 = ref2.length; l < len1; l++) {
              propName = ref2[l];
              this._addToNamespace(propName, fromObject);
            }
          }
        } else {
          for (propName in arg) {
            v = arg[propName];
            this._addToNamespace(propName, arg);
          }
        }
      }
    }
    return this;
  };


  /*
  Every child of a namespace gets these properties:
  
    namespace:      pointer to the parent namespace
    namespacePath:  string path from global to child
  
  NOTE: only modules which return a class or function
    get their namespace-props set.
   */

  Namespace._setChildNamespaceProps = function(name, child) {
    if (isFunction(child) || isClass(child)) {
      if (isFunction(child["class"])) {
        this._setChildNamespaceProps(name, child["class"]);
      }
      child.namespace = this;
      return child.namespacePath = this.namespacePath + "." + name;
    }
  };


  /*
  CoffeeScript classes copy all class props when inheriting,
  but some props need to be unique to each instance. This
  function initializes those props.
   */

  Namespace._init = function(name, namespace1) {
    var ref1;
    this.namespace = namespace1;
    this._name = name;
    this.modules = {};
    this.namespaces = {};
    this.versionedNamespaces = null;
    if ((ref1 = this.namespace) != null) {
      ref1._setChildNamespaceProps(name, this);
    }
    return this;
  };

  excludedPropNames = ["__super__", "_name", "version"].concat(Object.keys(Namespace));


  /*
  Helper for includeInNamespace.
  Add anything to the namespace.
  
  IN:
    propName:   property name to  value will be assigned to in the namespace (string)
    addingFrom: object
      used for reporting errors if attempting to overwrite an
      existing item.
  
  EFFECT:
    Only adds value if @[propName] is not already set.
    Otherwise, reports error and continues.
  
  OUT: value
   */

  Namespace._addToNamespace = function(propName, addingFrom) {
    var addingFromString, ref1, value;
    value = addingFrom[propName];
    if (propName === "inspect" && (value != null ? value.length : void 0) > 0) {
      return this[propName] = value;
    }
    if (indexOf.call(excludedPropNames, propName) >= 0) {
      return;
    }
    if (value == null) {
      return;
    }
    if (this[propName]) {
      if (this[propName] !== value) {
        addingFromString = addingFrom.namespacePath || addingFrom.propName || (Object.keys(addingFrom)).join(', ');
        console.error(this.namespacePath + " already has key: " + propName + ". Adding from: " + addingFromString);
      }
      this[propName];
    } else {
      this[propName] = value;
    }
    if (propName === 'version') {
      return (ref1 = this.namespace.versionedNamespaces) != null ? ref1[this.getName()][value] = this : void 0;
    }
  };

  return Namespace;

})();


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

(function(global) {
  'use strict';

  var dateFormat = (function() {
      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
      var timezoneClip = /[^-+\dA-Z]/g;
  
      // Regexes and supporting functions are cached through closure
      return function (date, mask, utc, gmt) {
  
        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
          mask = date;
          date = undefined;
        }
  
        date = date || new Date;
  
        if(!(date instanceof Date)) {
          date = new Date(date);
        }
  
        if (isNaN(date)) {
          throw TypeError('Invalid date');
        }
  
        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
  
        // Allow setting the utc/gmt argument via the mask
        var maskSlice = mask.slice(0, 4);
        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
          mask = mask.slice(4);
          utc = true;
          if (maskSlice === 'GMT:') {
            gmt = true;
          }
        }
  
        var _ = utc ? 'getUTC' : 'get';
        var d = date[_ + 'Date']();
        var D = date[_ + 'Day']();
        var m = date[_ + 'Month']();
        var y = date[_ + 'FullYear']();
        var H = date[_ + 'Hours']();
        var M = date[_ + 'Minutes']();
        var s = date[_ + 'Seconds']();
        var L = date[_ + 'Milliseconds']();
        var o = utc ? 0 : date.getTimezoneOffset();
        var W = getWeek(date);
        var N = getDayOfWeek(date);
        var flags = {
          d:    d,
          dd:   pad(d),
          ddd:  dateFormat.i18n.dayNames[D],
          dddd: dateFormat.i18n.dayNames[D + 7],
          m:    m + 1,
          mm:   pad(m + 1),
          mmm:  dateFormat.i18n.monthNames[m],
          mmmm: dateFormat.i18n.monthNames[m + 12],
          yy:   String(y).slice(2),
          yyyy: y,
          h:    H % 12 || 12,
          hh:   pad(H % 12 || 12),
          H:    H,
          HH:   pad(H),
          M:    M,
          MM:   pad(M),
          s:    s,
          ss:   pad(s),
          l:    pad(L, 3),
          L:    pad(Math.round(L / 10)),
          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
          W:    W,
          N:    N
        };
  
        return mask.replace(token, function (match) {
          if (match in flags) {
            return flags[match];
          }
          return match.slice(1, match.length - 1);
        });
      };
    })();

  dateFormat.masks = {
    'default':               'ddd mmm dd yyyy HH:MM:ss',
    'shortDate':             'm/d/yy',
    'mediumDate':            'mmm d, yyyy',
    'longDate':              'mmmm d, yyyy',
    'fullDate':              'dddd, mmmm d, yyyy',
    'shortTime':             'h:MM TT',
    'mediumTime':            'h:MM:ss TT',
    'longTime':              'h:MM:ss TT Z',
    'isoDate':               'yyyy-mm-dd',
    'isoTime':               'HH:MM:ss',
    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
  };

  // Internationalization strings
  dateFormat.i18n = {
    dayNames: [
      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
    ],
    monthNames: [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
    ],
    timeNames: [
      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'
    ]
  };

function pad(val, len) {
  val = String(val);
  len = len || 2;
  while (val.length < len) {
    val = '0' + val;
  }
  return val;
}

/**
 * Get the ISO 8601 week number
 * Based on comments from
 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
 *
 * @param  {Object} `date`
 * @return {Number}
 */
function getWeek(date) {
  // Remove time components of date
  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

  // Change date to Thursday same week
  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

  // Take January 4th as it is always in week 1 (see ISO 8601)
  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

  // Change date to Thursday same week
  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

  // Check if daylight-saving-time-switch occurred and correct for it
  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
  targetThursday.setHours(targetThursday.getHours() - ds);

  // Number of weeks between target Thursday and first Thursday
  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
  return 1 + Math.floor(weekDiff);
}

/**
 * Get ISO-8601 numeric representation of the day of the week
 * 1 (for Monday) through 7 (for Sunday)
 * 
 * @param  {Object} `date`
 * @return {Number}
 */
function getDayOfWeek(date) {
  var dow = date.getDay();
  if(dow === 0) {
    dow = 7;
  }
  return dow;
}

/**
 * kind-of shortcut
 * @param  {*} val
 * @return {String}
 */
function kindOf(val) {
  if (val === null) {
    return 'null';
  }

  if (val === undefined) {
    return 'undefined';
  }

  if (typeof val !== 'object') {
    return typeof val;
  }

  if (Array.isArray(val)) {
    return 'array';
  }

  return {}.toString.call(val)
    .slice(8, -1).toLowerCase();
};



  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return dateFormat;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    module.exports = dateFormat;
  } else {
    global.dateFormat = dateFormat;
  }
})(this);


/***/ }),
/* 161 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-foundation":"git://github.com/imikimi/art-foundation.git","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"atomic data-types such as Color, Point, Rectangle and Matrix","license":"ISC","name":"art-atomic","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.14.0"}

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"^1.11.5","art-class-system":"^1.5.2","art-config":"^1.3.3","art-standard-lib":"^1.11.1","art-testbench":"^1.10.3","aws-sdk":"^2.66.0","aws4":"^1.6.0","bluebird":"^3.5.0","caffeine-script":"^0.44.5","caffeine-script-runtime":"^1.0.0","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","corsproxy":"^1.5.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","dynamodb-local":"^0.0.18","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"^2.2.2","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Streamlined APIs for AWS SDK with Promises and Art.Foundation","license":"ISC","name":"art-aws","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.18.0"}

/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-events":"git://github.com/imikimi/art-events.git","art-express-server":"git://github.com/imikimi/art-express-server.git","art-flux":"git://github.com/imikimi/art-flux.git","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","compress":"^0.99.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","express":"^4.14.0","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","jsonwebtoken":"^7.2.1","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","throng":"^4.0.0","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"A pipelined business-logic framework for cloud-backed data. ArtEry conceptially allows you to write apps 100% as client-code, but with the security and performance of cloud-code.","license":"ISC","name":"art-ery","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress","testServer":"caf ./TestServer.caf"},"version":"1.80.5"}

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-communication-status":"*","art-config":"*","art-epoched-state":"*","art-object-tree-factory":"*","art-rest-client":"*","art-standard-lib":"*","art-testbench":"*","art-validation":"*","atob":"^2.0.3","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Foundation classes for the Art framework. Javascript extensions.","license":"ISC","name":"art-foundation","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"1.75.1"}

/***/ }),
/* 165 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = require("detect-node");

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = require("express");

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = require("uuid");

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(89);

module.exports.addModules({
  Development: __webpack_require__(177)
});


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(90);

module.exports.addModules({
  Chat: __webpack_require__(178)
});


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var ArtEryPusher;

ArtEryPusher = __webpack_require__(99).Config.PusherServer = __webpack_require__(305);

module.exports = ArtEryPusher;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(271);


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;_xamzrequire=function t(e,r,n){function i(s,a){if(!r[s]){if(!e[s]){var u="function"==typeof _xamzrequire&&_xamzrequire;if(!a&&u)return u(s,!0);if(o)return o(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var l=r[s]={exports:{}};e[s][0].call(l.exports,function(t){var r=e[s][1][t];return i(r?r:t)},l,l.exports,t,e,r,n)}return r[s].exports}for(var o="function"==typeof _xamzrequire&&_xamzrequire,s=0;s<n.length;s++)i(n[s]);return i}({24:[function(t,e,r){var n={util:t("./util")},i={};i.toString(),e.exports=n,n.util.update(n,{VERSION:"2.4.6",Signers:{},Protocol:{Json:t("./protocol/json"),Query:t("./protocol/query"),Rest:t("./protocol/rest"),RestJson:t("./protocol/rest_json"),RestXml:t("./protocol/rest_xml")},XML:{Builder:t("./xml/builder"),Parser:null},JSON:{Builder:t("./json/builder"),Parser:t("./json/parser")},Model:{Api:t("./model/api"),Operation:t("./model/operation"),Shape:t("./model/shape"),Paginator:t("./model/paginator"),ResourceWaiter:t("./model/resource_waiter")},util:t("./util"),apiLoader:function(){throw new Error("No API loader set")}}),t("./service"),t("./credentials"),t("./credentials/credential_provider_chain"),t("./credentials/temporary_credentials"),t("./credentials/web_identity_credentials"),t("./credentials/cognito_identity_credentials"),t("./credentials/saml_credentials"),t("./config"),t("./http"),t("./sequential_executor"),t("./event_listeners"),t("./request"),t("./response"),t("./resource_waiter"),t("./signers/request_signer"),t("./param_validator"),n.events=new n.SequentialExecutor},{"./config":23,"./credentials":25,"./credentials/cognito_identity_credentials":26,"./credentials/credential_provider_chain":27,"./credentials/saml_credentials":28,"./credentials/temporary_credentials":29,"./credentials/web_identity_credentials":30,"./event_listeners":36,"./http":37,"./json/builder":39,"./json/parser":40,"./model/api":41,"./model/operation":43,"./model/paginator":44,"./model/resource_waiter":45,"./model/shape":46,"./param_validator":47,"./protocol/json":48,"./protocol/query":49,"./protocol/rest":50,"./protocol/rest_json":51,"./protocol/rest_xml":52,"./request":56,"./resource_waiter":57,"./response":58,"./sequential_executor":60,"./service":61,"./signers/request_signer":77,"./util":84,"./xml/builder":86}],86:[function(t,e,r){function n(){}function i(t,e,r){switch(r.type){case"structure":return o(t,e,r);case"map":return s(t,e,r);case"list":return a(t,e,r);default:return u(t,e,r)}}function o(t,e,r){l.arrayEach(r.memberNames,function(n){var o=r.members[n];if("body"===o.location){var s=e[n],a=o.name;if(void 0!==s&&null!==s)if(o.isXmlAttribute)t.att(a,s);else if(o.flattened)i(t,s,o);else{var u=t.ele(a);c(u,o),i(u,s,o)}}})}function s(t,e,r){var n=r.key.name||"key",o=r.value.name||"value";l.each(e,function(e,s){var a=t.ele(r.flattened?r.name:"entry");i(a.ele(n),e,r.key),i(a.ele(o),s,r.value)})}function a(t,e,r){r.flattened?l.arrayEach(e,function(e){var n=r.member.name||r.name,o=t.ele(n);i(o,e,r.member)}):l.arrayEach(e,function(e){var n=r.member.name||"member",o=t.ele(n);i(o,e,r.member)})}function u(t,e,r){t.txt(r.toWireFormat(e))}function c(t,e){var r,n="xmlns";e.xmlNamespaceUri?(r=e.xmlNamespaceUri,e.xmlNamespacePrefix&&(n+=":"+e.xmlNamespacePrefix)):t.isRoot&&e.api.xmlNamespaceUri&&(r=e.api.xmlNamespaceUri),r&&t.att(n,r)}var l=t("../util"),h=t("xmlbuilder");n.prototype.toXML=function(t,e,r,n){var o=h.create(r);return c(o,e),i(o,t,e),o.children.length>0||n?o.root().toString():""},e.exports=n},{"../util":84,xmlbuilder:104}],104:[function(t,e,r){(function(){var r,n;n=t("lodash/object/assign"),r=t("./XMLBuilder"),e.exports.create=function(t,e,i,o){return o=n({},e,i,o),new r(t,o).root()}}).call(this)},{"./XMLBuilder":89,"lodash/object/assign":146}],146:[function(t,e,r){var n=t("../internal/baseAssign"),i=t("../internal/createAssigner"),o=i(n);e.exports=o},{"../internal/baseAssign":107,"../internal/createAssigner":125}],125:[function(t,e,r){function n(t){return function(){var e=arguments,r=e.length,n=e[0];if(2>r||null==n)return n;var s=e[r-2],a=e[r-1],u=e[3];r>3&&"function"==typeof s?(s=i(s,a,5),r-=2):(s=r>2&&"function"==typeof a?a:null,r-=s?1:0),u&&o(e[1],e[2],u)&&(s=3==r?null:s,r=2);for(var c=0;++c<r;){var l=e[c];l&&t(n,l,s)}return n}}var i=t("./bindCallback"),o=t("./isIterateeCall");e.exports=n},{"./bindCallback":124,"./isIterateeCall":131}],107:[function(t,e,r){function n(t,e,r){var n=o(e);if(!r)return i(e,t,n);for(var s=-1,a=n.length;++s<a;){var u=n[s],c=t[u],l=r(c,e[u],u,t,e);(l===l?l===c:c!==c)&&("undefined"!=typeof c||u in t)||(t[u]=l)}return t}var i=t("./baseCopy"),o=t("../object/keys");e.exports=n},{"../object/keys":148,"./baseCopy":109}],89:[function(t,e,r){(function(){var r,n,i,o,s;s=t("./XMLStringifier"),n=t("./XMLDeclaration"),i=t("./XMLDocType"),o=t("./XMLElement"),e.exports=r=function(){function t(t,e){var r,n;if(null==t)throw new Error("Root element needs a name");null==e&&(e={}),this.options=e,this.stringify=new s(e),n=new o(this,"doc"),r=n.element(t),r.isRoot=!0,r.documentObject=this,this.rootObject=r,e.headless||(r.declaration(e),(null!=e.pubID||null!=e.sysID)&&r.doctype(e))}return t.prototype.root=function(){return this.rootObject},t.prototype.end=function(t){return this.toString(t)},t.prototype.toString=function(t){var e,r,n,i,o,s,a,u;return i=(null!=t?t.pretty:void 0)||!1,e=null!=(s=null!=t?t.indent:void 0)?s:"  ",n=null!=(a=null!=t?t.offset:void 0)?a:0,r=null!=(u=null!=t?t.newline:void 0)?u:"\n",o="",null!=this.xmldec&&(o+=this.xmldec.toString(t)),null!=this.doctype&&(o+=this.doctype.toString(t)),o+=this.rootObject.toString(t),i&&o.slice(-r.length)===r&&(o=o.slice(0,-r.length)),o},t}()}).call(this)},{"./XMLDeclaration":96,"./XMLDocType":97,"./XMLElement":98,"./XMLStringifier":102}],102:[function(t,e,r){(function(){var t,r=function(t,e){return function(){return t.apply(e,arguments)}},n={}.hasOwnProperty;e.exports=t=function(){function t(t){this.assertLegalChar=r(this.assertLegalChar,this);var e,i,o;this.allowSurrogateChars=null!=t?t.allowSurrogateChars:void 0,i=(null!=t?t.stringify:void 0)||{};for(e in i)n.call(i,e)&&(o=i[e],this[e]=o)}return t.prototype.eleName=function(t){return t=""+t||"",this.assertLegalChar(t)},t.prototype.eleText=function(t){return t=""+t||"",this.assertLegalChar(this.elEscape(t))},t.prototype.cdata=function(t){if(t=""+t||"",t.match(/]]>/))throw new Error("Invalid CDATA text: "+t);return this.assertLegalChar(t)},t.prototype.comment=function(t){if(t=""+t||"",t.match(/--/))throw new Error("Comment text cannot contain double-hypen: "+t);return this.assertLegalChar(t)},t.prototype.raw=function(t){return""+t||""},t.prototype.attName=function(t){return""+t||""},t.prototype.attValue=function(t){return t=""+t||"",this.attEscape(t)},t.prototype.insTarget=function(t){return""+t||""},t.prototype.insValue=function(t){if(t=""+t||"",t.match(/\?>/))throw new Error("Invalid processing instruction value: "+t);return t},t.prototype.xmlVersion=function(t){if(t=""+t||"",!t.match(/1\.[0-9]+/))throw new Error("Invalid version number: "+t);return t},t.prototype.xmlEncoding=function(t){if(t=""+t||"",!t.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/))throw new Error("Invalid encoding: "+t);return t},t.prototype.xmlStandalone=function(t){return t?"yes":"no"},t.prototype.dtdPubID=function(t){return""+t||""},t.prototype.dtdSysID=function(t){return""+t||""},t.prototype.dtdElementValue=function(t){return""+t||""},t.prototype.dtdAttType=function(t){return""+t||""},t.prototype.dtdAttDefault=function(t){return null!=t?""+t||"":t},t.prototype.dtdEntityValue=function(t){return""+t||""},t.prototype.dtdNData=function(t){return""+t||""},t.prototype.convertAttKey="@",t.prototype.convertPIKey="?",t.prototype.convertTextKey="#text",t.prototype.convertCDataKey="#cdata",t.prototype.convertCommentKey="#comment",t.prototype.convertRawKey="#raw",t.prototype.convertListKey="#list",t.prototype.assertLegalChar=function(t){var e,r;if(e=this.allowSurrogateChars?/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/:/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/,r=t.match(e))throw new Error("Invalid character ("+r+") in string: "+t+" at index "+r.index);return t},t.prototype.elEscape=function(t){return t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\r/g,"&#xD;")},t.prototype.attEscape=function(t){return t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/"/g,"&quot;").replace(/\t/g,"&#x9;").replace(/\n/g,"&#xA;").replace(/\r/g,"&#xD;")},t}()}).call(this)},{}],96:[function(t,e,r){(function(){var r,n,i,o,s=function(t,e){function r(){this.constructor=t}for(var n in e)a.call(e,n)&&(t[n]=e[n]);return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},a={}.hasOwnProperty;i=t("lodash/object/create"),o=t("lodash/lang/isObject"),n=t("./XMLNode"),e.exports=r=function(t){function e(t,r,n,i){var s;e.__super__.constructor.call(this,t),o(r)&&(s=r,r=s.version,n=s.encoding,i=s.standalone),r||(r="1.0"),null!=r&&(this.version=this.stringify.xmlVersion(r)),null!=n&&(this.encoding=this.stringify.xmlEncoding(n)),null!=i&&(this.standalone=this.stringify.xmlStandalone(i))}return s(e,t),e.prototype.clone=function(){return i(e.prototype,this)},e.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<?xml",null!=this.version&&(s+=' version="'+this.version+'"'),null!=this.encoding&&(s+=' encoding="'+this.encoding+'"'),null!=this.standalone&&(s+=' standalone="'+this.standalone+'"'),s+="?>",o&&(s+=n),s},e}(n)}).call(this)},{"./XMLNode":99,"lodash/lang/isObject":143,"lodash/object/create":147}],99:[function(t,e,r){(function(){var r,n,i,o,s,a,u,c,l,h,p,f,d={}.hasOwnProperty;f=t("lodash/lang/isObject"),l=t("lodash/lang/isArray"),p=t("lodash/lang/isFunction"),h=t("lodash/lang/isEmpty"),s=null,r=null,n=null,i=null,o=null,u=null,c=null,e.exports=a=function(){function e(e){this.parent=e,this.options=this.parent.options,this.stringify=this.parent.stringify,null===s&&(s=t("./XMLElement"),r=t("./XMLCData"),n=t("./XMLComment"),i=t("./XMLDeclaration"),o=t("./XMLDocType"),u=t("./XMLRaw"),c=t("./XMLText"))}return e.prototype.clone=function(){throw new Error("Cannot clone generic XMLNode")},e.prototype.element=function(t,e,r){var n,i,o,s,a,u,c;if(s=null,null==e&&(e={}),e=e.valueOf(),f(e)||(u=[e,r],r=u[0],e=u[1]),null!=t&&(t=t.valueOf()),l(t))for(i=0,a=t.length;a>i;i++)n=t[i],s=this.element(n);else if(p(t))s=this.element(t.apply());else if(f(t))for(o in t)d.call(t,o)&&(c=t[o],p(c)&&(c=c.apply()),f(c)&&h(c)&&(c=null),!this.options.ignoreDecorators&&this.stringify.convertAttKey&&0===o.indexOf(this.stringify.convertAttKey)?s=this.attribute(o.substr(this.stringify.convertAttKey.length),c):!this.options.ignoreDecorators&&this.stringify.convertPIKey&&0===o.indexOf(this.stringify.convertPIKey)?s=this.instruction(o.substr(this.stringify.convertPIKey.length),c):f(c)?!this.options.ignoreDecorators&&this.stringify.convertListKey&&0===o.indexOf(this.stringify.convertListKey)&&l(c)?s=this.element(c):(s=this.element(o),s.element(c)):s=this.element(o,c));else s=!this.options.ignoreDecorators&&this.stringify.convertTextKey&&0===t.indexOf(this.stringify.convertTextKey)?this.text(r):!this.options.ignoreDecorators&&this.stringify.convertCDataKey&&0===t.indexOf(this.stringify.convertCDataKey)?this.cdata(r):!this.options.ignoreDecorators&&this.stringify.convertCommentKey&&0===t.indexOf(this.stringify.convertCommentKey)?this.comment(r):!this.options.ignoreDecorators&&this.stringify.convertRawKey&&0===t.indexOf(this.stringify.convertRawKey)?this.raw(r):this.node(t,e,r);if(null==s)throw new Error("Could not create any elements with: "+t);return s},e.prototype.insertBefore=function(t,e,r){var n,i,o;if(this.isRoot)throw new Error("Cannot insert elements at root level");return i=this.parent.children.indexOf(this),o=this.parent.children.splice(i),n=this.parent.element(t,e,r),Array.prototype.push.apply(this.parent.children,o),n},e.prototype.insertAfter=function(t,e,r){var n,i,o;if(this.isRoot)throw new Error("Cannot insert elements at root level");return i=this.parent.children.indexOf(this),o=this.parent.children.splice(i+1),n=this.parent.element(t,e,r),Array.prototype.push.apply(this.parent.children,o),n},e.prototype.remove=function(){var t,e;if(this.isRoot)throw new Error("Cannot remove the root element");return t=this.parent.children.indexOf(this),[].splice.apply(this.parent.children,[t,t-t+1].concat(e=[])),e,this.parent},e.prototype.node=function(t,e,r){var n,i;return null!=t&&(t=t.valueOf()),null==e&&(e={}),e=e.valueOf(),f(e)||(i=[e,r],r=i[0],e=i[1]),n=new s(this,t,e),null!=r&&n.text(r),this.children.push(n),n},e.prototype.text=function(t){var e;return e=new c(this,t),this.children.push(e),this},e.prototype.cdata=function(t){var e;return e=new r(this,t),this.children.push(e),this},e.prototype.comment=function(t){var e;return e=new n(this,t),this.children.push(e),this},e.prototype.raw=function(t){var e;return e=new u(this,t),this.children.push(e),this},e.prototype.declaration=function(t,e,r){var n,o;return n=this.document(),o=new i(n,t,e,r),n.xmldec=o,n.root()},e.prototype.doctype=function(t,e){var r,n;return r=this.document(),n=new o(r,t,e),r.doctype=n,n},e.prototype.up=function(){if(this.isRoot)throw new Error("The root node has no parent. Use doc() if you need to get the document object.");return this.parent},e.prototype.root=function(){var t;if(this.isRoot)return this;for(t=this.parent;!t.isRoot;)t=t.parent;return t},e.prototype.document=function(){return this.root().documentObject},e.prototype.end=function(t){return this.document().toString(t)},e.prototype.prev=function(){var t;if(this.isRoot)throw new Error("Root node has no siblings");if(t=this.parent.children.indexOf(this),1>t)throw new Error("Already at the first node");return this.parent.children[t-1]},e.prototype.next=function(){var t;if(this.isRoot)throw new Error("Root node has no siblings");if(t=this.parent.children.indexOf(this),-1===t||t===this.parent.children.length-1)throw new Error("Already at the last node");return this.parent.children[t+1]},e.prototype.importXMLBuilder=function(t){var e;return e=t.root().clone(),e.parent=this,e.isRoot=!1,this.children.push(e),this},e.prototype.ele=function(t,e,r){return this.element(t,e,r)},e.prototype.nod=function(t,e,r){return this.node(t,e,r)},e.prototype.txt=function(t){return this.text(t)},e.prototype.dat=function(t){return this.cdata(t)},e.prototype.com=function(t){return this.comment(t)},e.prototype.doc=function(){return this.document()},e.prototype.dec=function(t,e,r){return this.declaration(t,e,r)},e.prototype.dtd=function(t,e){return this.doctype(t,e)},e.prototype.e=function(t,e,r){return this.element(t,e,r)},e.prototype.n=function(t,e,r){return this.node(t,e,r)},e.prototype.t=function(t){return this.text(t)},e.prototype.d=function(t){return this.cdata(t)},e.prototype.c=function(t){return this.comment(t)},e.prototype.r=function(t){return this.raw(t)},e.prototype.u=function(){return this.up()},e}()}).call(this)},{"./XMLCData":90,"./XMLComment":91,"./XMLDeclaration":96,"./XMLDocType":97,"./XMLElement":98,"./XMLRaw":101,"./XMLText":103,"lodash/lang/isArray":139,"lodash/lang/isEmpty":140,"lodash/lang/isFunction":141,"lodash/lang/isObject":143}],140:[function(t,e,r){function n(t){if(null==t)return!0;var e=t.length;return a(e)&&(o(t)||c(t)||i(t)||u(t)&&s(t.splice))?!e:!l(t).length}var i=t("./isArguments"),o=t("./isArray"),s=t("./isFunction"),a=t("../internal/isLength"),u=t("../internal/isObjectLike"),c=t("./isString"),l=t("../object/keys");e.exports=n},{"../internal/isLength":132,"../internal/isObjectLike":133,"../object/keys":148,"./isArguments":138,"./isArray":139,"./isFunction":141,"./isString":144}],144:[function(t,e,r){function n(t){return"string"==typeof t||i(t)&&a.call(t)==o||!1}var i=t("../internal/isObjectLike"),o="[object String]",s=Object.prototype,a=s.toString;e.exports=n},{"../internal/isObjectLike":133}],103:[function(t,e,r){(function(){var r,n,i,o=function(t,e){function r(){this.constructor=t}for(var n in e)s.call(e,n)&&(t[n]=e[n]);return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},s={}.hasOwnProperty;i=t("lodash/object/create"),r=t("./XMLNode"),e.exports=n=function(t){function e(t,r){if(e.__super__.constructor.call(this,t),null==r)throw new Error("Missing element text");this.value=this.stringify.eleText(r)}return o(e,t),e.prototype.clone=function(){return i(e.prototype,this)},e.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+=this.value,o&&(s+=n),s},e}(r)}).call(this)},{"./XMLNode":99,"lodash/object/create":147}],101:[function(t,e,r){(function(){var r,n,i,o=function(t,e){function r(){this.constructor=t}for(var n in e)s.call(e,n)&&(t[n]=e[n]);return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},s={}.hasOwnProperty;i=t("lodash/object/create"),r=t("./XMLNode"),e.exports=n=function(t){function e(t,r){if(e.__super__.constructor.call(this,t),null==r)throw new Error("Missing raw text");this.value=this.stringify.raw(r)}return o(e,t),e.prototype.clone=function(){return i(e.prototype,this)},e.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+=this.value,o&&(s+=n),s},e}(r)}).call(this)},{"./XMLNode":99,"lodash/object/create":147}],98:[function(t,e,r){(function(){var r,n,i,o,s,a,u,c,l,h=function(t,e){function r(){this.constructor=t}for(var n in e)p.call(e,n)&&(t[n]=e[n]);return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},p={}.hasOwnProperty;s=t("lodash/object/create"),l=t("lodash/lang/isObject"),u=t("lodash/lang/isArray"),c=t("lodash/lang/isFunction"),a=t("lodash/collection/every"),i=t("./XMLNode"),r=t("./XMLAttribute"),o=t("./XMLProcessingInstruction"),e.exports=n=function(t){function e(t,r,n){if(e.__super__.constructor.call(this,t),null==r)throw new Error("Missing element name");this.name=this.stringify.eleName(r),this.children=[],this.instructions=[],this.attributes={},null!=n&&this.attribute(n)}return h(e,t),e.prototype.clone=function(){var t,r,n,i,o,a,u,c;n=s(e.prototype,this),n.isRoot&&(n.documentObject=null),n.attributes={},u=this.attributes;for(r in u)p.call(u,r)&&(t=u[r],n.attributes[r]=t.clone());for(n.instructions=[],c=this.instructions,i=0,o=c.length;o>i;i++)a=c[i],n.instructions.push(a.clone());return n.children=[],this.children.forEach(function(t){var e;return e=t.clone(),e.parent=n,n.children.push(e)}),n},e.prototype.attribute=function(t,e){var n,i;if(null!=t&&(t=t.valueOf()),l(t))for(n in t)p.call(t,n)&&(i=t[n],this.attribute(n,i));else c(e)&&(e=e.apply()),this.options.skipNullAttributes&&null==e||(this.attributes[t]=new r(this,t,e));return this},e.prototype.removeAttribute=function(t){var e,r,n;if(null==t)throw new Error("Missing attribute name");if(t=t.valueOf(),u(t))for(r=0,n=t.length;n>r;r++)e=t[r],delete this.attributes[e];else delete this.attributes[t];return this},e.prototype.instruction=function(t,e){var r,n,i,s,a;if(null!=t&&(t=t.valueOf()),null!=e&&(e=e.valueOf()),u(t))for(r=0,a=t.length;a>r;r++)n=t[r],this.instruction(n);else if(l(t))for(n in t)p.call(t,n)&&(i=t[n],this.instruction(n,i));else c(e)&&(e=e.apply()),s=new o(this,t,e),this.instructions.push(s);return this},e.prototype.toString=function(t,e){var r,n,i,o,s,u,c,l,h,f,d,y,v,g,m,b,w,E,_,x;for(y=(null!=t?t.pretty:void 0)||!1,o=null!=(g=null!=t?t.indent:void 0)?g:"  ",d=null!=(m=null!=t?t.offset:void 0)?m:0,f=null!=(b=null!=t?t.newline:void 0)?b:"\n",e||(e=0),x=new Array(e+d+1).join(o),v="",w=this.instructions,i=0,c=w.length;c>i;i++)s=w[i],v+=s.toString(t,e+1);y&&(v+=x),v+="<"+this.name,E=this.attributes;for(h in E)p.call(E,h)&&(r=E[h],v+=r.toString(t));if(0===this.children.length||a(this.children,function(t){return""===t.value}))v+="/>",y&&(v+=f);else if(y&&1===this.children.length&&null!=this.children[0].value)v+=">",v+=this.children[0].value,v+="</"+this.name+">",v+=f;else{for(v+=">",y&&(v+=f),_=this.children,u=0,l=_.length;l>u;u++)n=_[u],v+=n.toString(t,e+1);y&&(v+=x),v+="</"+this.name+">",y&&(v+=f)}return v},e.prototype.att=function(t,e){return this.attribute(t,e)},e.prototype.ins=function(t,e){return this.instruction(t,e)},e.prototype.a=function(t,e){return this.attribute(t,e)},e.prototype.i=function(t,e){return this.instruction(t,e)},e}(i)}).call(this)},{"./XMLAttribute":88,"./XMLNode":99,"./XMLProcessingInstruction":100,"lodash/collection/every":105,"lodash/lang/isArray":139,"lodash/lang/isFunction":141,"lodash/lang/isObject":143,"lodash/object/create":147}],141:[function(t,e,r){(function(r){var n=t("../internal/baseIsFunction"),i=t("./isNative"),o="[object Function]",s=Object.prototype,a=s.toString,u=i(u=r.Uint8Array)&&u,c=n(/x/)||u&&!n(u)?function(t){return a.call(t)==o}:n;e.exports=c}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../internal/baseIsFunction":117,"./isNative":142}],117:[function(t,e,r){function n(t){return"function"==typeof t||!1}e.exports=n},{}],105:[function(t,e,r){function n(t,e,r){var n=a(t)?i:s;return("function"!=typeof e||"undefined"!=typeof r)&&(e=o(e,r,3)),n(t,e)}var i=t("../internal/arrayEvery"),o=t("../internal/baseCallback"),s=t("../internal/baseEvery"),a=t("../lang/isArray");e.exports=n},{"../internal/arrayEvery":106,"../internal/baseCallback":108,"../internal/baseEvery":112,"../lang/isArray":139}],112:[function(t,e,r){function n(t,e){var r=!0;return i(t,function(t,n,i){return r=!!e(t,n,i)}),r}var i=t("./baseEach");e.exports=n},{"./baseEach":111}],111:[function(t,e,r){function n(t,e){var r=t?t.length:0;if(!o(r))return i(t,e);for(var n=-1,a=s(t);++n<r&&e(a[n],n,a)!==!1;);return t}var i=t("./baseForOwn"),o=t("./isLength"),s=t("./toObject");e.exports=n},{"./baseForOwn":114,"./isLength":132,"./toObject":137}],114:[function(t,e,r){function n(t,e){return i(t,e,o)}var i=t("./baseFor"),o=t("../object/keys");e.exports=n},{"../object/keys":148,"./baseFor":113}],113:[function(t,e,r){function n(t,e,r){for(var n=-1,o=i(t),s=r(t),a=s.length;++n<a;){var u=s[n];if(e(o[u],u,o)===!1)break}return t}var i=t("./toObject");e.exports=n},{"./toObject":137}],137:[function(t,e,r){function n(t){return i(t)?t:Object(t)}var i=t("../lang/isObject");e.exports=n},{"../lang/isObject":143}],108:[function(t,e,r){function n(t,e,r){var n=typeof t;return"function"==n?"undefined"!=typeof e&&c(t)?a(t,e,r):t:null==t?u:"object"==n?i(t):"undefined"==typeof e?s(t+""):o(t+"",e)}var i=t("./baseMatches"),o=t("./baseMatchesProperty"),s=t("./baseProperty"),a=t("./bindCallback"),u=t("../utility/identity"),c=t("./isBindable");e.exports=n},{"../utility/identity":152,"./baseMatches":119,"./baseMatchesProperty":120,"./baseProperty":121,"./bindCallback":124,"./isBindable":129}],129:[function(t,e,r){function n(t){var e=!(s.funcNames?t.name:s.funcDecomp);if(!e){var r=c.call(t);s.funcNames||(e=!a.test(r)),e||(e=u.test(r)||o(t),i(t,e))}return e}var i=t("./baseSetData"),o=t("../lang/isNative"),s=t("../support"),a=/^\s*function[ \n\r\t]+\w/,u=/\bthis\b/,c=Function.prototype.toString;e.exports=n},{"../lang/isNative":142,"../support":151,"./baseSetData":122}],122:[function(t,e,r){var n=t("../utility/identity"),i=t("./metaMap"),o=i?function(t,e){return i.set(t,e),t}:n;e.exports=o},{"../utility/identity":152,"./metaMap":135}],135:[function(t,e,r){(function(r){var n=t("../lang/isNative"),i=n(i=r.WeakMap)&&i,o=i&&new i;e.exports=o}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../lang/isNative":142}],124:[function(t,e,r){function n(t,e,r){if("function"!=typeof t)return i;if("undefined"==typeof e)return t;switch(r){case 1:return function(r){return t.call(e,r)};case 3:return function(r,n,i){return t.call(e,r,n,i)};case 4:return function(r,n,i,o){return t.call(e,r,n,i,o)};case 5:return function(r,n,i,o,s){return t.call(e,r,n,i,o,s)}}return function(){return t.apply(e,arguments)}}var i=t("../utility/identity");e.exports=n},{"../utility/identity":152}],152:[function(t,e,r){function n(t){return t}e.exports=n},{}],121:[function(t,e,r){function n(t){return function(e){return null==e?void 0:e[t]}}e.exports=n},{}],120:[function(t,e,r){function n(t,e){return o(e)?function(r){return null!=r&&r[t]===e}:function(r){return null!=r&&i(e,r[t],null,!0)}}var i=t("./baseIsEqual"),o=t("./isStrictComparable");e.exports=n},{"./baseIsEqual":115,"./isStrictComparable":134}],119:[function(t,e,r){function n(t){var e=s(t),r=e.length;if(1==r){var n=e[0],a=t[n];if(o(a))return function(t){return null!=t&&t[n]===a&&u.call(t,n)}}for(var c=Array(r),l=Array(r);r--;)a=t[e[r]],c[r]=a,l[r]=o(a);return function(t){return i(t,e,c,l)}}var i=t("./baseIsMatch"),o=t("./isStrictComparable"),s=t("../object/keys"),a=Object.prototype,u=a.hasOwnProperty;e.exports=n},{"../object/keys":148,"./baseIsMatch":118,"./isStrictComparable":134}],134:[function(t,e,r){function n(t){return t===t&&(0===t?1/t>0:!i(t))}var i=t("../lang/isObject");e.exports=n},{"../lang/isObject":143}],118:[function(t,e,r){function n(t,e,r,n,o){var a=e.length;if(null==t)return!a;for(var u=-1,c=!o;++u<a;)if(c&&n[u]?r[u]!==t[e[u]]:!s.call(t,e[u]))return!1;for(u=-1;++u<a;){var l=e[u];if(c&&n[u])var h=s.call(t,l);else{var p=t[l],f=r[u];h=o?o(p,f,l):void 0,"undefined"==typeof h&&(h=i(f,p,o,!0))}if(!h)return!1}return!0}var i=t("./baseIsEqual"),o=Object.prototype,s=o.hasOwnProperty;e.exports=n},{"./baseIsEqual":115}],115:[function(t,e,r){function n(t,e,r,o,s,a){if(t===e)return 0!==t||1/t==1/e;var u=typeof t,c=typeof e;return"function"!=u&&"object"!=u&&"function"!=c&&"object"!=c||null==t||null==e?t!==t&&e!==e:i(t,e,n,r,o,s,a)}var i=t("./baseIsEqualDeep");e.exports=n},{"./baseIsEqualDeep":116}],116:[function(t,e,r){function n(t,e,r,n,p,y,v){var g=a(t),m=a(e),b=l,w=l;g||(b=d.call(t),b==c?b=h:b!=h&&(g=u(t))),m||(w=d.call(e),w==c?w=h:w!=h&&(m=u(e)));var E=b==h,_=w==h,x=b==w;if(x&&!g&&!E)return o(t,e,b);var S=E&&f.call(t,"__wrapped__"),A=_&&f.call(e,"__wrapped__");if(S||A)return r(S?t.value():t,A?e.value():e,n,p,y,v);if(!x)return!1;y||(y=[]),v||(v=[]);for(var R=y.length;R--;)if(y[R]==t)return v[R]==e;y.push(t),v.push(e);var T=(g?i:s)(t,e,r,n,p,y,v);return y.pop(),v.pop(),T}var i=t("./equalArrays"),o=t("./equalByTag"),s=t("./equalObjects"),a=t("../lang/isArray"),u=t("../lang/isTypedArray"),c="[object Arguments]",l="[object Array]",h="[object Object]",p=Object.prototype,f=p.hasOwnProperty,d=p.toString;e.exports=n},{"../lang/isArray":139,"../lang/isTypedArray":145,"./equalArrays":126,"./equalByTag":127,"./equalObjects":128}],145:[function(t,e,r){function n(t){return o(t)&&i(t.length)&&C[L.call(t)]||!1}var i=t("../internal/isLength"),o=t("../internal/isObjectLike"),s="[object Arguments]",a="[object Array]",u="[object Boolean]",c="[object Date]",l="[object Error]",h="[object Function]",p="[object Map]",f="[object Number]",d="[object Object]",y="[object RegExp]",v="[object Set]",g="[object String]",m="[object WeakMap]",b="[object ArrayBuffer]",w="[object Float32Array]",E="[object Float64Array]",_="[object Int8Array]",x="[object Int16Array]",S="[object Int32Array]",A="[object Uint8Array]",R="[object Uint8ClampedArray]",T="[object Uint16Array]",I="[object Uint32Array]",C={};C[w]=C[E]=C[_]=C[x]=C[S]=C[A]=C[R]=C[T]=C[I]=!0,C[s]=C[a]=C[b]=C[u]=C[c]=C[l]=C[h]=C[p]=C[f]=C[d]=C[y]=C[v]=C[g]=C[m]=!1;var j=Object.prototype,L=j.toString;e.exports=n},{"../internal/isLength":132,"../internal/isObjectLike":133}],128:[function(t,e,r){function n(t,e,r,n,o,a,u){var c=i(t),l=c.length,h=i(e),p=h.length;if(l!=p&&!o)return!1;for(var f,d=-1;++d<l;){var y=c[d],v=s.call(e,y);if(v){var g=t[y],m=e[y];v=void 0,n&&(v=o?n(m,g,y):n(g,m,y)),"undefined"==typeof v&&(v=g&&g===m||r(g,m,n,o,a,u))}if(!v)return!1;f||(f="constructor"==y)}if(!f){var b=t.constructor,w=e.constructor;if(b!=w&&"constructor"in t&&"constructor"in e&&!("function"==typeof b&&b instanceof b&&"function"==typeof w&&w instanceof w))return!1}return!0}var i=t("../object/keys"),o=Object.prototype,s=o.hasOwnProperty;e.exports=n},{"../object/keys":148}],127:[function(t,e,r){function n(t,e,r){switch(r){case i:case o:return+t==+e;case s:return t.name==e.name&&t.message==e.message;case a:return t!=+t?e!=+e:0==t?1/t==1/e:t==+e;case u:case c:return t==e+""}return!1}var i="[object Boolean]",o="[object Date]",s="[object Error]",a="[object Number]",u="[object RegExp]",c="[object String]";e.exports=n},{}],126:[function(t,e,r){function n(t,e,r,n,i,o,s){var a=-1,u=t.length,c=e.length,l=!0;if(u!=c&&!(i&&c>u))return!1;for(;l&&++a<u;){var h=t[a],p=e[a];if(l=void 0,n&&(l=i?n(p,h,a):n(h,p,a)),"undefined"==typeof l)if(i)for(var f=c;f--&&(p=e[f],!(l=h&&h===p||r(h,p,n,i,o,s))););else l=h&&h===p||r(h,p,n,i,o,s)}return!!l}e.exports=n},{}],106:[function(t,e,r){function n(t,e){for(var r=-1,n=t.length;++r<n;)if(!e(t[r],r,t))return!1;return!0}e.exports=n},{}],88:[function(t,e,r){(function(){var r,n;n=t("lodash/object/create"),e.exports=r=function(){function t(t,e,r){if(this.stringify=t.stringify,null==e)throw new Error("Missing attribute name of element "+t.name);if(null==r)throw new Error("Missing attribute value for attribute "+e+" of element "+t.name);this.name=this.stringify.attName(e),this.value=this.stringify.attValue(r)}return t.prototype.clone=function(){return n(t.prototype,this)},t.prototype.toString=function(t,e){return" "+this.name+'="'+this.value+'"'},t}()}).call(this)},{"lodash/object/create":147}],97:[function(t,e,r){(function(){var r,n,i,o,s,a,u,c,l,h;l=t("lodash/object/create"),h=t("lodash/lang/isObject"),r=t("./XMLCData"),n=t("./XMLComment"),i=t("./XMLDTDAttList"),s=t("./XMLDTDEntity"),o=t("./XMLDTDElement"),a=t("./XMLDTDNotation"),c=t("./XMLProcessingInstruction"),e.exports=u=function(){function t(t,e,r){var n,i;this.documentObject=t,this.stringify=this.documentObject.stringify,this.children=[],h(e)&&(n=e,e=n.pubID,r=n.sysID),null==r&&(i=[e,r],r=i[0],e=i[1]),null!=e&&(this.pubID=this.stringify.dtdPubID(e)),null!=r&&(this.sysID=this.stringify.dtdSysID(r))}return t.prototype.clone=function(){return l(t.prototype,this)},t.prototype.element=function(t,e){var r;return r=new o(this,t,e),this.children.push(r),this},t.prototype.attList=function(t,e,r,n,o){var s;return s=new i(this,t,e,r,n,o),this.children.push(s),this},t.prototype.entity=function(t,e){var r;return r=new s(this,!1,t,e),this.children.push(r),this},t.prototype.pEntity=function(t,e){var r;return r=new s(this,!0,t,e),this.children.push(r),this},t.prototype.notation=function(t,e){var r;return r=new a(this,t,e),this.children.push(r),this},t.prototype.cdata=function(t){var e;return e=new r(this,t),this.children.push(e),this},t.prototype.comment=function(t){var e;return e=new n(this,t),this.children.push(e),this},t.prototype.instruction=function(t,e){var r;return r=new c(this,t,e),this.children.push(r),this},t.prototype.root=function(){return this.documentObject.root()},t.prototype.document=function(){return this.documentObject},t.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l,h,p,f,d;if(u=(null!=t?t.pretty:void 0)||!1,i=null!=(l=null!=t?t.indent:void 0)?l:"  ",a=null!=(h=null!=t?t.offset:void 0)?h:0,s=null!=(p=null!=t?t.newline:void 0)?p:"\n",e||(e=0),d=new Array(e+a+1).join(i),c="",u&&(c+=d),c+="<!DOCTYPE "+this.root().name,this.pubID&&this.sysID?c+=' PUBLIC "'+this.pubID+'" "'+this.sysID+'"':this.sysID&&(c+=' SYSTEM "'+this.sysID+'"'),this.children.length>0){for(c+=" [",u&&(c+=s),f=this.children,n=0,o=f.length;o>n;n++)r=f[n],c+=r.toString(t,e+1);c+="]"}return c+=">",u&&(c+=s),c},t.prototype.ele=function(t,e){return this.element(t,e)},t.prototype.att=function(t,e,r,n,i){
return this.attList(t,e,r,n,i)},t.prototype.ent=function(t,e){return this.entity(t,e)},t.prototype.pent=function(t,e){return this.pEntity(t,e)},t.prototype.not=function(t,e){return this.notation(t,e)},t.prototype.dat=function(t){return this.cdata(t)},t.prototype.com=function(t){return this.comment(t)},t.prototype.ins=function(t,e){return this.instruction(t,e)},t.prototype.up=function(){return this.root()},t.prototype.doc=function(){return this.document()},t}()}).call(this)},{"./XMLCData":90,"./XMLComment":91,"./XMLDTDAttList":92,"./XMLDTDElement":93,"./XMLDTDEntity":94,"./XMLDTDNotation":95,"./XMLProcessingInstruction":100,"lodash/lang/isObject":143,"lodash/object/create":147}],100:[function(t,e,r){(function(){var r,n;n=t("lodash/object/create"),e.exports=r=function(){function t(t,e,r){if(this.stringify=t.stringify,null==e)throw new Error("Missing instruction target");this.target=this.stringify.insTarget(e),r&&(this.value=this.stringify.insValue(r))}return t.prototype.clone=function(){return n(t.prototype,this)},t.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<?",s+=this.target,this.value&&(s+=" "+this.value),s+="?>",o&&(s+=n),s},t}()}).call(this)},{"lodash/object/create":147}],95:[function(t,e,r){(function(){var r,n;n=t("lodash/object/create"),e.exports=r=function(){function t(t,e,r){if(this.stringify=t.stringify,null==e)throw new Error("Missing notation name");if(!r.pubID&&!r.sysID)throw new Error("Public or system identifiers are required for an external entity");this.name=this.stringify.eleName(e),null!=r.pubID&&(this.pubID=this.stringify.dtdPubID(r.pubID)),null!=r.sysID&&(this.sysID=this.stringify.dtdSysID(r.sysID))}return t.prototype.clone=function(){return n(t.prototype,this)},t.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<!NOTATION "+this.name,this.pubID&&this.sysID?s+=' PUBLIC "'+this.pubID+'" "'+this.sysID+'"':this.pubID?s+=' PUBLIC "'+this.pubID+'"':this.sysID&&(s+=' SYSTEM "'+this.sysID+'"'),s+=">",o&&(s+=n),s},t}()}).call(this)},{"lodash/object/create":147}],94:[function(t,e,r){(function(){var r,n,i;n=t("lodash/object/create"),i=t("lodash/lang/isObject"),e.exports=r=function(){function t(t,e,r,n){if(this.stringify=t.stringify,null==r)throw new Error("Missing entity name");if(null==n)throw new Error("Missing entity value");if(this.pe=!!e,this.name=this.stringify.eleName(r),i(n)){if(!n.pubID&&!n.sysID)throw new Error("Public and/or system identifiers are required for an external entity");if(n.pubID&&!n.sysID)throw new Error("System identifier is required for a public external entity");if(null!=n.pubID&&(this.pubID=this.stringify.dtdPubID(n.pubID)),null!=n.sysID&&(this.sysID=this.stringify.dtdSysID(n.sysID)),null!=n.nData&&(this.nData=this.stringify.dtdNData(n.nData)),this.pe&&this.nData)throw new Error("Notation declaration is not allowed in a parameter entity")}else this.value=this.stringify.dtdEntityValue(n)}return t.prototype.clone=function(){return n(t.prototype,this)},t.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<!ENTITY",this.pe&&(s+=" %"),s+=" "+this.name,this.value?s+=' "'+this.value+'"':(this.pubID&&this.sysID?s+=' PUBLIC "'+this.pubID+'" "'+this.sysID+'"':this.sysID&&(s+=' SYSTEM "'+this.sysID+'"'),this.nData&&(s+=" NDATA "+this.nData)),s+=">",o&&(s+=n),s},t}()}).call(this)},{"lodash/lang/isObject":143,"lodash/object/create":147}],93:[function(t,e,r){(function(){var r,n,i;n=t("lodash/object/create"),i=t("lodash/lang/isArray"),e.exports=r=function(){function t(t,e,r){if(this.stringify=t.stringify,null==e)throw new Error("Missing DTD element name");r||(r="(#PCDATA)"),i(r)&&(r="("+r.join(",")+")"),this.name=this.stringify.eleName(e),this.value=this.stringify.dtdElementValue(r)}return t.prototype.clone=function(){return n(t.prototype,this)},t.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<!ELEMENT "+this.name+" "+this.value+">",o&&(s+=n),s},t}()}).call(this)},{"lodash/lang/isArray":139,"lodash/object/create":147}],92:[function(t,e,r){(function(){var r,n;n=t("lodash/object/create"),e.exports=r=function(){function t(t,e,r,n,i,o){if(this.stringify=t.stringify,null==e)throw new Error("Missing DTD element name");if(null==r)throw new Error("Missing DTD attribute name");if(!n)throw new Error("Missing DTD attribute type");if(!i)throw new Error("Missing DTD attribute default");if(0!==i.indexOf("#")&&(i="#"+i),!i.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");if(o&&!i.match(/^(#FIXED|#DEFAULT)$/))throw new Error("Default value only applies to #FIXED or #DEFAULT");this.elementName=this.stringify.eleName(e),this.attributeName=this.stringify.attName(r),this.attributeType=this.stringify.dtdAttType(n),this.defaultValue=this.stringify.dtdAttDefault(o),this.defaultValueType=i}return t.prototype.clone=function(){return n(t.prototype,this)},t.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<!ATTLIST "+this.elementName+" "+this.attributeName+" "+this.attributeType,"#DEFAULT"!==this.defaultValueType&&(s+=" "+this.defaultValueType),this.defaultValue&&(s+=' "'+this.defaultValue+'"'),s+=">",o&&(s+=n),s},t}()}).call(this)},{"lodash/object/create":147}],91:[function(t,e,r){(function(){var r,n,i,o=function(t,e){function r(){this.constructor=t}for(var n in e)s.call(e,n)&&(t[n]=e[n]);return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},s={}.hasOwnProperty;i=t("lodash/object/create"),n=t("./XMLNode"),e.exports=r=function(t){function e(t,r){if(e.__super__.constructor.call(this,t),null==r)throw new Error("Missing comment text");this.text=this.stringify.comment(r)}return o(e,t),e.prototype.clone=function(){return i(e.prototype,this)},e.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<!-- "+this.text+" -->",o&&(s+=n),s},e}(n)}).call(this)},{"./XMLNode":99,"lodash/object/create":147}],90:[function(t,e,r){(function(){var r,n,i,o=function(t,e){function r(){this.constructor=t}for(var n in e)s.call(e,n)&&(t[n]=e[n]);return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},s={}.hasOwnProperty;i=t("lodash/object/create"),n=t("./XMLNode"),e.exports=r=function(t){function e(t,r){if(e.__super__.constructor.call(this,t),null==r)throw new Error("Missing CDATA text");this.text=this.stringify.cdata(r)}return o(e,t),e.prototype.clone=function(){return i(e.prototype,this)},e.prototype.toString=function(t,e){var r,n,i,o,s,a,u,c,l;return o=(null!=t?t.pretty:void 0)||!1,r=null!=(a=null!=t?t.indent:void 0)?a:"  ",i=null!=(u=null!=t?t.offset:void 0)?u:0,n=null!=(c=null!=t?t.newline:void 0)?c:"\n",e||(e=0),l=new Array(e+i+1).join(r),s="",o&&(s+=l),s+="<![CDATA["+this.text+"]]>",o&&(s+=n),s},e}(n)}).call(this)},{"./XMLNode":99,"lodash/object/create":147}],147:[function(t,e,r){function n(t,e,r){var n=o(t);return r&&s(t,e,r)&&(e=null),e?i(e,n,a(e)):n}var i=t("../internal/baseCopy"),o=t("../internal/baseCreate"),s=t("../internal/isIterateeCall"),a=t("./keys");e.exports=n},{"../internal/baseCopy":109,"../internal/baseCreate":110,"../internal/isIterateeCall":131,"./keys":148}],148:[function(t,e,r){var n=t("../internal/isLength"),i=t("../lang/isNative"),o=t("../lang/isObject"),s=t("../internal/shimKeys"),a=i(a=Object.keys)&&a,u=a?function(t){if(t)var e=t.constructor,r=t.length;return"function"==typeof e&&e.prototype===t||"function"!=typeof t&&r&&n(r)?s(t):o(t)?a(t):[]}:s;e.exports=u},{"../internal/isLength":132,"../internal/shimKeys":136,"../lang/isNative":142,"../lang/isObject":143}],136:[function(t,e,r){function n(t){for(var e=u(t),r=e.length,n=r&&t.length,l=n&&a(n)&&(o(t)||c.nonEnumArgs&&i(t)),p=-1,f=[];++p<r;){var d=e[p];(l&&s(d,n)||h.call(t,d))&&f.push(d)}return f}var i=t("../lang/isArguments"),o=t("../lang/isArray"),s=t("./isIndex"),a=t("./isLength"),u=t("../object/keysIn"),c=t("../support"),l=Object.prototype,h=l.hasOwnProperty;e.exports=n},{"../lang/isArguments":138,"../lang/isArray":139,"../object/keysIn":149,"../support":151,"./isIndex":130,"./isLength":132}],149:[function(t,e,r){function n(t){if(null==t)return[];u(t)||(t=Object(t));var e=t.length;e=e&&a(e)&&(o(t)||c.nonEnumArgs&&i(t))&&e||0;for(var r=t.constructor,n=-1,l="function"==typeof r&&r.prototype===t,p=Array(e),f=e>0;++n<e;)p[n]=n+"";for(var d in t)f&&s(d,e)||"constructor"==d&&(l||!h.call(t,d))||p.push(d);return p}var i=t("../lang/isArguments"),o=t("../lang/isArray"),s=t("../internal/isIndex"),a=t("../internal/isLength"),u=t("../lang/isObject"),c=t("../support"),l=Object.prototype,h=l.hasOwnProperty;e.exports=n},{"../internal/isIndex":130,"../internal/isLength":132,"../lang/isArguments":138,"../lang/isArray":139,"../lang/isObject":143,"../support":151}],151:[function(t,e,r){(function(r){var n=t("./lang/isNative"),i=/\bthis\b/,o=Object.prototype,s=(s=r.window)&&s.document,a=o.propertyIsEnumerable,u={};!function(t){u.funcDecomp=!n(r.WinRTError)&&i.test(function(){return this}),u.funcNames="string"==typeof Function.name;try{u.dom=11===s.createDocumentFragment().nodeType}catch(e){u.dom=!1}try{u.nonEnumArgs=!a.call(arguments,1)}catch(e){u.nonEnumArgs=!0}}(0,0),e.exports=u}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./lang/isNative":142}],139:[function(t,e,r){var n=t("../internal/isLength"),i=t("./isNative"),o=t("../internal/isObjectLike"),s="[object Array]",a=Object.prototype,u=a.toString,c=i(c=Array.isArray)&&c,l=c||function(t){return o(t)&&n(t.length)&&u.call(t)==s||!1};e.exports=l},{"../internal/isLength":132,"../internal/isObjectLike":133,"./isNative":142}],142:[function(t,e,r){function n(t){return null==t?!1:l.call(t)==s?h.test(c.call(t)):o(t)&&a.test(t)||!1}var i=t("../string/escapeRegExp"),o=t("../internal/isObjectLike"),s="[object Function]",a=/^\[object .+?Constructor\]$/,u=Object.prototype,c=Function.prototype.toString,l=u.toString,h=RegExp("^"+i(l).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=n},{"../internal/isObjectLike":133,"../string/escapeRegExp":150}],150:[function(t,e,r){function n(t){return t=i(t),t&&s.test(t)?t.replace(o,"\\$&"):t}var i=t("../internal/baseToString"),o=/[.*+?^${}()|[\]\/\\]/g,s=RegExp(o.source);e.exports=n},{"../internal/baseToString":123}],123:[function(t,e,r){function n(t){return"string"==typeof t?t:null==t?"":t+""}e.exports=n},{}],138:[function(t,e,r){function n(t){var e=o(t)?t.length:void 0;return i(e)&&u.call(t)==s||!1}var i=t("../internal/isLength"),o=t("../internal/isObjectLike"),s="[object Arguments]",a=Object.prototype,u=a.toString;e.exports=n},{"../internal/isLength":132,"../internal/isObjectLike":133}],133:[function(t,e,r){function n(t){return t&&"object"==typeof t||!1}e.exports=n},{}],131:[function(t,e,r){function n(t,e,r){if(!s(r))return!1;var n=typeof e;if("number"==n)var a=r.length,u=o(a)&&i(e,a);else u="string"==n&&e in r;if(u){var c=r[e];return t===t?t===c:c!==c}return!1}var i=t("./isIndex"),o=t("./isLength"),s=t("../lang/isObject");e.exports=n},{"../lang/isObject":143,"./isIndex":130,"./isLength":132}],132:[function(t,e,r){function n(t){return"number"==typeof t&&t>-1&&t%1==0&&i>=t}var i=Math.pow(2,53)-1;e.exports=n},{}],130:[function(t,e,r){function n(t,e){return t=+t,e=null==e?i:e,t>-1&&t%1==0&&e>t}var i=Math.pow(2,53)-1;e.exports=n},{}],110:[function(t,e,r){(function(r){var n=t("../lang/isObject"),i=function(){function t(){}return function(e){if(n(e)){t.prototype=e;var i=new t;t.prototype=null}return i||r.Object()}}();e.exports=i}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../lang/isObject":143}],143:[function(t,e,r){function n(t){var e=typeof t;return"function"==e||t&&"object"==e||!1}e.exports=n},{}],109:[function(t,e,r){function n(t,e,r){r||(r=e,e={});for(var n=-1,i=r.length;++n<i;){var o=r[n];e[o]=t[o]}return e}e.exports=n},{}],77:[function(t,e,r){var n=t("../core"),i=n.util.inherit;n.Signers.RequestSigner=i({constructor:function(t){this.request=t}}),n.Signers.RequestSigner.getVersion=function(t){switch(t){case"v2":return n.Signers.V2;case"v3":return n.Signers.V3;case"v4":return n.Signers.V4;case"s3":return n.Signers.S3;case"v3https":return n.Signers.V3Https}throw new Error("Unknown signing version "+t)},t("./v2"),t("./v3"),t("./v3https"),t("./v4"),t("./s3"),t("./presign")},{"../core":24,"./presign":76,"./s3":78,"./v2":79,"./v3":80,"./v3https":81,"./v4":82}],82:[function(t,e,r){var n=t("../core"),i=n.util.inherit,o={},s="presigned-expires";n.Signers.V4=i(n.Signers.RequestSigner,{constructor:function(t,e,r){n.Signers.RequestSigner.call(this,t),this.serviceName=e,this.signatureCache=r},algorithm:"AWS4-HMAC-SHA256",addAuthorization:function(t,e){var r=n.util.date.iso8601(e).replace(/[:\-]|\.\d{3}/g,"");this.isPresigned()?this.updateForPresigned(t,r):this.addHeaders(t,r),this.request.headers.Authorization=this.authorization(t,r)},addHeaders:function(t,e){this.request.headers["X-Amz-Date"]=e,t.sessionToken&&(this.request.headers["x-amz-security-token"]=t.sessionToken)},updateForPresigned:function(t,e){var r=this.credentialString(e),i={"X-Amz-Date":e,"X-Amz-Algorithm":this.algorithm,"X-Amz-Credential":t.accessKeyId+"/"+r,"X-Amz-Expires":this.request.headers[s],"X-Amz-SignedHeaders":this.signedHeaders()};t.sessionToken&&(i["X-Amz-Security-Token"]=t.sessionToken),this.request.headers["Content-Type"]&&(i["Content-Type"]=this.request.headers["Content-Type"]),this.request.headers["Content-MD5"]&&(i["Content-MD5"]=this.request.headers["Content-MD5"]),this.request.headers["Cache-Control"]&&(i["Cache-Control"]=this.request.headers["Cache-Control"]),n.util.each.call(this,this.request.headers,function(t,e){if(t!==s&&this.isSignableHeader(t)){var r=t.toLowerCase();0===r.indexOf("x-amz-meta-")?i[r]=e:0===r.indexOf("x-amz-")&&(i[t]=e)}});var o=this.request.path.indexOf("?")>=0?"&":"?";this.request.path+=o+n.util.queryParamsToString(i)},authorization:function(t,e){var r=[],n=this.credentialString(e);return r.push(this.algorithm+" Credential="+t.accessKeyId+"/"+n),r.push("SignedHeaders="+this.signedHeaders()),r.push("Signature="+this.signature(t,e)),r.join(", ")},signature:function(t,e){var r=null;if(this.signatureCache)var r=o[this.serviceName];var i=e.substr(0,8);if(!r||r.akid!==t.accessKeyId||r.region!==this.request.region||r.date!==i){var s=t.secretAccessKey,a=n.util.crypto.hmac("AWS4"+s,i,"buffer"),u=n.util.crypto.hmac(a,this.request.region,"buffer"),c=n.util.crypto.hmac(u,this.serviceName,"buffer"),l=n.util.crypto.hmac(c,"aws4_request","buffer");if(!this.signatureCache)return n.util.crypto.hmac(l,this.stringToSign(e),"hex");o[this.serviceName]={region:this.request.region,date:i,key:l,akid:t.accessKeyId}}var h=o[this.serviceName].key;return n.util.crypto.hmac(h,this.stringToSign(e),"hex")},stringToSign:function(t){var e=[];return e.push("AWS4-HMAC-SHA256"),e.push(t),e.push(this.credentialString(t)),e.push(this.hexEncodedHash(this.canonicalString())),e.join("\n")},canonicalString:function(){var t=[],e=this.request.pathname();return"s3"!==this.serviceName&&(e=n.util.uriEscapePath(e)),t.push(this.request.method),t.push(e),t.push(this.request.search()),t.push(this.canonicalHeaders()+"\n"),t.push(this.signedHeaders()),t.push(this.hexEncodedBodyHash()),t.join("\n")},canonicalHeaders:function(){var t=[];n.util.each.call(this,this.request.headers,function(e,r){t.push([e,r])}),t.sort(function(t,e){return t[0].toLowerCase()<e[0].toLowerCase()?-1:1});var e=[];return n.util.arrayEach.call(this,t,function(t){var r=t[0].toLowerCase();this.isSignableHeader(r)&&e.push(r+":"+this.canonicalHeaderValues(t[1].toString()))}),e.join("\n")},canonicalHeaderValues:function(t){return t.replace(/\s+/g," ").replace(/^\s+|\s+$/g,"")},signedHeaders:function(){var t=[];return n.util.each.call(this,this.request.headers,function(e){e=e.toLowerCase(),this.isSignableHeader(e)&&t.push(e)}),t.sort().join(";")},credentialString:function(t){var e=[];return e.push(t.substr(0,8)),e.push(this.request.region),e.push(this.serviceName),e.push("aws4_request"),e.join("/")},hexEncodedHash:function(t){return n.util.crypto.sha256(t,"hex")},hexEncodedBodyHash:function(){return this.isPresigned()&&"s3"===this.serviceName&&!this.request.body?"UNSIGNED-PAYLOAD":this.request.headers["X-Amz-Content-Sha256"]?this.request.headers["X-Amz-Content-Sha256"]:this.hexEncodedHash(this.request.body||"")},unsignableHeaders:["authorization","content-type","content-length","user-agent",s,"expect"],isSignableHeader:function(t){return 0===t.toLowerCase().indexOf("x-amz-")?!0:this.unsignableHeaders.indexOf(t)<0},isPresigned:function(){return this.request.headers[s]?!0:!1}}),e.exports=n.Signers.V4},{"../core":24}],81:[function(t,e,r){var n=t("../core"),i=n.util.inherit;t("./v3"),n.Signers.V3Https=i(n.Signers.V3,{authorization:function(t){return"AWS3-HTTPS AWSAccessKeyId="+t.accessKeyId+",Algorithm=HmacSHA256,Signature="+this.signature(t)},stringToSign:function(){return this.request.headers["X-Amz-Date"]}}),e.exports=n.Signers.V3Https},{"../core":24,"./v3":80}],80:[function(t,e,r){var n=t("../core"),i=n.util.inherit;n.Signers.V3=i(n.Signers.RequestSigner,{addAuthorization:function(t,e){var r=n.util.date.rfc822(e);this.request.headers["X-Amz-Date"]=r,t.sessionToken&&(this.request.headers["x-amz-security-token"]=t.sessionToken),this.request.headers["X-Amzn-Authorization"]=this.authorization(t,r)},authorization:function(t){return"AWS3 AWSAccessKeyId="+t.accessKeyId+",Algorithm=HmacSHA256,SignedHeaders="+this.signedHeaders()+",Signature="+this.signature(t)},signedHeaders:function(){var t=[];return n.util.arrayEach(this.headersToSign(),function(e){t.push(e.toLowerCase())}),t.sort().join(";")},canonicalHeaders:function(){var t=this.request.headers,e=[];return n.util.arrayEach(this.headersToSign(),function(r){e.push(r.toLowerCase().trim()+":"+String(t[r]).trim())}),e.sort().join("\n")+"\n"},headersToSign:function(){var t=[];return n.util.each(this.request.headers,function(e){("Host"===e||"Content-Encoding"===e||e.match(/^X-Amz/i))&&t.push(e)}),t},signature:function(t){return n.util.crypto.hmac(t.secretAccessKey,this.stringToSign(),"base64")},stringToSign:function(){var t=[];return t.push(this.request.method),t.push("/"),t.push(""),t.push(this.canonicalHeaders()),t.push(this.request.body),n.util.crypto.sha256(t.join("\n"))}}),e.exports=n.Signers.V3},{"../core":24}],79:[function(t,e,r){var n=t("../core"),i=n.util.inherit;n.Signers.V2=i(n.Signers.RequestSigner,{addAuthorization:function(t,e){e||(e=n.util.date.getDate());var r=this.request;r.params.Timestamp=n.util.date.iso8601(e),r.params.SignatureVersion="2",r.params.SignatureMethod="HmacSHA256",r.params.AWSAccessKeyId=t.accessKeyId,t.sessionToken&&(r.params.SecurityToken=t.sessionToken),delete r.params.Signature,r.params.Signature=this.signature(t),r.body=n.util.queryParamsToString(r.params),r.headers["Content-Length"]=r.body.length},signature:function(t){return n.util.crypto.hmac(t.secretAccessKey,this.stringToSign(),"base64")},stringToSign:function(){var t=[];return t.push(this.request.method),t.push(this.request.endpoint.host.toLowerCase()),t.push(this.request.pathname()),t.push(n.util.queryParamsToString(this.request.params)),t.join("\n")}}),e.exports=n.Signers.V2},{"../core":24}],78:[function(t,e,r){var n=t("../core"),i=n.util.inherit;n.Signers.S3=i(n.Signers.RequestSigner,{subResources:{acl:1,accelerate:1,cors:1,lifecycle:1,"delete":1,location:1,logging:1,notification:1,partNumber:1,policy:1,requestPayment:1,replication:1,restore:1,tagging:1,torrent:1,uploadId:1,uploads:1,versionId:1,versioning:1,versions:1,website:1},responseHeaders:{"response-content-type":1,"response-content-language":1,"response-expires":1,"response-cache-control":1,"response-content-disposition":1,"response-content-encoding":1},addAuthorization:function(t,e){this.request.headers["presigned-expires"]||(this.request.headers["X-Amz-Date"]=n.util.date.rfc822(e)),t.sessionToken&&(this.request.headers["x-amz-security-token"]=t.sessionToken);var r=this.sign(t.secretAccessKey,this.stringToSign()),i="AWS "+t.accessKeyId+":"+r;this.request.headers.Authorization=i},stringToSign:function(){var t=this.request,e=[];e.push(t.method),e.push(t.headers["Content-MD5"]||""),e.push(t.headers["Content-Type"]||""),e.push(t.headers["presigned-expires"]||"");var r=this.canonicalizedAmzHeaders();return r&&e.push(r),e.push(this.canonicalizedResource()),e.join("\n")},canonicalizedAmzHeaders:function(){var t=[];n.util.each(this.request.headers,function(e){e.match(/^x-amz-/i)&&t.push(e)}),t.sort(function(t,e){return t.toLowerCase()<e.toLowerCase()?-1:1});var e=[];return n.util.arrayEach.call(this,t,function(t){e.push(t.toLowerCase()+":"+String(this.request.headers[t]))}),e.join("\n")},canonicalizedResource:function(){var t=this.request,e=t.path.split("?"),r=e[0],i=e[1],o="";if(t.virtualHostedBucket&&(o+="/"+t.virtualHostedBucket),o+=r,i){var s=[];n.util.arrayEach.call(this,i.split("&"),function(t){var e=t.split("=")[0],r=t.split("=")[1];if(this.subResources[e]||this.responseHeaders[e]){var n={name:e};void 0!==r&&(this.subResources[e]?n.value=r:n.value=decodeURIComponent(r)),s.push(n)}}),s.sort(function(t,e){return t.name<e.name?-1:1}),s.length&&(i=[],n.util.arrayEach(s,function(t){void 0===t.value?i.push(t.name):i.push(t.name+"="+t.value)}),o+="?"+i.join("&"))}return o},sign:function(t,e){return n.util.crypto.hmac(t,e,"base64","sha1")}}),e.exports=n.Signers.S3},{"../core":24}],76:[function(t,e,r){function n(t){var e=t.httpRequest.headers[a],r=t.service.getSignerClass(t);if(delete t.httpRequest.headers["User-Agent"],delete t.httpRequest.headers["X-Amz-User-Agent"],r===o.Signers.V4){if(e>604800){var n="Presigning does not support expiry time greater than a week with SigV4 signing.";throw o.util.error(new Error,{code:"InvalidExpiryTime",message:n,retryable:!1})}t.httpRequest.headers[a]=e}else{if(r!==o.Signers.S3)throw o.util.error(new Error,{message:"Presigning only supports S3 or SigV4 signing.",code:"UnsupportedSigner",retryable:!1});t.httpRequest.headers[a]=parseInt(o.util.date.unixTimestamp()+e,10).toString()}}function i(t){var e=t.httpRequest.endpoint,r=o.util.urlParse(t.httpRequest.path),n={};r.search&&(n=o.util.queryStringParse(r.search.substr(1))),o.util.each(t.httpRequest.headers,function(t,e){t===a&&(t="Expires"),0===t.indexOf("x-amz-meta-")&&(delete n[t],t=t.toLowerCase()),n[t]=e}),delete t.httpRequest.headers[a];var i=n.Authorization.split(" ");if("AWS"===i[0])i=i[1].split(":"),n.AWSAccessKeyId=i[0],n.Signature=i[1];else if("AWS4-HMAC-SHA256"===i[0]){i.shift();var s=i.join(" "),u=s.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];n["X-Amz-Signature"]=u,delete n.Expires}delete n.Authorization,delete n.Host,e.pathname=r.pathname,e.search=o.util.queryParamsToString(n)}var o=t("../core"),s=o.util.inherit,a="presigned-expires";o.Signers.Presign=s({sign:function(t,e,r){if(t.httpRequest.headers[a]=e||3600,t.on("build",n),t.on("sign",i),t.removeListener("afterBuild",o.EventListeners.Core.SET_CONTENT_LENGTH),t.removeListener("afterBuild",o.EventListeners.Core.COMPUTE_SHA256),t.emit("beforePresign",[t]),!r){if(t.build(),t.response.error)throw t.response.error;return o.util.urlFormat(t.httpRequest.endpoint)}t.build(function(){this.response.error?r(this.response.error):r(null,o.util.urlFormat(t.httpRequest.endpoint))})}}),e.exports=o.Signers.Presign},{"../core":24}],61:[function(t,e,r){var n=t("./core"),i=t("./model/api"),o=t("./region_config"),s=n.util.inherit;n.Service=s({constructor:function(t){if(!this.loadServiceClass)throw n.util.error(new Error,"Service must be constructed with `new' operator");var e=this.loadServiceClass(t||{});if(e){var r=n.util.copy(t),i=new e(t);return Object.defineProperty(i,"_originalConfig",{get:function(){return r},enumerable:!1,configurable:!0}),i}this.initialize(t)},initialize:function(t){var e=n.config[this.serviceIdentifier];this.config=new n.Config(n.config),e&&this.config.update(e,!0),t&&this.config.update(t,!0),this.validateService(),this.config.endpoint||o(this),this.config.endpoint=this.endpointFromTemplate(this.config.endpoint),this.setEndpoint(this.config.endpoint)},validateService:function(){},loadServiceClass:function(t){var e=t;if(n.util.isEmpty(this.api)){if(e.apiConfig)return n.Service.defineServiceApi(this.constructor,e.apiConfig);if(this.constructor.services){e=new n.Config(n.config),e.update(t,!0);var r=e.apiVersions[this.constructor.serviceIdentifier];return r=r||e.apiVersion,this.getLatestServiceClass(r)}return null}return null},getLatestServiceClass:function(t){return t=this.getLatestServiceVersion(t),null===this.constructor.services[t]&&n.Service.defineServiceApi(this.constructor,t),this.constructor.services[t]},getLatestServiceVersion:function(t){if(!this.constructor.services||0===this.constructor.services.length)throw new Error("No services defined on "+this.constructor.serviceIdentifier);if(t?n.util.isType(t,Date)&&(t=n.util.date.iso8601(t).split("T")[0]):t="latest",Object.hasOwnProperty(this.constructor.services,t))return t;for(var e=Object.keys(this.constructor.services).sort(),r=null,i=e.length-1;i>=0;i--)if("*"!==e[i][e[i].length-1]&&(r=e[i]),e[i].substr(0,10)<=t)return r;throw new Error("Could not find "+this.constructor.serviceIdentifier+" API to satisfy version constraint `"+t+"'")},api:{},defaultRetryCount:3,makeRequest:function(t,e,r){if("function"==typeof e&&(r=e,e=null),e=e||{},this.config.params){var i=this.api.operations[t];i&&(e=n.util.copy(e),n.util.each(this.config.params,function(t,r){i.input.members[t]&&(void 0===e[t]||null===e[t])&&(e[t]=r)}))}var o=new n.Request(this,t,e);return this.addAllRequestListeners(o),r&&o.send(r),o},makeUnauthenticatedRequest:function(t,e,r){"function"==typeof e&&(r=e,e={});var n=this.makeRequest(t,e).toUnauthenticated();return r?n.send(r):n},waitFor:function(t,e,r){var i=new n.ResourceWaiter(this,t);return i.wait(e,r)},addAllRequestListeners:function(t){for(var e=[n.events,n.EventListeners.Core,this.serviceInterface(),n.EventListeners.CorePost],r=0;r<e.length;r++)e[r]&&t.addListeners(e[r]);this.config.paramValidation||t.removeListener("validate",n.EventListeners.Core.VALIDATE_PARAMETERS),this.config.logger&&t.addListeners(n.EventListeners.Logger),this.setupRequestListeners(t)},setupRequestListeners:function(){},getSignerClass:function(){var t;return t=this.config.signatureVersion?this.config.signatureVersion:this.api.signatureVersion,n.Signers.RequestSigner.getVersion(t)},serviceInterface:function(){switch(this.api.protocol){case"ec2":return n.EventListeners.Query;case"query":return n.EventListeners.Query;case"json":return n.EventListeners.Json;case"rest-json":return n.EventListeners.RestJson;case"rest-xml":return n.EventListeners.RestXml}if(this.api.protocol)throw new Error("Invalid service `protocol' "+this.api.protocol+" in API config")},successfulResponse:function(t){return t.httpResponse.statusCode<300},numRetries:function(){return void 0!==this.config.maxRetries?this.config.maxRetries:this.defaultRetryCount},retryDelays:function(t){var e=this.config.retryDelayOptions||{},r=e.customBackoff||null;if("function"==typeof r)return r(t);var n=e.base||30,i=Math.random()*Math.pow(2,t)*n;return i},retryableError:function(t){return this.networkingError(t)?!0:this.expiredCredentialsError(t)?!0:this.throttledError(t)?!0:t.statusCode>=500?!0:!1},networkingError:function(t){return"NetworkingError"===t.code},expiredCredentialsError:function(t){return"ExpiredTokenException"===t.code},clockSkewError:function(t){switch(t.code){case"RequestTimeTooSkewed":case"RequestExpired":case"InvalidSignatureException":case"SignatureDoesNotMatch":case"AuthFailure":case"RequestInTheFuture":return!0;default:return!1}},throttledError:function(t){switch(t.code){case"ProvisionedThroughputExceededException":case"Throttling":case"ThrottlingException":case"RequestLimitExceeded":case"RequestThrottled":return!0;default:return!1}},endpointFromTemplate:function(t){if("string"!=typeof t)return t;var e=t;return e=e.replace(/\{service\}/g,this.api.endpointPrefix),e=e.replace(/\{region\}/g,this.config.region),e=e.replace(/\{scheme\}/g,this.config.sslEnabled?"https":"http")},setEndpoint:function(t){this.endpoint=new n.Endpoint(t,this.config)},paginationConfig:function(t,e){var r=this.api.operations[t].paginator;if(!r){if(e){var i=new Error;throw n.util.error(i,"No pagination configuration for "+t)}return null}return r}}),n.util.update(n.Service,{defineMethods:function(t){n.util.each(t.prototype.api.operations,function(e){if(!t.prototype[e]){var r=t.prototype.api.operations[e];"none"===r.authtype?t.prototype[e]=function(t,r){return this.makeUnauthenticatedRequest(e,t,r)}:t.prototype[e]=function(t,r){return this.makeRequest(e,t,r)}}})},defineService:function(t,e,r){n.Service._serviceMap[t]=!0,Array.isArray(e)||(r=e,e=[]);var i=s(n.Service,r||{});if("string"==typeof t){n.Service.addVersions(i,e);var o=i.serviceIdentifier||t;i.serviceIdentifier=o}else i.prototype.api=t,n.Service.defineMethods(i);return i},addVersions:function(t,e){Array.isArray(e)||(e=[e]),t.services=t.services||{};for(var r=0;r<e.length;r++)void 0===t.services[e[r]]&&(t.services[e[r]]=null);t.apiVersions=Object.keys(t.services).sort()},defineServiceApi:function(t,e,r){function o(t){t.isApi?a.prototype.api=t:a.prototype.api=new i(t)}var a=s(t,{serviceIdentifier:t.serviceIdentifier});if("string"==typeof e){if(r)o(r);else try{o(n.apiLoader(t.serviceIdentifier,e))}catch(u){throw n.util.error(u,{message:"Could not find API configuration "+t.serviceIdentifier+"-"+e})}Object.prototype.hasOwnProperty.call(t.services,e)||(t.apiVersions=t.apiVersions.concat(e).sort()),t.services[e]=a}else o(e);return n.Service.defineMethods(a),a},hasService:function(t){return Object.prototype.hasOwnProperty.call(n.Service._serviceMap,t)},_serviceMap:{}})},{"./core":24,"./model/api":41,"./region_config":55}],55:[function(t,e,r){function n(t){if(!t)return null;var e=t.split("-");return e.length<3?null:e.slice(0,e.length-2).join("-")+"-*"}function i(t){var e=t.config.region,r=n(e),i=t.api.endpointPrefix;return[[e,i],[r,i],[e,"*"],[r,"*"],["*",i],["*","*"]].map(function(t){return t[0]&&t[1]?t.join("/"):null})}function o(t,e){a.each(e,function(e,r){"globalEndpoint"!==e&&(void 0===t.config[e]||null===t.config[e])&&(t.config[e]=r)})}function s(t){for(var e=i(t),r=0;r<e.length;r++){var n=e[r];if(n&&Object.prototype.hasOwnProperty.call(u.rules,n)){var s=u.rules[n];return"string"==typeof s&&(s=u.patterns[s]),t.isGlobalEndpoint=!!s.globalEndpoint,s.signatureVersion||(s.signatureVersion="v4"),void o(t,s)}}}var a=t("./util"),u=t("./region_config.json");e.exports=s},{"./region_config.json":54,"./util":84}],54:[function(t,e,r){e.exports={rules:{"*/*":{endpoint:"{service}.{region}.amazonaws.com"},"cn-*/*":{endpoint:"{service}.{region}.amazonaws.com.cn"},"*/cloudfront":"globalSSL",
"*/iam":"globalSSL","*/sts":"globalSSL","*/importexport":{endpoint:"{service}.amazonaws.com",signatureVersion:"v2",globalEndpoint:!0},"*/route53":{endpoint:"https://{service}.amazonaws.com",signatureVersion:"v3https",globalEndpoint:!0},"*/waf":"globalSSL","us-gov-*/iam":"globalGovCloud","us-gov-*/sts":{endpoint:"{service}.{region}.amazonaws.com"},"us-gov-west-1/s3":"s3dash","us-west-1/s3":"s3dash","us-west-2/s3":"s3dash","eu-west-1/s3":"s3dash","ap-southeast-1/s3":"s3dash","ap-southeast-2/s3":"s3dash","ap-northeast-1/s3":"s3dash","sa-east-1/s3":"s3dash","us-east-1/s3":{endpoint:"{service}.amazonaws.com",signatureVersion:"s3"},"us-east-1/sdb":{endpoint:"{service}.amazonaws.com",signatureVersion:"v2"},"*/sdb":{endpoint:"{service}.{region}.amazonaws.com",signatureVersion:"v2"}},patterns:{globalSSL:{endpoint:"https://{service}.amazonaws.com",globalEndpoint:!0},globalGovCloud:{endpoint:"{service}.us-gov.amazonaws.com"},s3dash:{endpoint:"{service}-{region}.amazonaws.com",signatureVersion:"s3"}}}},{}],58:[function(t,e,r){var n=t("./core"),i=n.util.inherit,o=t("jmespath");n.Response=i({constructor:function(t){this.request=t,this.data=null,this.error=null,this.retryCount=0,this.redirectCount=0,this.httpResponse=new n.HttpResponse,t&&(this.maxRetries=t.service.numRetries(),this.maxRedirects=t.service.config.maxRedirects)},nextPage:function(t){var e,r=this.request.service,i=this.request.operation;try{e=r.paginationConfig(i,!0)}catch(o){this.error=o}if(!this.hasNextPage()){if(t)t(this.error,null);else if(this.error)throw this.error;return null}var s=n.util.copy(this.request.params);if(this.nextPageTokens){var a=e.inputToken;"string"==typeof a&&(a=[a]);for(var u=0;u<a.length;u++)s[a[u]]=this.nextPageTokens[u];return r.makeRequest(this.request.operation,s,t)}return t?t(null,null):null},hasNextPage:function(){return this.cacheNextPageTokens(),this.nextPageTokens?!0:void 0===this.nextPageTokens?void 0:!1},cacheNextPageTokens:function(){if(Object.prototype.hasOwnProperty.call(this,"nextPageTokens"))return this.nextPageTokens;this.nextPageTokens=void 0;var t=this.request.service.paginationConfig(this.request.operation);if(!t)return this.nextPageTokens;if(this.nextPageTokens=null,t.moreResults&&!o.search(this.data,t.moreResults))return this.nextPageTokens;var e=t.outputToken;return"string"==typeof e&&(e=[e]),n.util.arrayEach.call(this,e,function(t){var e=o.search(this.data,t);e&&(this.nextPageTokens=this.nextPageTokens||[],this.nextPageTokens.push(e))}),this.nextPageTokens}})},{"./core":24,jmespath:87}],57:[function(t,e,r){function n(t){var e=t.request._waiter,r=e.config.acceptors,n=!1,i="retry";r.forEach(function(r){if(!n){var o=e.matchers[r.matcher];o&&o(t,r.expected,r.argument)&&(n=!0,i=r.state)}}),!n&&t.error&&(i="failure"),"success"===i?e.setSuccess(t):e.setError(t,"retry"===i)}var i=t("./core"),o=i.util.inherit,s=t("jmespath");i.ResourceWaiter=o({constructor:function(t,e){this.service=t,this.state=e,this.loadWaiterConfig(this.state)},service:null,state:null,config:null,matchers:{path:function(t,e,r){var n=s.search(t.data,r);return s.strictDeepEqual(n,e)},pathAll:function(t,e,r){var n=s.search(t.data,r);Array.isArray(n)||(n=[n]);var i=n.length;if(!i)return!1;for(var o=0;i>o;o++)if(!s.strictDeepEqual(n[o],e))return!1;return!0},pathAny:function(t,e,r){var n=s.search(t.data,r);Array.isArray(n)||(n=[n]);for(var i=n.length,o=0;i>o;o++)if(s.strictDeepEqual(n[o],e))return!0;return!1},status:function(t,e){var r=t.httpResponse.statusCode;return"number"==typeof r&&r===e},error:function(t,e){return"string"==typeof e&&t.error?e===t.error.code:e===!!t.error}},listeners:(new i.SequentialExecutor).addNamedListeners(function(t){t("RETRY_CHECK","retry",function(t){var e=t.request._waiter;t.error&&"ResourceNotReady"===t.error.code&&(t.error.retryDelay=1e3*(e.config.delay||0))}),t("CHECK_OUTPUT","extractData",n),t("CHECK_ERROR","extractError",n)}),wait:function(t,e){"function"==typeof t&&(e=t,t=void 0);var r=this.service.makeRequest(this.config.operation,t);return r._waiter=this,r.response.maxRetries=this.config.maxAttempts,r.addListeners(this.listeners),e&&r.send(e),r},setSuccess:function(t){t.error=null,t.data=t.data||{},t.request.removeAllListeners("extractData")},setError:function(t,e){t.data=null,t.error=i.util.error(t.error||new Error,{code:"ResourceNotReady",message:"Resource is not in the state "+this.state,retryable:e})},loadWaiterConfig:function(t){if(!this.service.api.waiters[t])throw new i.util.error(new Error,{code:"StateNotFoundError",message:"State "+t+" not found."});this.config=this.service.api.waiters[t]}})},{"./core":24,jmespath:87}],56:[function(t,e,r){(function(e){function r(t){return Object.prototype.hasOwnProperty.call(u,t._asm.currentState)}var n=t("./core"),i=t("./state_machine"),o=n.util.inherit,s=n.util.nodeRequire("domain"),a=t("jmespath"),u={success:1,error:1,complete:1},c=new i;c.setupStates=function(){var t=function(t,e){var n=this;n._haltHandlersOnError=!1,n.emit(n._asm.currentState,function(t){if(t)if(r(n)){if(!(s&&n.domain instanceof s.Domain))throw t;t.domainEmitter=n,t.domain=n.domain,t.domainThrown=!1,n.domain.emit("error",t)}else n.response.error=t,e(t);else e(n.response.error)})};this.addState("validate","build","error",t),this.addState("build","afterBuild","restart",t),this.addState("afterBuild","sign","restart",t),this.addState("sign","send","retry",t),this.addState("retry","afterRetry","afterRetry",t),this.addState("afterRetry","sign","error",t),this.addState("send","validateResponse","retry",t),this.addState("validateResponse","extractData","extractError",t),this.addState("extractError","extractData","retry",t),this.addState("extractData","success","retry",t),this.addState("restart","build","error",t),this.addState("success","complete","complete",t),this.addState("error","complete","complete",t),this.addState("complete",null,null,t)},c.setupStates(),n.Request=o({constructor:function(t,e,r){var o=t.endpoint,a=t.config.region,u=t.config.customUserAgent;t.isGlobalEndpoint&&(a="us-east-1"),this.domain=s&&s.active,this.service=t,this.operation=e,this.params=r||{},this.httpRequest=new n.HttpRequest(o,a,u),this.startTime=n.util.date.getDate(),this.response=new n.Response(this),this._asm=new i(c.states,"validate"),this._haltHandlersOnError=!1,n.SequentialExecutor.call(this),this.emit=this.emitEvent},send:function(t){return t&&this.on("complete",function(e){t.call(e,e.error,e.data)}),this.runTo(),this.response},build:function(t){return this.runTo("send",t)},runTo:function(t,e){return this._asm.runTo(t,e,this),this},abort:function(){return this.removeAllListeners("validateResponse"),this.removeAllListeners("extractError"),this.on("validateResponse",function(t){t.error=n.util.error(new Error("Request aborted by user"),{code:"RequestAbortedError",retryable:!1})}),this.httpRequest.stream&&(this.httpRequest.stream.abort(),this.httpRequest._abortCallback?this.httpRequest._abortCallback():this.removeAllListeners("send")),this},eachPage:function(t){function e(r){t.call(r,r.error,r.data,function(i){i!==!1&&(r.hasNextPage()?r.nextPage().on("complete",e).send():t.call(r,null,null,n.util.fn.noop))})}t=n.util.fn.makeAsync(t,3),this.on("complete",e).send()},eachItem:function(t){function e(e,i){if(e)return t(e,null);if(null===i)return t(null,null);var o=r.service.paginationConfig(r.operation),s=o.resultKey;Array.isArray(s)&&(s=s[0]);var u=a.search(i,s);n.util.arrayEach(u,function(e){t(null,e)})}var r=this;this.eachPage(e)},isPageable:function(){return this.service.paginationConfig(this.operation)?!0:!1},createReadStream:function(){var t=n.util.nodeRequire("stream"),r=this,i=null;return 2===n.HttpClient.streamsApiVersion?(i=new t.PassThrough,r.send()):(i=new t.Stream,i.readable=!0,i.sent=!1,i.on("newListener",function(t){i.sent||"data"!==t||(i.sent=!0,e.nextTick(function(){r.send()}))})),this.on("httpHeaders",function(t,e,o){if(300>t){r.removeListener("httpData",n.EventListeners.Core.HTTP_DATA),r.removeListener("httpError",n.EventListeners.Core.HTTP_ERROR),r.on("httpError",function(t){o.error=t,o.error.retryable=!1});var s=o.httpResponse.createUnbufferedStream();2===n.HttpClient.streamsApiVersion?s.pipe(i):(s.on("data",function(t){i.emit("data",t)}),s.on("end",function(){i.emit("end")})),s.on("error",function(t){i.emit("error",t)})}}),this.on("error",function(t){i.emit("error",t)}),i},emitEvent:function(t,e,r){"function"==typeof e&&(r=e,e=null),r||(r=function(){}),e||(e=this.eventParameters(t,this.response));var i=n.SequentialExecutor.prototype.emit;i.call(this,t,e,function(t){t&&(this.response.error=t),r.call(this,t)})},eventParameters:function(t){switch(t){case"restart":case"validate":case"sign":case"build":case"afterValidate":case"afterBuild":return[this];case"error":return[this.response.error,this.response];default:return[this.response]}},presign:function(t,e){return e||"function"!=typeof t||(e=t,t=null),(new n.Signers.Presign).sign(this.toGet(),t,e)},isPresigned:function(){return Object.prototype.hasOwnProperty.call(this.httpRequest.headers,"presigned-expires")},toUnauthenticated:function(){return this.removeListener("validate",n.EventListeners.Core.VALIDATE_CREDENTIALS),this.removeListener("sign",n.EventListeners.Core.SIGN),this},toGet:function(){return("query"===this.service.api.protocol||"ec2"===this.service.api.protocol)&&(this.removeListener("build",this.buildAsGet),this.addListener("build",this.buildAsGet)),this},buildAsGet:function(t){t.httpRequest.method="GET",t.httpRequest.path=t.service.endpoint.path+"?"+t.httpRequest.body,t.httpRequest.body="",delete t.httpRequest.headers["Content-Length"],delete t.httpRequest.headers["Content-Type"]},haltHandlersOnError:function(){this._haltHandlersOnError=!0}}),n.util.addPromisesToRequests(n.Request),n.util.mixin(n.Request,n.SequentialExecutor)}).call(this,t("_process"))},{"./core":24,"./state_machine":83,_process:13,jmespath:87}],87:[function(t,e,r){!function(t){"use strict";function e(t){return null!==t?"[object Array]"===Object.prototype.toString.call(t):!1}function r(t){return null!==t?"[object Object]"===Object.prototype.toString.call(t):!1}function n(t,i){if(t===i)return!0;var o=Object.prototype.toString.call(t);if(o!==Object.prototype.toString.call(i))return!1;if(e(t)===!0){if(t.length!==i.length)return!1;for(var s=0;s<t.length;s++)if(n(t[s],i[s])===!1)return!1;return!0}if(r(t)===!0){var a={};for(var u in t)if(hasOwnProperty.call(t,u)){if(n(t[u],i[u])===!1)return!1;a[u]=!0}for(var c in i)if(hasOwnProperty.call(i,c)&&a[c]!==!0)return!1;return!0}return!1}function i(t){if(""===t||t===!1||null===t)return!0;if(e(t)&&0===t.length)return!0;if(r(t)){for(var n in t)if(t.hasOwnProperty(n))return!1;return!0}return!1}function o(t){for(var e=Object.keys(t),r=[],n=0;n<e.length;n++)r.push(t[e[n]]);return r}function s(t){return t>="a"&&"z">=t||t>="A"&&"Z">=t||"_"===t}function a(t){return t>="0"&&"9">=t||"-"===t}function u(t){return t>="a"&&"z">=t||t>="A"&&"Z">=t||t>="0"&&"9">=t||"_"===t}function c(){}function l(){}function h(t){this.runtime=t}function p(t){this._interpreter=t,this.functionTable={abs:{_func:this._functionAbs,_signature:[{types:[g]}]},avg:{_func:this._functionAvg,_signature:[{types:[A]}]},ceil:{_func:this._functionCeil,_signature:[{types:[g]}]},contains:{_func:this._functionContains,_signature:[{types:[b,w]},{types:[m]}]},ends_with:{_func:this._functionEndsWith,_signature:[{types:[b]},{types:[b]}]},floor:{_func:this._functionFloor,_signature:[{types:[g]}]},length:{_func:this._functionLength,_signature:[{types:[b,w,E]}]},map:{_func:this._functionMap,_signature:[{types:[x]},{types:[w]}]},max:{_func:this._functionMax,_signature:[{types:[A,R]}]},merge:{_func:this._functionMerge,_signature:[{types:[E],variadic:!0}]},max_by:{_func:this._functionMaxBy,_signature:[{types:[w]},{types:[x]}]},sum:{_func:this._functionSum,_signature:[{types:[A]}]},starts_with:{_func:this._functionStartsWith,_signature:[{types:[b]},{types:[b]}]},min:{_func:this._functionMin,_signature:[{types:[A,R]}]},min_by:{_func:this._functionMinBy,_signature:[{types:[w]},{types:[x]}]},type:{_func:this._functionType,_signature:[{types:[m]}]},keys:{_func:this._functionKeys,_signature:[{types:[E]}]},values:{_func:this._functionValues,_signature:[{types:[E]}]},sort:{_func:this._functionSort,_signature:[{types:[R,A]}]},sort_by:{_func:this._functionSortBy,_signature:[{types:[w]},{types:[x]}]},join:{_func:this._functionJoin,_signature:[{types:[b]},{types:[R]}]},reverse:{_func:this._functionReverse,_signature:[{types:[b,w]}]},to_array:{_func:this._functionToArray,_signature:[{types:[m]}]},to_string:{_func:this._functionToString,_signature:[{types:[m]}]},to_number:{_func:this._functionToNumber,_signature:[{types:[m]}]},not_null:{_func:this._functionNotNull,_signature:[{types:[m],variadic:!0}]}}}function f(t){var e=new l,r=e.parse(t);return r}function d(t){var e=new c;return e.tokenize(t)}function y(t,e){var r=new l,n=new p,i=new h(n);n._interpreter=i;var o=r.parse(e);return i.search(o,t)}var v;v="function"==typeof String.prototype.trimLeft?function(t){return t.trimLeft()}:function(t){return t.match(/^\s*(.*)/)[1]};var g=0,m=1,b=2,w=3,E=4,_=5,x=6,S=7,A=8,R=9,T="EOF",I="UnquotedIdentifier",C="QuotedIdentifier",j="Rbracket",L="Rparen",O="Comma",q="Colon",D="Rbrace",P="Number",k="Current",N="Expref",M="Pipe",U="Or",B="And",F="EQ",z="GT",H="LT",X="GTE",V="LTE",K="NE",W="Flatten",Y="Star",J="Filter",G="Dot",$="Not",Z="Lbrace",Q="Lbracket",tt="Lparen",et="Literal",rt={".":G,"*":Y,",":O,":":q,"{":Z,"}":D,"]":j,"(":tt,")":L,"@":k},nt={"<":!0,">":!0,"=":!0,"!":!0},it={" ":!0,"	":!0,"\n":!0};c.prototype={tokenize:function(t){var e=[];this._current=0;for(var r,n,i;this._current<t.length;)if(s(t[this._current]))r=this._current,n=this._consumeUnquotedIdentifier(t),e.push({type:I,value:n,start:r});else if(void 0!==rt[t[this._current]])e.push({type:rt[t[this._current]],value:t[this._current],start:this._current}),this._current++;else if(a(t[this._current]))i=this._consumeNumber(t),e.push(i);else if("["===t[this._current])i=this._consumeLBracket(t),e.push(i);else if('"'===t[this._current])r=this._current,n=this._consumeQuotedIdentifier(t),e.push({type:C,value:n,start:r});else if("'"===t[this._current])r=this._current,n=this._consumeRawStringLiteral(t),e.push({type:et,value:n,start:r});else if("`"===t[this._current]){r=this._current;var o=this._consumeLiteral(t);e.push({type:et,value:o,start:r})}else if(void 0!==nt[t[this._current]])e.push(this._consumeOperator(t));else if(void 0!==it[t[this._current]])this._current++;else if("&"===t[this._current])r=this._current,this._current++,"&"===t[this._current]?(this._current++,e.push({type:B,value:"&&",start:r})):e.push({type:N,value:"&",start:r});else{if("|"!==t[this._current]){var u=new Error("Unknown character:"+t[this._current]);throw u.name="LexerError",u}r=this._current,this._current++,"|"===t[this._current]?(this._current++,e.push({type:U,value:"||",start:r})):e.push({type:M,value:"|",start:r})}return e},_consumeUnquotedIdentifier:function(t){var e=this._current;for(this._current++;this._current<t.length&&u(t[this._current]);)this._current++;return t.slice(e,this._current)},_consumeQuotedIdentifier:function(t){var e=this._current;this._current++;for(var r=t.length;'"'!==t[this._current]&&this._current<r;){var n=this._current;"\\"!==t[n]||"\\"!==t[n+1]&&'"'!==t[n+1]?n++:n+=2,this._current=n}return this._current++,JSON.parse(t.slice(e,this._current))},_consumeRawStringLiteral:function(t){var e=this._current;this._current++;for(var r=t.length;"'"!==t[this._current]&&this._current<r;){var n=this._current;"\\"!==t[n]||"\\"!==t[n+1]&&"'"!==t[n+1]?n++:n+=2,this._current=n}this._current++;var i=t.slice(e+1,this._current-1);return i.replace("\\'","'")},_consumeNumber:function(t){var e=this._current;this._current++;for(var r=t.length;a(t[this._current])&&this._current<r;)this._current++;var n=parseInt(t.slice(e,this._current));return{type:P,value:n,start:e}},_consumeLBracket:function(t){var e=this._current;return this._current++,"?"===t[this._current]?(this._current++,{type:J,value:"[?",start:e}):"]"===t[this._current]?(this._current++,{type:W,value:"[]",start:e}):{type:Q,value:"[",start:e}},_consumeOperator:function(t){var e=this._current,r=t[e];return this._current++,"!"===r?"="===t[this._current]?(this._current++,{type:K,value:"!=",start:e}):{type:$,value:"!",start:e}:"<"===r?"="===t[this._current]?(this._current++,{type:V,value:"<=",start:e}):{type:H,value:"<",start:e}:">"===r?"="===t[this._current]?(this._current++,{type:X,value:">=",start:e}):{type:z,value:">",start:e}:"="===r&&"="===t[this._current]?(this._current++,{type:F,value:"==",start:e}):void 0},_consumeLiteral:function(t){this._current++;for(var e,r=this._current,n=t.length;"`"!==t[this._current]&&this._current<n;){var i=this._current;"\\"!==t[i]||"\\"!==t[i+1]&&"`"!==t[i+1]?i++:i+=2,this._current=i}var o=v(t.slice(r,this._current));return o=o.replace("\\`","`"),e=this._looksLikeJSON(o)?JSON.parse(o):JSON.parse('"'+o+'"'),this._current++,e},_looksLikeJSON:function(t){var e='[{"',r=["true","false","null"],n="-0123456789";if(""===t)return!1;if(e.indexOf(t[0])>=0)return!0;if(r.indexOf(t)>=0)return!0;if(!(n.indexOf(t[0])>=0))return!1;try{return JSON.parse(t),!0}catch(i){return!1}}};var ot={};ot[T]=0,ot[I]=0,ot[C]=0,ot[j]=0,ot[L]=0,ot[O]=0,ot[D]=0,ot[P]=0,ot[k]=0,ot[N]=0,ot[M]=1,ot[U]=2,ot[B]=3,ot[F]=5,ot[z]=5,ot[H]=5,ot[X]=5,ot[V]=5,ot[K]=5,ot[W]=9,ot[Y]=20,ot[J]=21,ot[G]=40,ot[$]=45,ot[Z]=50,ot[Q]=55,ot[tt]=60,l.prototype={parse:function(t){this._loadTokens(t),this.index=0;var e=this.expression(0);if(this._lookahead(0)!==T){var r=this._lookaheadToken(0),n=new Error("Unexpected token type: "+r.type+", value: "+r.value);throw n.name="ParserError",n}return e},_loadTokens:function(t){var e=new c,r=e.tokenize(t);r.push({type:T,value:"",start:t.length}),this.tokens=r},expression:function(t){var e=this._lookaheadToken(0);this._advance();for(var r=this.nud(e),n=this._lookahead(0);t<ot[n];)this._advance(),r=this.led(n,r),n=this._lookahead(0);return r},_lookahead:function(t){return this.tokens[this.index+t].type},_lookaheadToken:function(t){return this.tokens[this.index+t]},_advance:function(){this.index++},nud:function(t){var e,r,n;switch(t.type){case et:return{type:"Literal",value:t.value};case I:return{type:"Field",name:t.value};case C:var i={type:"Field",name:t.value};if(this._lookahead(0)===tt)throw new Error("Quoted identifier not allowed for function names.");return i;case $:return r=this.expression(ot.Not),{type:"NotExpression",children:[r]};case Y:return e={type:"Identity"},r=null,r=this._lookahead(0)===j?{type:"Identity"}:this._parseProjectionRHS(ot.Star),{type:"ValueProjection",children:[e,r]};case J:return this.led(t.type,{type:"Identity"});case Z:return this._parseMultiselectHash();case W:return e={type:W,children:[{type:"Identity"}]},r=this._parseProjectionRHS(ot.Flatten),{type:"Projection",children:[e,r]};case Q:return this._lookahead(0)===P||this._lookahead(0)===q?(r=this._parseIndexExpression(),this._projectIfSlice({type:"Identity"},r)):this._lookahead(0)===Y&&this._lookahead(1)===j?(this._advance(),this._advance(),r=this._parseProjectionRHS(ot.Star),{type:"Projection",children:[{type:"Identity"},r]}):this._parseMultiselectList();case k:return{type:k};case N:return n=this.expression(ot.Expref),{type:"ExpressionReference",children:[n]};case tt:for(var o=[];this._lookahead(0)!==L;)this._lookahead(0)===k?(n={type:k},this._advance()):n=this.expression(0),o.push(n);return this._match(L),o[0];default:this._errorToken(t)}},led:function(t,e){var r;switch(t){case G:var n=ot.Dot;return this._lookahead(0)!==Y?(r=this._parseDotRHS(n),{type:"Subexpression",children:[e,r]}):(this._advance(),r=this._parseProjectionRHS(n),{type:"ValueProjection",children:[e,r]});case M:return r=this.expression(ot.Pipe),{type:M,children:[e,r]};case U:return r=this.expression(ot.Or),{type:"OrExpression",children:[e,r]};case B:return r=this.expression(ot.And),{type:"AndExpression",children:[e,r]};case tt:for(var i,o,s=e.name,a=[];this._lookahead(0)!==L;)this._lookahead(0)===k?(i={type:k},this._advance()):i=this.expression(0),this._lookahead(0)===O&&this._match(O),a.push(i);return this._match(L),o={type:"Function",name:s,children:a};case J:var u=this.expression(0);return this._match(j),r=this._lookahead(0)===W?{type:"Identity"}:this._parseProjectionRHS(ot.Filter),{type:"FilterProjection",children:[e,r,u]};case W:var c={type:W,children:[e]},l=this._parseProjectionRHS(ot.Flatten);return{type:"Projection",children:[c,l]};case F:case K:case z:case X:case H:case V:return this._parseComparator(e,t);case Q:var h=this._lookaheadToken(0);return h.type===P||h.type===q?(r=this._parseIndexExpression(),this._projectIfSlice(e,r)):(this._match(Y),this._match(j),r=this._parseProjectionRHS(ot.Star),{type:"Projection",children:[e,r]});default:this._errorToken(this._lookaheadToken(0))}},_match:function(t){if(this._lookahead(0)!==t){var e=this._lookaheadToken(0),r=new Error("Expected "+t+", got: "+e.type);throw r.name="ParserError",r}this._advance()},_errorToken:function(t){var e=new Error("Invalid token ("+t.type+'): "'+t.value+'"');throw e.name="ParserError",e},_parseIndexExpression:function(){if(this._lookahead(0)===q||this._lookahead(1)===q)return this._parseSliceExpression();var t={type:"Index",value:this._lookaheadToken(0).value};return this._advance(),this._match(j),t},_projectIfSlice:function(t,e){var r={type:"IndexExpression",children:[t,e]};return"Slice"===e.type?{type:"Projection",children:[r,this._parseProjectionRHS(ot.Star)]}:r},_parseSliceExpression:function(){for(var t=[null,null,null],e=0,r=this._lookahead(0);r!==j&&3>e;){if(r===q)e++,this._advance();else{if(r!==P){var n=this._lookahead(0),i=new Error("Syntax error, unexpected token: "+n.value+"("+n.type+")");throw i.name="Parsererror",i}t[e]=this._lookaheadToken(0).value,this._advance()}r=this._lookahead(0)}return this._match(j),{type:"Slice",children:t}},_parseComparator:function(t,e){var r=this.expression(ot[e]);return{type:"Comparator",name:e,children:[t,r]}},_parseDotRHS:function(t){var e=this._lookahead(0),r=[I,C,Y];return r.indexOf(e)>=0?this.expression(t):e===Q?(this._match(Q),this._parseMultiselectList()):e===Z?(this._match(Z),this._parseMultiselectHash()):void 0},_parseProjectionRHS:function(t){var e;if(ot[this._lookahead(0)]<10)e={type:"Identity"};else if(this._lookahead(0)===Q)e=this.expression(t);else if(this._lookahead(0)===J)e=this.expression(t);else{if(this._lookahead(0)!==G){var r=this._lookaheadToken(0),n=new Error("Sytanx error, unexpected token: "+r.value+"("+r.type+")");throw n.name="ParserError",n}this._match(G),e=this._parseDotRHS(t)}return e},_parseMultiselectList:function(){for(var t=[];this._lookahead(0)!==j;){var e=this.expression(0);if(t.push(e),this._lookahead(0)===O&&(this._match(O),this._lookahead(0)===j))throw new Error("Unexpected token Rbracket")}return this._match(j),{type:"MultiSelectList",children:t}},_parseMultiselectHash:function(){for(var t,e,r,n,i=[],o=[I,C];;){if(t=this._lookaheadToken(0),o.indexOf(t.type)<0)throw new Error("Expecting an identifier token, got: "+t.type);if(e=t.value,this._advance(),this._match(q),r=this.expression(0),n={type:"KeyValuePair",name:e,value:r},i.push(n),this._lookahead(0)===O)this._match(O);else if(this._lookahead(0)===D){this._match(D);break}}return{type:"MultiSelectHash",children:i}}},h.prototype={search:function(t,e){return this.visit(t,e)},visit:function(t,s){var a,u,c,l,h,p,f,d,y,v;switch(t.type){case"Field":return null===s?null:r(s)?(p=s[t.name],void 0===p?null:p):null;case"Subexpression":for(c=this.visit(t.children[0],s),v=1;v<t.children.length;v++)if(c=this.visit(t.children[1],c),null===c)return null;return c;case"IndexExpression":return f=this.visit(t.children[0],s),d=this.visit(t.children[1],f);case"Index":if(!e(s))return null;var g=t.value;return 0>g&&(g=s.length+g),c=s[g],void 0===c&&(c=null),c;case"Slice":if(!e(s))return null;var m=t.children.slice(0),b=this.computeSliceParams(s.length,m),w=b[0],E=b[1],_=b[2];if(c=[],_>0)for(v=w;E>v;v+=_)c.push(s[v]);else for(v=w;v>E;v+=_)c.push(s[v]);return c;case"Projection":var x=this.visit(t.children[0],s);if(!e(x))return null;for(y=[],v=0;v<x.length;v++)u=this.visit(t.children[1],x[v]),null!==u&&y.push(u);return y;case"ValueProjection":if(x=this.visit(t.children[0],s),!r(x))return null;y=[];var S=o(x);for(v=0;v<S.length;v++)u=this.visit(t.children[1],S[v]),null!==u&&y.push(u);return y;case"FilterProjection":if(x=this.visit(t.children[0],s),!e(x))return null;var A=[],R=[];for(v=0;v<x.length;v++)a=this.visit(t.children[2],x[v]),i(a)||A.push(x[v]);for(var T=0;T<A.length;T++)u=this.visit(t.children[1],A[T]),null!==u&&R.push(u);return R;case"Comparator":switch(l=this.visit(t.children[0],s),h=this.visit(t.children[1],s),t.name){case F:c=n(l,h);break;case K:c=!n(l,h);break;case z:c=l>h;break;case X:c=l>=h;break;case H:c=h>l;break;case V:c=h>=l;break;default:throw new Error("Unknown comparator: "+t.name)}return c;case W:var I=this.visit(t.children[0],s);if(!e(I))return null;var C=[];for(v=0;v<I.length;v++)u=I[v],e(u)?C.push.apply(C,u):C.push(u);return C;case"Identity":return s;case"MultiSelectList":if(null===s)return null;for(y=[],v=0;v<t.children.length;v++)y.push(this.visit(t.children[v],s));return y;case"MultiSelectHash":if(null===s)return null;y={};var j;for(v=0;v<t.children.length;v++)j=t.children[v],y[j.name]=this.visit(j.value,s);return y;case"OrExpression":return a=this.visit(t.children[0],s),i(a)&&(a=this.visit(t.children[1],s)),a;case"AndExpression":return l=this.visit(t.children[0],s),i(l)===!0?l:this.visit(t.children[1],s);case"NotExpression":return l=this.visit(t.children[0],s),i(l);case"Literal":return t.value;case M:return f=this.visit(t.children[0],s),this.visit(t.children[1],f);case k:return s;case"Function":var L=[];for(v=0;v<t.children.length;v++)L.push(this.visit(t.children[v],s));return this.runtime.callFunction(t.name,L);case"ExpressionReference":var O=t.children[0];return O.jmespathType=N,O;default:throw new Error("Unknown node type: "+t.type)}},computeSliceParams:function(t,e){var r=e[0],n=e[1],i=e[2],o=[null,null,null];if(null===i)i=1;else if(0===i){var s=new Error("Invalid slice, step cannot be 0");throw s.name="RuntimeError",s}var a=0>i?!0:!1;return r=null===r?a?t-1:0:this.capSliceRange(t,r,i),n=null===n?a?-1:t:this.capSliceRange(t,n,i),o[0]=r,o[1]=n,o[2]=i,o},capSliceRange:function(t,e,r){return 0>e?(e+=t,0>e&&(e=0>r?-1:0)):e>=t&&(e=0>r?t-1:t),e}},p.prototype={callFunction:function(t,e){var r=this.functionTable[t];if(void 0===r)throw new Error("Unknown function: "+t+"()");return this._validateArgs(t,e,r._signature),r._func.call(this,e)},_validateArgs:function(t,e,r){var n;if(r[r.length-1].variadic){if(e.length<r.length)throw n=1===r.length?" argument":" arguments",new Error("ArgumentError: "+t+"() takes at least"+r.length+n+" but received "+e.length)}else if(e.length!==r.length)throw n=1===r.length?" argument":" arguments",new Error("ArgumentError: "+t+"() takes "+r.length+n+" but received "+e.length);for(var i,o,s,a=0;a<r.length;a++){s=!1,i=r[a].types,o=this._getTypeName(e[a]);for(var u=0;u<i.length;u++)if(this._typeMatches(o,i[u],e[a])){s=!0;break}if(!s)throw new Error("TypeError: "+t+"() expected argument "+(a+1)+" to be type "+i+" but received type "+o+" instead.")}},_typeMatches:function(t,e,r){if(e===m)return!0;if(e!==R&&e!==A&&e!==w)return t===e;if(e===w)return t===w;if(t===w){var n;e===A?n=g:e===R&&(n=b);for(var i=0;i<r.length;i++)if(!this._typeMatches(this._getTypeName(r[i]),n,r[i]))return!1;return!0}},_getTypeName:function(t){switch(Object.prototype.toString.call(t)){case"[object String]":return b;case"[object Number]":return g;case"[object Array]":return w;case"[object Boolean]":return _;case"[object Null]":return S;case"[object Object]":return t.jmespathType===N?x:E}},_functionStartsWith:function(t){return 0===t[0].lastIndexOf(t[1])},_functionEndsWith:function(t){var e=t[0],r=t[1];return-1!==e.indexOf(r,e.length-r.length)},_functionReverse:function(t){var e=this._getTypeName(t[0]);if(e===b){for(var r=t[0],n="",i=r.length-1;i>=0;i--)n+=r[i];return n}var o=t[0].slice(0);return o.reverse(),o},_functionAbs:function(t){return Math.abs(t[0])},_functionCeil:function(t){return Math.ceil(t[0])},_functionAvg:function(t){for(var e=0,r=t[0],n=0;n<r.length;n++)e+=r[n];return e/r.length},_functionContains:function(t){return t[0].indexOf(t[1])>=0},_functionFloor:function(t){return Math.floor(t[0])},_functionLength:function(t){return r(t[0])?Object.keys(t[0]).length:t[0].length},_functionMap:function(t){for(var e=[],r=this._interpreter,n=t[0],i=t[1],o=0;o<i.length;o++)e.push(r.visit(n,i[o]));return e},_functionMerge:function(t){for(var e={},r=0;r<t.length;r++){var n=t[r];for(var i in n)e[i]=n[i]}return e},_functionMax:function(t){if(t[0].length>0){var e=this._getTypeName(t[0][0]);if(e===g)return Math.max.apply(Math,t[0]);for(var r=t[0],n=r[0],i=1;i<r.length;i++)n.localeCompare(r[i])<0&&(n=r[i]);return n}return null},_functionMin:function(t){if(t[0].length>0){var e=this._getTypeName(t[0][0]);if(e===g)return Math.min.apply(Math,t[0]);for(var r=t[0],n=r[0],i=1;i<r.length;i++)r[i].localeCompare(n)<0&&(n=r[i]);return n}return null},_functionSum:function(t){for(var e=0,r=t[0],n=0;n<r.length;n++)e+=r[n];return e},_functionType:function(t){switch(this._getTypeName(t[0])){case g:return"number";case b:return"string";case w:return"array";case E:return"object";case _:return"boolean";case x:return"expref";case S:return"null"}},_functionKeys:function(t){return Object.keys(t[0])},_functionValues:function(t){for(var e=t[0],r=Object.keys(e),n=[],i=0;i<r.length;i++)n.push(e[r[i]]);return n},_functionJoin:function(t){var e=t[0],r=t[1];return r.join(e)},_functionToArray:function(t){return this._getTypeName(t[0])===w?t[0]:[t[0]]},_functionToString:function(t){return this._getTypeName(t[0])===b?t[0]:JSON.stringify(t[0])},_functionToNumber:function(t){var e,r=this._getTypeName(t[0]);return r===g?t[0]:r!==b||(e=+t[0],isNaN(e))?null:e},_functionNotNull:function(t){for(var e=0;e<t.length;e++)if(this._getTypeName(t[e])!==S)return t[e];return null},_functionSort:function(t){var e=t[0].slice(0);return e.sort(),e},_functionSortBy:function(t){var e=t[0].slice(0);if(0===e.length)return e;var r=this._interpreter,n=t[1],i=this._getTypeName(r.visit(n,e[0]));if([g,b].indexOf(i)<0)throw new Error("TypeError");for(var o=this,s=[],a=0;a<e.length;a++)s.push([a,e[a]]);s.sort(function(t,e){var s=r.visit(n,t[1]),a=r.visit(n,e[1]);if(o._getTypeName(s)!==i)throw new Error("TypeError: expected "+i+", received "+o._getTypeName(s));if(o._getTypeName(a)!==i)throw new Error("TypeError: expected "+i+", received "+o._getTypeName(a));return s>a?1:a>s?-1:t[0]-e[0]});for(var u=0;u<s.length;u++)e[u]=s[u][1];return e},_functionMaxBy:function(t){for(var e,r,n=t[1],i=t[0],o=this.createKeyFunction(n,[g,b]),s=-(1/0),a=0;a<i.length;a++)r=o(i[a]),r>s&&(s=r,e=i[a]);return e},_functionMinBy:function(t){for(var e,r,n=t[1],i=t[0],o=this.createKeyFunction(n,[g,b]),s=1/0,a=0;a<i.length;a++)r=o(i[a]),s>r&&(s=r,e=i[a]);return e},createKeyFunction:function(t,e){var r=this,n=this._interpreter,i=function(i){var o=n.visit(t,i);if(e.indexOf(r._getTypeName(o))<0){var s="TypeError: expected one of "+e+", received "+r._getTypeName(o);throw new Error(s)}return o};return i}},t.tokenize=d,t.compile=f,t.search=y,t.strictDeepEqual=n}("undefined"==typeof r?this.jmespath={}:r)},{}],83:[function(t,e,r){function n(t,e){this.currentState=e||null,this.states=t||{}}n.prototype.runTo=function(t,e,r,n){"function"==typeof t&&(n=r,r=e,e=t,t=null);var i=this,o=i.states[i.currentState];o.fn.call(r||i,n,function(n){if(n){if(!o.fail)return e?e.call(r,n):null;i.currentState=o.fail}else{if(!o.accept)return e?e.call(r):null;i.currentState=o.accept}return i.currentState===t?e?e.call(r,n):null:void i.runTo(t,e,r,n)})},n.prototype.addState=function(t,e,r,n){return"function"==typeof e?(n=e,e=null,r=null):"function"==typeof r&&(n=r,r=null),this.currentState||(this.currentState=t),this.states[t]={accept:e,fail:r,fn:n},this},e.exports=n},{}],47:[function(t,e,r){
var n=t("./core");n.ParamValidator=n.util.inherit({constructor:function(t){(t===!0||void 0===t)&&(t={min:!0}),this.validation=t},validate:function(t,e,r){if(this.errors=[],this.validateMember(t,e||{},r||"params"),this.errors.length>1){var i=this.errors.join("\n* ");throw i="There were "+this.errors.length+" validation errors:\n* "+i,n.util.error(new Error(i),{code:"MultipleValidationErrors",errors:this.errors})}if(1===this.errors.length)throw this.errors[0];return!0},fail:function(t,e){this.errors.push(n.util.error(new Error(e),{code:t}))},validateStructure:function(t,e,r){this.validateType(e,r,["object"],"structure");for(var n,i=0;t.required&&i<t.required.length;i++){n=t.required[i];var o=e[n];(void 0===o||null===o)&&this.fail("MissingRequiredParameter","Missing required key '"+n+"' in "+r)}for(n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var s=e[n],a=t.members[n];if(void 0!==a){var u=[r,n].join(".");this.validateMember(a,s,u)}else this.fail("UnexpectedParameter","Unexpected key '"+n+"' found in "+r)}return!0},validateMember:function(t,e,r){switch(t.type){case"structure":return this.validateStructure(t,e,r);case"list":return this.validateList(t,e,r);case"map":return this.validateMap(t,e,r);default:return this.validateScalar(t,e,r)}},validateList:function(t,e,r){if(this.validateType(e,r,[Array])){this.validateRange(t,e.length,r,"list member count");for(var n=0;n<e.length;n++)this.validateMember(t.member,e[n],r+"["+n+"]")}},validateMap:function(t,e,r){if(this.validateType(e,r,["object"],"map")){var n=0;for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(this.validateMember(t.key,i,r+"[key='"+i+"']"),this.validateMember(t.value,e[i],r+"['"+i+"']"),n++);this.validateRange(t,n,r,"map member count")}},validateScalar:function(t,e,r){switch(t.type){case null:case void 0:case"string":return this.validateString(t,e,r);case"base64":case"binary":return this.validatePayload(e,r);case"integer":case"float":return this.validateNumber(t,e,r);case"boolean":return this.validateType(e,r,["boolean"]);case"timestamp":return this.validateType(e,r,[Date,/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/,"number"],"Date object, ISO-8601 string, or a UNIX timestamp");default:return this.fail("UnkownType","Unhandled type "+t.type+" for "+r)}},validateString:function(t,e,r){this.validateType(e,r,["string"])&&(this.validateEnum(t,e,r),this.validateRange(t,e.length,r,"string length"),this.validatePattern(t,e,r))},validatePattern:function(t,e,r){this.validation.pattern&&void 0!==t.pattern&&(new RegExp(t.pattern).test(e)||this.fail("PatternMatchError",'Provided value "'+e+'" does not match regex pattern /'+t.pattern+"/ for "+r))},validateRange:function(t,e,r,n){this.validation.min&&void 0!==t.min&&e<t.min&&this.fail("MinRangeError","Expected "+n+" >= "+t.min+", but found "+e+" for "+r),this.validation.max&&void 0!==t.max&&e>t.max&&this.fail("MaxRangeError","Expected "+n+" <= "+t.max+", but found "+e+" for "+r)},validateEnum:function(t,e,r){this.validation["enum"]&&void 0!==t["enum"]&&-1===t["enum"].indexOf(e)&&this.fail("EnumError","Found string value of "+e+", but expected "+t["enum"].join("|")+" for "+r)},validateType:function(t,e,r,i){if(null===t||void 0===t)return!1;for(var o=!1,s=0;s<r.length;s++){if("string"==typeof r[s]){if(typeof t===r[s])return!0}else if(r[s]instanceof RegExp){if((t||"").toString().match(r[s]))return!0}else{if(t instanceof r[s])return!0;if(n.util.isType(t,r[s]))return!0;i||o||(r=r.slice()),r[s]=n.util.typeName(r[s])}o=!0}var a=i;a||(a=r.join(", ").replace(/,([^,]+)$/,", or$1"));var u=a.match(/^[aeiou]/i)?"n":"";return this.fail("InvalidParameterType","Expected "+e+" to be a"+u+" "+a),!1},validateNumber:function(t,e,r){if(null!==e&&void 0!==e){if("string"==typeof e){var n=parseFloat(e);n.toString()===e&&(e=n)}this.validateType(e,r,["number"])&&this.validateRange(t,e,r,"numeric value")}},validatePayload:function(t,e){if(null!==t&&void 0!==t&&"string"!=typeof t&&(!t||"number"!=typeof t.byteLength)){if(n.util.isNode()){var r=n.util.nodeRequire("stream").Stream;if(n.util.Buffer.isBuffer(t)||t instanceof r)return}var i=["Buffer","Stream","File","Blob","ArrayBuffer","DataView"];if(t)for(var o=0;o<i.length;o++){if(n.util.isType(t,i[o]))return;if(n.util.typeName(t.constructor)===i[o])return}this.fail("InvalidParameterType","Expected "+e+" to be a string, Buffer, Stream, Blob, or typed array object")}}})},{"./core":24}],41:[function(t,e,r){function n(t,e){t=t||{},e=e||{},e.api=this,t.metadata=t.metadata||{},l(this,"isApi",!0,!1),l(this,"apiVersion",t.metadata.apiVersion),l(this,"endpointPrefix",t.metadata.endpointPrefix),l(this,"signingName",t.metadata.signingName),l(this,"globalEndpoint",t.metadata.globalEndpoint),l(this,"signatureVersion",t.metadata.signatureVersion),l(this,"jsonVersion",t.metadata.jsonVersion),l(this,"targetPrefix",t.metadata.targetPrefix),l(this,"protocol",t.metadata.protocol),l(this,"timestampFormat",t.metadata.timestampFormat),l(this,"xmlNamespaceUri",t.metadata.xmlNamespace),l(this,"abbreviation",t.metadata.serviceAbbreviation),l(this,"fullName",t.metadata.serviceFullName),h(this,"className",function(){var e=t.metadata.serviceAbbreviation||t.metadata.serviceFullName;return e?(e=e.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g,""),"ElasticLoadBalancing"===e&&(e="ELB"),e):null}),l(this,"operations",new i(t.operations,e,function(t,r){return new o(t,r,e)},c.string.lowerFirst)),l(this,"shapes",new i(t.shapes,e,function(t,r){return s.create(r,e)})),l(this,"paginators",new i(t.paginators,e,function(t,r){return new a(t,r,e)})),l(this,"waiters",new i(t.waiters,e,function(t,r){return new u(t,r,e)},c.string.lowerFirst)),e.documentation&&(l(this,"documentation",t.documentation),l(this,"documentationUrl",t.documentationUrl))}var i=t("./collection"),o=t("./operation"),s=t("./shape"),a=t("./paginator"),u=t("./resource_waiter"),c=t("../util"),l=c.property,h=c.memoizedProperty;e.exports=n},{"../util":84,"./collection":42,"./operation":43,"./paginator":44,"./resource_waiter":45,"./shape":46}],45:[function(t,e,r){function n(t,e,r){r=r||{},o(this,"name",t),o(this,"api",r.api,!1),e.operation&&o(this,"operation",i.string.lowerFirst(e.operation));var n=this,s=["type","description","delay","maxAttempts","acceptors"];s.forEach(function(t){var r=e[t];r&&o(n,t,r)})}var i=t("../util"),o=i.property;e.exports=n},{"../util":84}],44:[function(t,e,r){function n(t,e){i(this,"inputToken",e.input_token),i(this,"limitKey",e.limit_key),i(this,"moreResults",e.more_results),i(this,"outputToken",e.output_token),i(this,"resultKey",e.result_key)}var i=t("../util").property;e.exports=n},{"../util":84}],43:[function(t,e,r){function n(t,e,r){r=r||{},s(this,"name",e.name||t),s(this,"api",r.api,!1),e.http=e.http||{},s(this,"httpMethod",e.http.method||"POST"),s(this,"httpPath",e.http.requestUri||"/"),s(this,"authtype",e.authtype||""),a(this,"input",function(){return e.input?i.create(e.input,r):new i.create({type:"structure"},r)}),a(this,"output",function(){return e.output?i.create(e.output,r):new i.create({type:"structure"},r)}),a(this,"errors",function(){var t=[];if(!e.errors)return null;for(var n=0;n<e.errors.length;n++)t.push(i.create(e.errors[n],r));return t}),a(this,"paginator",function(){return r.api.paginators[t]}),r.documentation&&(s(this,"documentation",e.documentation),s(this,"documentationUrl",e.documentationUrl))}var i=t("./shape"),o=t("../util"),s=o.property,a=o.memoizedProperty;e.exports=n},{"../util":84,"./shape":46}],37:[function(t,e,r){var n=t("./core"),i=n.util.inherit;n.Endpoint=i({constructor:function(t,e){if(n.util.hideProperties(this,["slashes","auth","hash","search","query"]),"undefined"==typeof t||null===t)throw new Error("Invalid endpoint: "+t);if("string"!=typeof t)return n.util.copy(t);if(!t.match(/^http/)){var r=e&&void 0!==e.sslEnabled?e.sslEnabled:n.config.sslEnabled;t=(r?"https":"http")+"://"+t}n.util.update(this,n.util.urlParse(t)),this.port?this.port=parseInt(this.port,10):this.port="https:"===this.protocol?443:80}}),n.HttpRequest=i({constructor:function(t,e,r){t=new n.Endpoint(t),this.method="POST",this.path=t.path||"/",this.headers={},this.body="",this.endpoint=t,this.region=e,this.setUserAgent(r)},setUserAgent:function(t){var e=n.util.isBrowser()?"X-Amz-":"",r="";"string"==typeof t&&t&&(r+=" "+t),this.headers[e+"User-Agent"]=n.util.userAgent()+r},pathname:function(){return this.path.split("?",1)[0]},search:function(){var t=this.path.split("?",2)[1];return t?(t=n.util.queryStringParse(t),n.util.queryParamsToString(t)):""}}),n.HttpResponse=i({constructor:function(){this.statusCode=void 0,this.headers={},this.body=void 0,this.streaming=!1,this.stream=null},createUnbufferedStream:function(){return this.streaming=!0,this.stream}}),n.HttpClient=i({}),n.HttpClient.getInstance=function(){return void 0===this.singleton&&(this.singleton=new this),this.singleton}},{"./core":24}],36:[function(t,e,r){var n=t("./core"),i=t("./sequential_executor");n.EventListeners={Core:{}},n.EventListeners={Core:(new i).addNamedListeners(function(t,e){e("VALIDATE_CREDENTIALS","validate",function(t,e){return t.service.api.signatureVersion?void t.service.config.getCredentials(function(r){r&&(t.response.error=n.util.error(r,{code:"CredentialsError",message:"Missing credentials in config"})),e()}):e()}),t("VALIDATE_REGION","validate",function(t){t.service.config.region||t.service.isGlobalEndpoint||(t.response.error=n.util.error(new Error,{code:"ConfigError",message:"Missing region in config"}))}),t("VALIDATE_PARAMETERS","validate",function(t){var e=t.service.api.operations[t.operation].input,r=t.service.config.paramValidation;new n.ParamValidator(r).validate(e,t.params)}),e("COMPUTE_SHA256","afterBuild",function(t,e){if(t.haltHandlersOnError(),!t.service.api.signatureVersion)return e();if(t.service.getSignerClass(t)===n.Signers.V4){var r=t.httpRequest.body||"";n.util.computeSha256(r,function(r,n){r?e(r):(t.httpRequest.headers["X-Amz-Content-Sha256"]=n,e())})}else e()}),t("SET_CONTENT_LENGTH","afterBuild",function(t){if(void 0===t.httpRequest.headers["Content-Length"]){var e=n.util.string.byteLength(t.httpRequest.body);t.httpRequest.headers["Content-Length"]=e}}),t("SET_HTTP_HOST","afterBuild",function(t){t.httpRequest.headers.Host=t.httpRequest.endpoint.host}),t("RESTART","restart",function(){var t=this.response.error;t&&t.retryable&&(this.httpRequest=new n.HttpRequest(this.service.endpoint,this.service.region),this.response.retryCount<this.service.config.maxRetries?this.response.retryCount++:this.response.error=null)}),e("SIGN","sign",function(t,e){return t.service.api.signatureVersion?void t.service.config.getCredentials(function(r,i){if(r)return t.response.error=r,e();try{var o=n.util.date.getDate(),s=t.service.getSignerClass(t),a=new s(t.httpRequest,t.service.api.signingName||t.service.api.endpointPrefix,t.service.config.signatureCache);delete t.httpRequest.headers.Authorization,delete t.httpRequest.headers.Date,delete t.httpRequest.headers["X-Amz-Date"],a.addAuthorization(i,o),t.signedAt=o}catch(u){t.response.error=u}e()}):e()}),t("VALIDATE_RESPONSE","validateResponse",function(t){this.service.successfulResponse(t,this)?(t.data={},t.error=null):(t.data=null,t.error=n.util.error(new Error,{code:"UnknownError",message:"An unknown error occurred."}))}),e("SEND","send",function(t,e){function r(r){t.httpResponse.stream=r,r.on("headers",function(e,i){t.request.emit("httpHeaders",[e,i,t]),t.httpResponse.streaming||(2===n.HttpClient.streamsApiVersion?r.on("readable",function(){var e=r.read();null!==e&&t.request.emit("httpData",[e,t])}):r.on("data",function(e){t.request.emit("httpData",[e,t])}))}),r.on("end",function(){t.request.emit("httpDone"),e()})}function i(e){e.on("sendProgress",function(e){t.request.emit("httpUploadProgress",[e,t])}),e.on("receiveProgress",function(e){t.request.emit("httpDownloadProgress",[e,t])})}function o(r){t.error=n.util.error(r,{code:"NetworkingError",region:t.request.httpRequest.region,hostname:t.request.httpRequest.endpoint.hostname,retryable:!0}),t.request.emit("httpError",[t.error,t],function(){e()})}function s(){var e=n.HttpClient.getInstance(),s=t.request.service.config.httpOptions||{};try{var a=e.handleRequest(t.request.httpRequest,s,r,o);i(a)}catch(u){o(u)}}t.httpResponse._abortCallback=e,t.error=null,t.data=null;var a=(n.util.date.getDate()-this.signedAt)/1e3;a>=600?this.emit("sign",[this],function(t){t?e(t):s()}):s()}),t("HTTP_HEADERS","httpHeaders",function(t,e,r){r.httpResponse.statusCode=t,r.httpResponse.headers=e,r.httpResponse.body=new n.util.Buffer(""),r.httpResponse.buffers=[],r.httpResponse.numBytes=0;var i=e.date||e.Date;if(i){var o=Date.parse(i);r.request.service.config.correctClockSkew&&n.util.isClockSkewed(o)&&n.util.applyClockOffset(o)}}),t("HTTP_DATA","httpData",function(t,e){if(t){if(n.util.isNode()){e.httpResponse.numBytes+=t.length;var r=e.httpResponse.headers["content-length"],i={loaded:e.httpResponse.numBytes,total:r};e.request.emit("httpDownloadProgress",[i,e])}e.httpResponse.buffers.push(new n.util.Buffer(t))}}),t("HTTP_DONE","httpDone",function(t){if(t.httpResponse.buffers&&t.httpResponse.buffers.length>0){var e=n.util.buffer.concat(t.httpResponse.buffers);t.httpResponse.body=e}delete t.httpResponse.numBytes,delete t.httpResponse.buffers}),t("FINALIZE_ERROR","retry",function(t){t.httpResponse.statusCode&&(t.error.statusCode=t.httpResponse.statusCode,void 0===t.error.retryable&&(t.error.retryable=this.service.retryableError(t.error,this)))}),t("INVALIDATE_CREDENTIALS","retry",function(t){if(t.error)switch(t.error.code){case"RequestExpired":case"ExpiredTokenException":case"ExpiredToken":t.error.retryable=!0,t.request.service.config.credentials.expired=!0}}),t("EXPIRED_SIGNATURE","retry",function(t){var e=t.error;e&&"string"==typeof e.code&&"string"==typeof e.message&&e.code.match(/Signature/)&&e.message.match(/expired/)&&(t.error.retryable=!0)}),t("CLOCK_SKEWED","retry",function(t){t.error&&this.service.clockSkewError(t.error)&&this.service.config.correctClockSkew&&n.config.isClockSkewed&&(t.error.retryable=!0)}),t("REDIRECT","retry",function(t){t.error&&t.error.statusCode>=300&&t.error.statusCode<400&&t.httpResponse.headers.location&&(this.httpRequest.endpoint=new n.Endpoint(t.httpResponse.headers.location),this.httpRequest.headers.Host=this.httpRequest.endpoint.host,t.error.redirect=!0,t.error.retryable=!0)}),t("RETRY_CHECK","retry",function(t){t.error&&(t.error.redirect&&t.redirectCount<t.maxRedirects?t.error.retryDelay=0:t.retryCount<t.maxRetries&&(t.error.retryDelay=this.service.retryDelays(t.retryCount)||0))}),e("RESET_RETRY_STATE","afterRetry",function(t,e){var r,n=!1;t.error&&(r=t.error.retryDelay||0,t.error.retryable&&t.retryCount<t.maxRetries?(t.retryCount++,n=!0):t.error.redirect&&t.redirectCount<t.maxRedirects&&(t.redirectCount++,n=!0)),n?(t.error=null,setTimeout(e,r)):e()})}),CorePost:(new i).addNamedListeners(function(t){t("EXTRACT_REQUEST_ID","extractData",n.util.extractRequestId),t("EXTRACT_REQUEST_ID","extractError",n.util.extractRequestId),t("ENOTFOUND_ERROR","httpError",function(t){if("NetworkingError"===t.code&&"ENOTFOUND"===t.errno){var e="Inaccessible host: `"+t.hostname+"'. This service may not be available in the `"+t.region+"' region.";this.response.error=n.util.error(new Error(e),{code:"UnknownEndpoint",region:t.region,hostname:t.hostname,retryable:!0,originalError:t})}})}),Logger:(new i).addNamedListeners(function(e){e("LOG_REQUEST","complete",function(e){function r(){var r=n.util.date.getDate().getTime(),s=(r-i.startTime.getTime())/1e3,a=o.isTTY?!0:!1,u=e.httpResponse.statusCode,c=t("util").inspect(i.params,!0,null),l="";return a&&(l+="[33m"),l+="[AWS "+i.service.serviceIdentifier+" "+u,l+=" "+s.toString()+"s "+e.retryCount+" retries]",a&&(l+="[0;1m"),l+=" "+n.util.string.lowerFirst(i.operation),l+="("+c+")",a&&(l+="[0m"),l}var i=e.request,o=i.service.config.logger;if(o){var s=r();"function"==typeof o.log?o.log(s):"function"==typeof o.write&&o.write(s+"\n")}})}),Json:(new i).addNamedListeners(function(e){var r=t("./protocol/json");e("BUILD","build",r.buildRequest),e("EXTRACT_DATA","extractData",r.extractData),e("EXTRACT_ERROR","extractError",r.extractError)}),Rest:(new i).addNamedListeners(function(e){var r=t("./protocol/rest");e("BUILD","build",r.buildRequest),e("EXTRACT_DATA","extractData",r.extractData),e("EXTRACT_ERROR","extractError",r.extractError)}),RestJson:(new i).addNamedListeners(function(e){var r=t("./protocol/rest_json");e("BUILD","build",r.buildRequest),e("EXTRACT_DATA","extractData",r.extractData),e("EXTRACT_ERROR","extractError",r.extractError)}),RestXml:(new i).addNamedListeners(function(e){var r=t("./protocol/rest_xml");e("BUILD","build",r.buildRequest),e("EXTRACT_DATA","extractData",r.extractData),e("EXTRACT_ERROR","extractError",r.extractError)}),Query:(new i).addNamedListeners(function(e){var r=t("./protocol/query");e("BUILD","build",r.buildRequest),e("EXTRACT_DATA","extractData",r.extractData),e("EXTRACT_ERROR","extractError",r.extractError)})}},{"./core":24,"./protocol/json":48,"./protocol/query":49,"./protocol/rest":50,"./protocol/rest_json":51,"./protocol/rest_xml":52,"./sequential_executor":60,util:20}],60:[function(t,e,r){var n=t("./core");n.SequentialExecutor=n.util.inherit({constructor:function(){this._events={}},listeners:function(t){return this._events[t]?this._events[t].slice(0):[]},on:function(t,e){return this._events[t]?this._events[t].push(e):this._events[t]=[e],this},onAsync:function(t,e){return e._isAsync=!0,this.on(t,e)},removeListener:function(t,e){var r=this._events[t];if(r){for(var n=r.length,i=-1,o=0;n>o;++o)r[o]===e&&(i=o);i>-1&&r.splice(i,1)}return this},removeAllListeners:function(t){return t?delete this._events[t]:this._events={},this},emit:function(t,e,r){r||(r=function(){});var n=this.listeners(t),i=n.length;return this.callListeners(n,e,r),i>0},callListeners:function(t,e,r,i){function o(i){return i&&(a=n.util.error(a||new Error,i),s._haltHandlersOnError)?r.call(s,a):void s.callListeners(t,e,r,a)}for(var s=this,a=i||null;t.length>0;){var u=t.shift();if(u._isAsync)return void u.apply(s,e.concat([o]));try{u.apply(s,e)}catch(c){a=n.util.error(a||new Error,c)}if(a&&s._haltHandlersOnError)return void r.call(s,a)}r.call(s,a)},addListeners:function(t){var e=this;return t._events&&(t=t._events),n.util.each(t,function(t,r){"function"==typeof r&&(r=[r]),n.util.arrayEach(r,function(r){e.on(t,r)})}),e},addNamedListener:function(t,e,r){return this[t]=r,this.addListener(e,r),this},addNamedAsyncListener:function(t,e,r){return r._isAsync=!0,this.addNamedListener(t,e,r)},addNamedListeners:function(t){var e=this;return t(function(){e.addNamedListener.apply(e,arguments)},function(){e.addNamedAsyncListener.apply(e,arguments)}),this}}),n.SequentialExecutor.prototype.addListener=n.SequentialExecutor.prototype.on,e.exports=n.SequentialExecutor},{"./core":24}],52:[function(t,e,r){function n(t){var e=t.service.api.operations[t.operation].input,r=new a.XML.Builder,n=t.params,i=e.payload;if(i){var o=e.members[i];if(n=n[i],void 0===n)return;if("structure"===o.type){var s=o.name;t.httpRequest.body=r.toXML(n,o,s,!0)}else t.httpRequest.body=n}else t.httpRequest.body=r.toXML(n,e,e.name||e.shape||u.string.upperFirst(t.operation)+"Request")}function i(t){c.buildRequest(t),["GET","HEAD"].indexOf(t.httpRequest.method)<0&&n(t)}function o(t){c.extractError(t);var e=(new a.XML.Parser).parse(t.httpResponse.body.toString());e.Errors&&(e=e.Errors),e.Error&&(e=e.Error),e.Code?t.error=u.error(new Error,{code:e.Code,message:e.Message}):t.error=u.error(new Error,{code:t.httpResponse.statusCode,message:null})}function s(t){c.extractData(t);var e,r=t.request,n=t.httpResponse.body,i=r.service.api.operations[r.operation],o=i.output,s=o.payload;if(s){var l=o.members[s];l.isStreaming?t.data[s]=n:"structure"===l.type?(e=new a.XML.Parser,t.data[s]=e.parse(n.toString(),l)):t.data[s]=n.toString()}else if(n.length>0){e=new a.XML.Parser;var h=e.parse(n.toString(),o);u.update(t.data,h)}}var a=t("../core"),u=t("../util"),c=t("./rest");e.exports={buildRequest:i,extractError:o,extractData:s}},{"../core":24,"../util":84,"./rest":50}],51:[function(t,e,r){function n(t){var e=new l,r=t.service.api.operations[t.operation].input;if(r.payload){var n={},i=r.members[r.payload];if(n=t.params[r.payload],void 0===n)return;"structure"===i.type?t.httpRequest.body=e.build(n,i):t.httpRequest.body=n}else t.httpRequest.body=e.build(t.params,r)}function i(t){u.buildRequest(t),["GET","HEAD","DELETE"].indexOf(t.httpRequest.method)<0&&n(t)}function o(t){c.extractError(t)}function s(t){u.extractData(t);var e=t.request,r=e.service.api.operations[e.operation].output||{};if(r.payload){var n=r.members[r.payload],i=t.httpResponse.body;if(n.isStreaming)t.data[r.payload]=i;else if("structure"===n.type||"list"===n.type){var o=new h;t.data[r.payload]=o.parse(i,n)}else t.data[r.payload]=i.toString()}else{var s=t.data;c.extractData(t),t.data=a.merge(s,t.data)}}var a=t("../util"),u=t("./rest"),c=t("./json"),l=t("../json/builder"),h=t("../json/parser");e.exports={buildRequest:i,extractError:o,extractData:s}},{"../json/builder":39,"../json/parser":40,"../util":84,"./json":48,"./rest":50}],50:[function(t,e,r){function n(t){t.httpRequest.method=t.service.api.operations[t.operation].httpMethod}function i(t){var e=t.service.api.operations[t.operation],r=e.input,n=[t.httpRequest.endpoint.path,e.httpPath].join("/");n=n.replace(/\/+/g,"/");var i={},o=!1;if(c.each(r.members,function(e,r){var s=t.params[e];if(null!==s&&void 0!==s)if("uri"===r.location){var a=new RegExp("\\{"+r.name+"(\\+)?\\}");n=n.replace(a,function(t,e){var r=e?c.uriEscapePath:c.uriEscape;return r(String(s))})}else"querystring"===r.location&&(o=!0,"list"===r.type?i[r.name]=s.map(function(t){return c.uriEscape(String(t))}):"map"===r.type?c.each(s,function(t,e){Array.isArray(e)?i[t]=e.map(function(t){return c.uriEscape(String(t))}):i[t]=c.uriEscape(String(e))}):i[r.name]=c.uriEscape(String(s)))}),o){n+=n.indexOf("?")>=0?"&":"?";var s=[];c.arrayEach(Object.keys(i).sort(),function(t){Array.isArray(i[t])||(i[t]=[i[t]]);for(var e=0;e<i[t].length;e++)s.push(c.uriEscape(String(t))+"="+i[t][e])}),n+=s.join("&")}t.httpRequest.path=n}function o(t){var e=t.service.api.operations[t.operation];c.each(e.input.members,function(e,r){var n=t.params[e];null!==n&&void 0!==n&&("headers"===r.location&&"map"===r.type?c.each(n,function(e,n){t.httpRequest.headers[r.name+e]=n}):"header"===r.location&&(n=r.toWireFormat(n).toString(),t.httpRequest.headers[r.name]=n))})}function s(t){n(t),i(t),o(t)}function a(){}function u(t){var e=t.request,r={},n=t.httpResponse,i=e.service.api.operations[e.operation],o=i.output,s={};c.each(n.headers,function(t,e){s[t.toLowerCase()]=e}),c.each(o.members,function(t,e){var i=(e.name||t).toLowerCase();if("headers"===e.location&&"map"===e.type){r[t]={};var o=e.isLocationName?e.name:"",a=new RegExp("^"+o+"(.+)","i");c.each(n.headers,function(e,n){var i=e.match(a);null!==i&&(r[t][i[1]]=n)})}else"header"===e.location?void 0!==s[i]&&(r[t]=s[i]):"statusCode"===e.location&&(r[t]=parseInt(n.statusCode,10))}),t.data=r}var c=t("../util");e.exports={buildRequest:s,extractError:a,extractData:u}},{"../util":84}],49:[function(t,e,r){function n(t){var e=t.service.api.operations[t.operation],r=t.httpRequest;r.headers["Content-Type"]="application/x-www-form-urlencoded; charset=utf-8",r.params={Version:t.service.api.apiVersion,Action:e.name};var n=new u;n.serialize(t.params,e.input,function(t,e){r.params[t]=e}),r.body=a.queryParamsToString(r.params)}function i(t){var e,r=t.httpResponse.body.toString();e=r.match("<UnknownOperationException")?{Code:"UnknownOperation",Message:"Unknown operation "+t.request.operation}:(new s.XML.Parser).parse(r),e.requestId&&!t.requestId&&(t.requestId=e.requestId),e.Errors&&(e=e.Errors),e.Error&&(e=e.Error),e.Code?t.error=a.error(new Error,{code:e.Code,message:e.Message}):t.error=a.error(new Error,{code:t.httpResponse.statusCode,message:null})}function o(t){var e=t.request,r=e.service.api.operations[e.operation],n=r.output||{},i=n;if(i.resultWrapper){var o=c.create({type:"structure"});o.members[i.resultWrapper]=n,o.memberNames=[i.resultWrapper],a.property(n,"name",n.resultWrapper),n=o}var u=new s.XML.Parser;if(n&&n.members&&!n.members._XAMZRequestId){var l=c.create({type:"string"},{api:{protocol:"query"}},"requestId");n.members._XAMZRequestId=l}var h=u.parse(t.httpResponse.body.toString(),n);t.requestId=h._XAMZRequestId||h.requestId,h._XAMZRequestId&&delete h._XAMZRequestId,i.resultWrapper&&h[i.resultWrapper]&&(a.update(h,h[i.resultWrapper]),delete h[i.resultWrapper]),t.data=h}var s=t("../core"),a=t("../util"),u=t("../query/query_param_serializer"),c=t("../model/shape");e.exports={buildRequest:n,extractError:i,extractData:o}},{"../core":24,"../model/shape":46,"../query/query_param_serializer":53,"../util":84}],53:[function(t,e,r){function n(){}function i(t){return t.isQueryName||"ec2"!==t.api.protocol?t.name:t.name[0].toUpperCase()+t.name.substr(1)}function o(t,e,r,n){c.each(r.members,function(r,o){var s=e[r];if(null!==s&&void 0!==s){var a=i(o);a=t?t+"."+a:a,u(a,s,o,n)}})}function s(t,e,r,n){var i=1;c.each(e,function(e,o){var s=r.flattened?".":".entry.",a=s+i++ +".",c=a+(r.key.name||"key"),l=a+(r.value.name||"value");u(t+c,e,r.key,n),u(t+l,o,r.value,n)})}function a(t,e,r,n){var o=r.member||{};return 0===e.length?void n.call(this,t,null):void c.arrayEach(e,function(e,s){var a="."+(s+1);if("ec2"===r.api.protocol)a+="";else if(r.flattened){if(o.name){var c=t.split(".");c.pop(),c.push(i(o)),t=c.join(".")}}else a=".member"+a;u(t+a,e,o,n)})}function u(t,e,r,n){null!==e&&void 0!==e&&("structure"===r.type?o(t,e,r,n):"list"===r.type?a(t,e,r,n):"map"===r.type?s(t,e,r,n):n(t,r.toWireFormat(e).toString()))}var c=t("../util");n.prototype.serialize=function(t,e,r){o("",t,e,r)},e.exports=n},{"../util":84}],46:[function(t,e,r){function n(t,e,r){null!==r&&void 0!==r&&m.property.apply(this,arguments)}function i(t,e){t.constructor.prototype[e]||m.memoizedProperty.apply(this,arguments)}function o(t,e,r){e=e||{},n(this,"shape",t.shape),n(this,"api",e.api,!1),n(this,"type",t.type),n(this,"enum",t["enum"]),n(this,"min",t.min),n(this,"max",t.max),n(this,"pattern",t.pattern),n(this,"location",t.location||this.location||"body"),n(this,"name",this.name||t.xmlName||t.queryName||t.locationName||r),n(this,"isStreaming",t.streaming||this.isStreaming||!1),n(this,"isComposite",t.isComposite||!1),n(this,"isShape",!0,!1),n(this,"isQueryName",t.queryName?!0:!1,!1),n(this,"isLocationName",t.locationName?!0:!1,!1),e.documentation&&(n(this,"documentation",t.documentation),n(this,"documentationUrl",t.documentationUrl)),t.xmlAttribute&&n(this,"isXmlAttribute",t.xmlAttribute||!1),n(this,"defaultValue",null),this.toWireFormat=function(t){return null===t||void 0===t?"":t},this.toType=function(t){return t}}function s(t){o.apply(this,arguments),n(this,"isComposite",!0),t.flattened&&n(this,"flattened",t.flattened||!1)}function a(t,e){var r=null,a=!this.isShape;s.apply(this,arguments),a&&(n(this,"defaultValue",function(){return{}}),n(this,"members",{}),n(this,"memberNames",[]),n(this,"required",[]),n(this,"isRequired",function(){return!1})),t.members&&(n(this,"members",new g(t.members,e,function(t,r){return o.create(r,e,t)})),i(this,"memberNames",function(){return t.xmlOrder||Object.keys(t.members)})),t.required&&(n(this,"required",t.required),n(this,"isRequired",function(e){if(!r){r={};for(var n=0;n<t.required.length;n++)r[t.required[n]]=!0}return r[e]},!1,!0)),n(this,"resultWrapper",t.resultWrapper||null),t.payload&&n(this,"payload",t.payload),"string"==typeof t.xmlNamespace?n(this,"xmlNamespaceUri",t.xmlNamespace):"object"==typeof t.xmlNamespace&&(n(this,"xmlNamespacePrefix",t.xmlNamespace.prefix),n(this,"xmlNamespaceUri",t.xmlNamespace.uri))}function u(t,e){var r=this,a=!this.isShape;if(s.apply(this,arguments),a&&n(this,"defaultValue",function(){return[]}),t.member&&i(this,"member",function(){return o.create(t.member,e)}),this.flattened){var u=this.name;i(this,"name",function(){return r.member.name||u})}}function c(t,e){var r=!this.isShape;s.apply(this,arguments),r&&(n(this,"defaultValue",function(){return{}}),n(this,"key",o.create({type:"string"},e)),n(this,"value",o.create({type:"string"},e))),t.key&&i(this,"key",function(){return o.create(t.key,e)}),t.value&&i(this,"value",function(){return o.create(t.value,e)})}function l(t){var e=this;if(o.apply(this,arguments),"header"===this.location)n(this,"timestampFormat","rfc822");else if(t.timestampFormat)n(this,"timestampFormat",t.timestampFormat);else if(this.api)if(this.api.timestampFormat)n(this,"timestampFormat",this.api.timestampFormat);else switch(this.api.protocol){case"json":case"rest-json":n(this,"timestampFormat","unixTimestamp");break;case"rest-xml":case"query":case"ec2":n(this,"timestampFormat","iso8601")}this.toType=function(t){return null===t||void 0===t?null:"function"==typeof t.toUTCString?t:"string"==typeof t||"number"==typeof t?m.date.parseTimestamp(t):null},this.toWireFormat=function(t){return m.date.format(t,e.timestampFormat)}}function h(){if(o.apply(this,arguments),this.api)switch(this.api.protocol){case"rest-xml":case"query":case"ec2":this.toType=function(t){return t||""}}}function p(){o.apply(this,arguments),this.toType=function(t){return null===t||void 0===t?null:parseFloat(t)},this.toWireFormat=this.toType}function f(){o.apply(this,arguments),this.toType=function(t){return null===t||void 0===t?null:parseInt(t,10)},this.toWireFormat=this.toType}function d(){o.apply(this,arguments),this.toType=m.base64.decode,this.toWireFormat=m.base64.encode}function y(){d.apply(this,arguments)}function v(){o.apply(this,arguments),this.toType=function(t){return"boolean"==typeof t?t:null===t||void 0===t?null:"true"===t}}var g=t("./collection"),m=t("../util");o.normalizedTypes={character:"string","double":"float","long":"integer","short":"integer",biginteger:"integer",bigdecimal:"float",blob:"binary"},o.types={structure:a,list:u,map:c,"boolean":v,timestamp:l,"float":p,integer:f,string:h,base64:y,binary:d},o.resolve=function(t,e){if(t.shape){var r=e.api.shapes[t.shape];if(!r)throw new Error("Cannot find shape reference: "+t.shape);return r}return null},o.create=function(t,e,r){if(t.isShape)return t;var n=o.resolve(t,e);if(n){var i=Object.keys(t);if(e.documentation||(i=i.filter(function(t){return!t.match(/documentation/)})),i===["shape"])return n;var s=function(){n.constructor.call(this,t,e,r)};return s.prototype=n,new s}t.type||(t.members?t.type="structure":t.member?t.type="list":t.key?t.type="map":t.type="string");var a=t.type;if(o.normalizedTypes[t.type]&&(t.type=o.normalizedTypes[t.type]),o.types[t.type])return new o.types[t.type](t,e,r);throw new Error("Unrecognized shape type: "+a)},o.shapes={StructureShape:a,ListShape:u,MapShape:c,StringShape:h,BooleanShape:v,Base64Shape:y},e.exports=o},{"../util":84,"./collection":42}],42:[function(t,e,r){function n(t,e,r,n){o(this,n(t),function(){return r(t,e)})}function i(t,e,r,i){i=i||String;var o=this;for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&n.call(o,s,t[s],r,i)}var o=t("../util").memoizedProperty;e.exports=i},{"../util":84}],48:[function(t,e,r){function n(t){var e=t.httpRequest,r=t.service.api,n=r.targetPrefix+"."+r.operations[t.operation].name,i=r.jsonVersion||"1.0",o=r.operations[t.operation].input,s=new a;1===i&&(i="1.0"),e.body=s.build(t.params||{},o),e.headers["Content-Type"]="application/x-amz-json-"+i,e.headers["X-Amz-Target"]=n}function i(t){var e={},r=t.httpResponse;if(e.code=r.headers["x-amzn-errortype"]||"UnknownError","string"==typeof e.code&&(e.code=e.code.split(":")[0]),r.body.length>0){var n=JSON.parse(r.body.toString());(n.__type||n.code)&&(e.code=(n.__type||n.code).split("#").pop()),"RequestEntityTooLarge"===e.code?e.message="Request body must be less than 1 MB":e.message=n.message||n.Message||null}else e.statusCode=r.statusCode,e.message=r.statusCode.toString();t.error=s.error(new Error,e)}function o(t){var e=t.httpResponse.body.toString()||"{}";if(t.request.service.config.convertResponseTypes===!1)t.data=JSON.parse(e);else{
var r=t.request.service.api.operations[t.request.operation],n=r.output||{},i=new u;t.data=i.parse(e,n)}}var s=t("../util"),a=t("../json/builder"),u=t("../json/parser");e.exports={buildRequest:n,extractError:i,extractData:o}},{"../json/builder":39,"../json/parser":40,"../util":84}],40:[function(t,e,r){function n(){}function i(t,e){if(!e||void 0===t)return void 0;switch(e.type){case"structure":return o(t,e);case"map":return a(t,e);case"list":return s(t,e);default:return u(t,e)}}function o(t,e){if(null==t)return void 0;var r={},n=e.members;return c.each(n,function(e,n){var o=n.isLocationName?n.name:e;if(Object.prototype.hasOwnProperty.call(t,o)){var s=t[o],a=i(s,n);void 0!==a&&(r[e]=a)}}),r}function s(t,e){if(null==t)return void 0;var r=[];return c.arrayEach(t,function(t){var n=i(t,e.member);void 0===n?r.push(null):r.push(n)}),r}function a(t,e){if(null==t)return void 0;var r={};return c.each(t,function(t,n){var o=i(n,e.value);void 0===o?r[t]=null:r[t]=o}),r}function u(t,e){return e.toType(t)}var c=t("../util");n.prototype.parse=function(t,e){return i(JSON.parse(t),e)},e.exports=n},{"../util":84}],39:[function(t,e,r){function n(){}function i(t,e){if(!e||void 0===t||null===t)return void 0;switch(e.type){case"structure":return o(t,e);case"map":return a(t,e);case"list":return s(t,e);default:return u(t,e)}}function o(t,e){var r={};return c.each(t,function(t,n){var o=e.members[t];if(o){if("body"!==o.location)return;var s=o.isLocationName?o.name:t,a=i(n,o);void 0!==a&&(r[s]=a)}}),r}function s(t,e){var r=[];return c.arrayEach(t,function(t){var n=i(t,e.member);void 0!==n&&r.push(n)}),r}function a(t,e){var r={};return c.each(t,function(t,n){var o=i(n,e.value);void 0!==o&&(r[t]=o)}),r}function u(t,e){return e.toWireFormat(t)}var c=t("../util");n.prototype.build=function(t,e){return JSON.stringify(i(t,e))},e.exports=n},{"../util":84}],84:[function(t,e,r){(function(r){var n,i=t("crypto"),o=t("buffer").Buffer,s={engine:function(){return s.isBrowser()&&"undefined"!=typeof navigator?navigator.userAgent:r.platform+"/"+r.version},userAgent:function(){var e=s.isBrowser()?"js":"nodejs",r="aws-sdk-"+e+"/"+t("./core").VERSION;return"nodejs"===e&&(r+=" "+s.engine()),r},isBrowser:function(){return r&&r.browser},isNode:function(){return!s.isBrowser()},nodeRequire:function(e){return s.isNode()?t(e):void 0},multiRequire:function(e,r){return t(s.isNode()?e:r)},uriEscape:function(t){var e=encodeURIComponent(t);return e=e.replace(/[^A-Za-z0-9_.~\-%]+/g,escape),e=e.replace(/[*]/g,function(t){return"%"+t.charCodeAt(0).toString(16).toUpperCase()})},uriEscapePath:function(t){var e=[];return s.arrayEach(t.split("/"),function(t){e.push(s.uriEscape(t))}),e.join("/")},urlParse:function(e){return t("url").parse(e)},urlFormat:function(e){return t("url").format(e)},queryStringParse:function(e){return t("querystring").parse(e)},queryParamsToString:function(t){var e=[],r=s.uriEscape,n=Object.keys(t).sort();return s.arrayEach(n,function(n){var i=t[n],o=r(n),a=o+"=";if(Array.isArray(i)){var u=[];s.arrayEach(i,function(t){u.push(r(t))}),a=o+"="+u.sort().join("&"+o+"=")}else void 0!==i&&null!==i&&(a=o+"="+r(i));e.push(a)}),e.join("&")},readFileSync:function(t){return s.isBrowser()?null:s.nodeRequire("fs").readFileSync(t,"utf-8")},base64:{encode:function(t){return new o(t).toString("base64")},decode:function(t){return new o(t,"base64")}},Buffer:o,buffer:{toStream:function(t){s.Buffer.isBuffer(t)||(t=new s.Buffer(t));var e=new(s.nodeRequire("stream").Readable),r=0;return e._read=function(n){if(r>=t.length)return e.push(null);var i=r+n;i>t.length&&(i=t.length),e.push(t.slice(r,i)),r=i},e},concat:function(t){var e,r=0,n=0,i=null;for(e=0;e<t.length;e++)r+=t[e].length;for(i=new o(r),e=0;e<t.length;e++)t[e].copy(i,n),n+=t[e].length;return i}},string:{byteLength:function(t){if(null===t||void 0===t)return 0;if("string"==typeof t&&(t=new o(t)),"number"==typeof t.byteLength)return t.byteLength;if("number"==typeof t.length)return t.length;if("number"==typeof t.size)return t.size;if("string"==typeof t.path)return s.nodeRequire("fs").lstatSync(t.path).size;throw s.error(new Error("Cannot determine length of "+t),{object:t})},upperFirst:function(t){return t[0].toUpperCase()+t.substr(1)},lowerFirst:function(t){return t[0].toLowerCase()+t.substr(1)}},ini:{parse:function(t){var e,r={};return s.arrayEach(t.split(/\r?\n/),function(t){t=t.split(/(^|\s);/)[0];var n=t.match(/^\s*\[([^\[\]]+)\]\s*$/);if(n)e=n[1];else if(e){var i=t.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);i&&(r[e]=r[e]||{},r[e][i[1]]=i[2])}}),r}},fn:{noop:function(){},makeAsync:function(t,e){return e&&e<=t.length?t:function(){var e=Array.prototype.slice.call(arguments,0),r=e.pop(),n=t.apply(null,e);r(n)}}},date:{getDate:function(){return n||(n=t("./core")),n.config.systemClockOffset?new Date((new Date).getTime()+n.config.systemClockOffset):new Date},iso8601:function(t){return void 0===t&&(t=s.date.getDate()),t.toISOString().replace(/\.\d{3}Z$/,"Z")},rfc822:function(t){return void 0===t&&(t=s.date.getDate()),t.toUTCString()},unixTimestamp:function(t){return void 0===t&&(t=s.date.getDate()),t.getTime()/1e3},from:function(t){return"number"==typeof t?new Date(1e3*t):new Date(t)},format:function(t,e){return e||(e="iso8601"),s.date[e](s.date.from(t))},parseTimestamp:function(t){if("number"==typeof t)return new Date(1e3*t);if(t.match(/^\d+$/))return new Date(1e3*t);if(t.match(/^\d{4}/))return new Date(t);if(t.match(/^\w{3},/))return new Date(t);throw s.error(new Error("unhandled timestamp format: "+t),{code:"TimestampParserError"})}},crypto:{crc32Table:[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],crc32:function(t){var e=s.crypto.crc32Table,r=-1;"string"==typeof t&&(t=new o(t));for(var n=0;n<t.length;n++){var i=t.readUInt8(n);r=r>>>8^e[255&(r^i)]}return(-1^r)>>>0},hmac:function(t,e,r,n){return r||(r="binary"),"buffer"===r&&(r=void 0),n||(n="sha256"),"string"==typeof e&&(e=new o(e)),i.createHmac(n,t).update(e).digest(r)},md5:function(t,e,r){return s.crypto.hash("md5",t,e,r)},sha256:function(t,e,r){return s.crypto.hash("sha256",t,e,r)},hash:function(t,e,r,n){var i=s.crypto.createHash(t);r||(r="binary"),"buffer"===r&&(r=void 0),"string"==typeof e&&(e=new o(e));var a=s.arraySliceFn(e),u=o.isBuffer(e);if(s.isBrowser()&&"undefined"!=typeof ArrayBuffer&&e&&e.buffer instanceof ArrayBuffer&&(u=!0),n&&"object"==typeof e&&"function"==typeof e.on&&!u)e.on("data",function(t){i.update(t)}),e.on("error",function(t){n(t)}),e.on("end",function(){n(null,i.digest(r))});else{if(!n||!a||u||"undefined"==typeof FileReader){s.isBrowser()&&"object"==typeof e&&!u&&(e=new o(new Uint8Array(e)));var c=i.update(e).digest(r);return n&&n(null,c),c}var l=0,h=524288,p=new FileReader;p.onerror=function(){n(new Error("Failed to read data."))},p.onload=function(){var t=new o(new Uint8Array(p.result));i.update(t),l+=t.length,p._continueReading()},p._continueReading=function(){if(l>=e.size)return void n(null,i.digest(r));var t=l+h;t>e.size&&(t=e.size),p.readAsArrayBuffer(a.call(e,l,t))},p._continueReading()}},toHex:function(t){for(var e=[],r=0;r<t.length;r++)e.push(("0"+t.charCodeAt(r).toString(16)).substr(-2,2));return e.join("")},createHash:function(t){return i.createHash(t)}},abort:{},each:function(t,e){for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=e.call(this,r,t[r]);if(n===s.abort)break}},arrayEach:function(t,e){for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=e.call(this,t[r],parseInt(r,10));if(n===s.abort)break}},update:function(t,e){return s.each(e,function(e,r){t[e]=r}),t},merge:function(t,e){return s.update(s.copy(t),e)},copy:function(t){if(null===t||void 0===t)return t;var e={};for(var r in t)e[r]=t[r];return e},isEmpty:function(t){for(var e in t)if(Object.prototype.hasOwnProperty.call(t,e))return!1;return!0},arraySliceFn:function(t){var e=t.slice||t.webkitSlice||t.mozSlice;return"function"==typeof e?e:null},isType:function(t,e){return"function"==typeof e&&(e=s.typeName(e)),Object.prototype.toString.call(t)==="[object "+e+"]"},typeName:function(t){if(Object.prototype.hasOwnProperty.call(t,"name"))return t.name;var e=t.toString(),r=e.match(/^\s*function (.+)\(/);return r?r[1]:e},error:function(t,e){var r=null;return"string"==typeof t.message&&""!==t.message&&("string"==typeof e||e&&e.message)&&(r=s.copy(t),r.message=t.message),t.message=t.message||null,"string"==typeof e?t.message=e:"object"==typeof e&&null!==e&&(s.update(t,e),e.message&&(t.message=e.message),(e.code||e.name)&&(t.code=e.code||e.name),e.stack&&(t.stack=e.stack)),"function"==typeof Object.defineProperty&&(Object.defineProperty(t,"name",{writable:!0,enumerable:!1}),Object.defineProperty(t,"message",{enumerable:!0})),t.name=e&&e.name||t.name||t.code||"Error",t.time=new Date,r&&(t.originalError=r),t},inherit:function(t,e){var r=null;if(void 0===e)e=t,t=Object,r={};else{var n=function(){};n.prototype=t.prototype,r=new n}return e.constructor===Object&&(e.constructor=function(){return t!==Object?t.apply(this,arguments):void 0}),e.constructor.prototype=r,s.update(e.constructor.prototype,e),e.constructor.__super__=t,e.constructor},mixin:function(){for(var t=arguments[0],e=1;e<arguments.length;e++)for(var r in arguments[e].prototype){var n=arguments[e].prototype[r];"constructor"!==r&&(t.prototype[r]=n)}return t},hideProperties:function(t,e){"function"==typeof Object.defineProperty&&s.arrayEach(e,function(e){Object.defineProperty(t,e,{enumerable:!1,writable:!0,configurable:!0})})},property:function(t,e,r,n,i){var o={configurable:!0,enumerable:void 0!==n?n:!0};"function"!=typeof r||i?(o.value=r,o.writable=!0):o.get=r,Object.defineProperty(t,e,o)},memoizedProperty:function(t,e,r,n){var i=null;s.property(t,e,function(){return null===i&&(i=r()),i},n)},hoistPayloadMember:function(t){var e=t.request,r=e.operation,n=e.service.api.operations[r].output;if(n.payload){var i=n.members[n.payload],o=t.data[n.payload];"structure"===i.type&&s.each(o,function(e,r){s.property(t.data,e,r,!1)})}},computeSha256:function(t,e){if(s.isNode()){var r=s.nodeRequire("stream").Stream,n=s.nodeRequire("fs");if(t instanceof r){if("string"!=typeof t.path)return e(new Error("Non-file stream objects are not supported with SigV4"));var i={};"number"==typeof t.start&&(i.start=t.start),"number"==typeof t.end&&(i.end=t.end),t=n.createReadStream(t.path,i)}}s.crypto.sha256(t,"hex",function(t,r){t?e(t):e(null,r)})},isClockSkewed:function(t){return t?(s.property(n.config,"isClockSkewed",Math.abs((new Date).getTime()-t)>=3e5,!1),n.config.isClockSkewed):void 0},applyClockOffset:function(t){t&&(n.config.systemClockOffset=t-(new Date).getTime())},extractRequestId:function(t){var e=t.httpResponse.headers["x-amz-request-id"]||t.httpResponse.headers["x-amzn-requestid"];!e&&t.data&&t.data.ResponseMetadata&&(e=t.data.ResponseMetadata.RequestId),e&&(t.requestId=e),t.error&&(t.error.requestId=e)},addPromisesToRequests:function(t,e){return e=e||null,e||"undefined"==typeof Promise||(e=Promise),"function"!=typeof e?void delete t.prototype.promise:void(t.prototype.promise=function(){var t=this;return new e(function(e,r){t.on("complete",function(t){t.error?r(t.error):e(t.data)}),t.runTo()})})}};e.exports=s}).call(this,t("_process"))},{"./core":24,_process:13,buffer:1,crypto:6,querystring:17,url:18}],30:[function(t,e,r){var n=t("../core");n.WebIdentityCredentials=n.util.inherit(n.Credentials,{constructor:function(t){n.Credentials.call(this),this.expired=!0,this.params=t,this.params.RoleSessionName=this.params.RoleSessionName||"web-identity",this.data=null},refresh:function(t){var e=this;e.createClients(),t||(t=function(t){if(t)throw t}),e.service.assumeRoleWithWebIdentity(function(r,n){e.data=null,r||(e.data=n,e.service.credentialsFrom(n,e)),t(r)})},createClients:function(){this.service=this.service||new n.STS({params:this.params})}})},{"../core":24}],29:[function(t,e,r){var n=t("../core");n.TemporaryCredentials=n.util.inherit(n.Credentials,{constructor:function(t){n.Credentials.call(this),this.loadMasterCredentials(),this.expired=!0,this.params=t||{},this.params.RoleArn&&(this.params.RoleSessionName=this.params.RoleSessionName||"temporary-credentials")},refresh:function(t){var e=this;e.createClients(),t||(t=function(t){if(t)throw t}),e.service.config.credentials=e.masterCredentials;var r=e.params.RoleArn?e.service.assumeRole:e.service.getSessionToken;r.call(e.service,function(r,n){r||e.service.credentialsFrom(n,e),t(r)})},loadMasterCredentials:function(){for(this.masterCredentials=n.config.credentials;this.masterCredentials.masterCredentials;)this.masterCredentials=this.masterCredentials.masterCredentials},createClients:function(){this.service=this.service||new n.STS({params:this.params})}})},{"../core":24}],28:[function(t,e,r){var n=t("../core");n.SAMLCredentials=n.util.inherit(n.Credentials,{constructor:function(t){n.Credentials.call(this),this.expired=!0,this.params=t},refresh:function(t){var e=this;e.createClients(),t||(t=function(t){if(t)throw t}),e.service.assumeRoleWithSAML(function(r,n){r||e.service.credentialsFrom(n,e),t(r)})},createClients:function(){this.service=this.service||new n.STS({params:this.params})}})},{"../core":24}],26:[function(t,e,r){var n=t("../core");n.CognitoIdentityCredentials=n.util.inherit(n.Credentials,{localStorageKey:{id:"aws.cognito.identity-id.",providers:"aws.cognito.identity-providers."},constructor:function(t){n.Credentials.call(this),this.expired=!0,this.params=t,this.data=null,this.identityId=null,this.loadCachedId()},refresh:function(t){var e=this;e.createClients(),e.data=null,e.identityId=null,e.getId(function(r){r?(e.clearIdOnNotAuthorized(r),t(r)):e.params.RoleArn?e.getCredentialsFromSTS(t):e.getCredentialsForIdentity(t)})},clearCachedId:function(){this.identityId=null,delete this.params.IdentityId;var t=this.params.IdentityPoolId,e=this.params.LoginId||"";delete this.storage[this.localStorageKey.id+t+e],delete this.storage[this.localStorageKey.providers+t+e]},clearIdOnNotAuthorized:function(t){var e=this;"NotAuthorizedException"==t.code&&e.clearCachedId()},getId:function(t){var e=this;return"string"==typeof e.params.IdentityId?t(null,e.params.IdentityId):void e.cognito.getId(function(r,n){!r&&n.IdentityId?(e.params.IdentityId=n.IdentityId,t(null,n.IdentityId)):t(r)})},loadCredentials:function(t,e){t&&e&&(e.expired=!1,e.accessKeyId=t.Credentials.AccessKeyId,e.secretAccessKey=t.Credentials.SecretKey,e.sessionToken=t.Credentials.SessionToken,e.expireTime=t.Credentials.Expiration)},getCredentialsForIdentity:function(t){var e=this;e.cognito.getCredentialsForIdentity(function(r,n){r?e.clearIdOnNotAuthorized(r):(e.cacheId(n),e.data=n,e.loadCredentials(e.data,e)),t(r)})},getCredentialsFromSTS:function(t){var e=this;e.cognito.getOpenIdToken(function(r,n){r?(e.clearIdOnNotAuthorized(r),t(r)):(e.cacheId(n),e.params.WebIdentityToken=n.Token,e.webIdentityCredentials.refresh(function(r){r||(e.data=e.webIdentityCredentials.data,e.sts.credentialsFrom(e.data,e)),t(r)}))})},loadCachedId:function(){var t=this;if(n.util.isBrowser()&&!t.params.IdentityId){var e=t.getStorage("id");if(e&&t.params.Logins){var r=Object.keys(t.params.Logins),i=(t.getStorage("providers")||"").split(","),o=i.filter(function(t){return-1!==r.indexOf(t)});0!==o.length&&(t.params.IdentityId=e)}else e&&(t.params.IdentityId=e)}},createClients:function(){this.webIdentityCredentials=this.webIdentityCredentials||new n.WebIdentityCredentials(this.params),this.cognito=this.cognito||new n.CognitoIdentity({params:this.params}),this.sts=this.sts||new n.STS},cacheId:function(t){this.identityId=t.IdentityId,this.params.IdentityId=this.identityId,n.util.isBrowser()&&(this.setStorage("id",t.IdentityId),this.params.Logins&&this.setStorage("providers",Object.keys(this.params.Logins).join(",")))},getStorage:function(t){return this.storage[this.localStorageKey[t]+this.params.IdentityPoolId+(this.params.LoginId||"")]},setStorage:function(t,e){try{this.storage[this.localStorageKey[t]+this.params.IdentityPoolId+(this.params.LoginId||"")]=e}catch(r){}},storage:function(){try{return n.util.isBrowser()&&null!==window.localStorage&&"object"==typeof window.localStorage?window.localStorage:{}}catch(t){return{}}}()})},{"../core":24}],23:[function(t,e,r){var n=t("./core");t("./credentials"),t("./credentials/credential_provider_chain"),n.Config=n.util.inherit({constructor:function(t){void 0===t&&(t={}),t=this.extractCredentials(t),n.util.each.call(this,this.keys,function(e,r){this.set(e,t[e],r)})},getCredentials:function(t){function e(e){t(e,e?null:s.credentials)}function r(t,e){return new n.util.error(e||new Error,{code:"CredentialsError",message:t})}function i(){s.credentials.get(function(t){if(t){var n="Could not load credentials from "+s.credentials.constructor.name;t=r(n,t)}e(t)})}function o(){var t=null;s.credentials.accessKeyId&&s.credentials.secretAccessKey||(t=r("Missing credentials")),e(t)}var s=this;s.credentials?"function"==typeof s.credentials.get?i():o():s.credentialProvider?s.credentialProvider.resolve(function(t,n){t&&(t=r("Could not load credentials from any providers",t)),s.credentials=n,e(t)}):e(r("No credentials to load"))},update:function(t,e){e=e||!1,t=this.extractCredentials(t),n.util.each.call(this,t,function(t,r){(e||Object.prototype.hasOwnProperty.call(this.keys,t)||n.Service.hasService(t))&&this.set(t,r)})},loadFromPath:function(t){this.clear();var e=JSON.parse(n.util.readFileSync(t)),r=new n.FileSystemCredentials(t),i=new n.CredentialProviderChain;return i.providers.unshift(r),i.resolve(function(t,r){if(t)throw t;e.credentials=r}),this.constructor(e),this},clear:function(){n.util.each.call(this,this.keys,function(t){delete this[t]}),this.set("credentials",void 0),this.set("credentialProvider",void 0)},set:function(t,e,r){void 0===e?(void 0===r&&(r=this.keys[t]),"function"==typeof r?this[t]=r.call(this):this[t]=r):"httpOptions"===t&&this[t]?this[t]=n.util.merge(this[t],e):this[t]=e},keys:{credentials:null,credentialProvider:null,region:null,logger:null,apiVersions:{},apiVersion:null,endpoint:void 0,httpOptions:{timeout:12e4},maxRetries:void 0,maxRedirects:10,paramValidation:!0,sslEnabled:!0,s3ForcePathStyle:!1,s3BucketEndpoint:!1,s3DisableBodySigning:!0,computeChecksums:!0,convertResponseTypes:!0,correctClockSkew:!1,customUserAgent:null,dynamoDbCrc32:!0,systemClockOffset:0,signatureVersion:null,signatureCache:!0,retryDelayOptions:{base:100},useAccelerateEndpoint:!1},extractCredentials:function(t){return t.accessKeyId&&t.secretAccessKey&&(t=n.util.copy(t),t.credentials=new n.Credentials(t)),t},setPromisesDependency:function(t){n.util.addPromisesToRequests(n.Request,t)}}),n.config=new n.Config},{"./core":24,"./credentials":25,"./credentials/credential_provider_chain":27}],27:[function(t,e,r){var n=t("../core");n.CredentialProviderChain=n.util.inherit(n.Credentials,{constructor:function(t){t?this.providers=t:this.providers=n.CredentialProviderChain.defaultProviders.slice(0)},resolve:function(t){function e(i,o){if(!i&&o||r===n.length)return void t(i,o);var s=n[r++];o="function"==typeof s?s.call():s,o.get?o.get(function(t){e(t,t?null:o)}):e(null,o)}if(0===this.providers.length)return t(new Error("No providers")),this;var r=0,n=this.providers.slice(0);return e(),this}}),n.CredentialProviderChain.defaultProviders=[]},{"../core":24}],25:[function(t,e,r){var n=t("./core");n.Credentials=n.util.inherit({constructor:function(){if(n.util.hideProperties(this,["secretAccessKey"]),this.expired=!1,this.expireTime=null,1===arguments.length&&"object"==typeof arguments[0]){var t=arguments[0].credentials||arguments[0];this.accessKeyId=t.accessKeyId,this.secretAccessKey=t.secretAccessKey,this.sessionToken=t.sessionToken}else this.accessKeyId=arguments[0],this.secretAccessKey=arguments[1],this.sessionToken=arguments[2]},expiryWindow:15,needsRefresh:function(){var t=n.util.date.getDate().getTime(),e=new Date(t+1e3*this.expiryWindow);return this.expireTime&&e>this.expireTime?!0:this.expired||!this.accessKeyId||!this.secretAccessKey},get:function(t){var e=this;this.needsRefresh()?this.refresh(function(r){r||(e.expired=!1),t&&t(r)}):t&&t()},refresh:function(t){this.expired=!1,t()}})},{"./core":24}],20:[function(t,e,r){(function(e,n){function i(t,e){var n={seen:[],stylize:s};return arguments.length>=3&&(n.depth=arguments[2]),arguments.length>=4&&(n.colors=arguments[3]),y(e)?n.showHidden=e:e&&r._extend(n,e),E(n.showHidden)&&(n.showHidden=!1),E(n.depth)&&(n.depth=2),E(n.colors)&&(n.colors=!1),E(n.customInspect)&&(n.customInspect=!0),n.colors&&(n.stylize=o),u(n,t,n.depth)}function o(t,e){var r=i.styles[e];return r?"["+i.colors[r][0]+"m"+t+"["+i.colors[r][1]+"m":t}function s(t,e){return t}function a(t){var e={};return t.forEach(function(t,r){e[t]=!0}),e}function u(t,e,n){if(t.customInspect&&e&&R(e.inspect)&&e.inspect!==r.inspect&&(!e.constructor||e.constructor.prototype!==e)){var i=e.inspect(n,t);return b(i)||(i=u(t,i,n)),i}var o=c(t,e);if(o)return o;var s=Object.keys(e),y=a(s);if(t.showHidden&&(s=Object.getOwnPropertyNames(e)),A(e)&&(s.indexOf("message")>=0||s.indexOf("description")>=0))return l(e);if(0===s.length){if(R(e)){var v=e.name?": "+e.name:"";return t.stylize("[Function"+v+"]","special")}if(_(e))return t.stylize(RegExp.prototype.toString.call(e),"regexp");if(S(e))return t.stylize(Date.prototype.toString.call(e),"date");if(A(e))return l(e)}var g="",m=!1,w=["{","}"];if(d(e)&&(m=!0,w=["[","]"]),R(e)){var E=e.name?": "+e.name:"";g=" [Function"+E+"]"}if(_(e)&&(g=" "+RegExp.prototype.toString.call(e)),S(e)&&(g=" "+Date.prototype.toUTCString.call(e)),A(e)&&(g=" "+l(e)),0===s.length&&(!m||0==e.length))return w[0]+g+w[1];if(0>n)return _(e)?t.stylize(RegExp.prototype.toString.call(e),"regexp"):t.stylize("[Object]","special");t.seen.push(e);var x;return x=m?h(t,e,n,y,s):s.map(function(r){return p(t,e,n,y,r,m)}),t.seen.pop(),f(x,g,w)}function c(t,e){if(E(e))return t.stylize("undefined","undefined");if(b(e)){var r="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(r,"string")}return m(e)?t.stylize(""+e,"number"):y(e)?t.stylize(""+e,"boolean"):v(e)?t.stylize("null","null"):void 0}function l(t){return"["+Error.prototype.toString.call(t)+"]"}function h(t,e,r,n,i){for(var o=[],s=0,a=e.length;a>s;++s)L(e,String(s))?o.push(p(t,e,r,n,String(s),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(p(t,e,r,n,i,!0))}),o}function p(t,e,r,n,i,o){var s,a,c;if(c=Object.getOwnPropertyDescriptor(e,i)||{value:e[i]},c.get?a=c.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):c.set&&(a=t.stylize("[Setter]","special")),L(n,i)||(s="["+i+"]"),a||(t.seen.indexOf(c.value)<0?(a=v(r)?u(t,c.value,null):u(t,c.value,r-1),a.indexOf("\n")>-1&&(a=o?a.split("\n").map(function(t){return"  "+t}).join("\n").substr(2):"\n"+a.split("\n").map(function(t){return"   "+t}).join("\n"))):a=t.stylize("[Circular]","special")),E(s)){if(o&&i.match(/^\d+$/))return a;s=JSON.stringify(""+i),s.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(s=s.substr(1,s.length-2),s=t.stylize(s,"name")):(s=s.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),s=t.stylize(s,"string"))}return s+": "+a}function f(t,e,r){var n=0,i=t.reduce(function(t,e){return n++,e.indexOf("\n")>=0&&n++,t+e.replace(/\u001b\[\d\d?m/g,"").length+1},0);return i>60?r[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+r[1]:r[0]+e+" "+t.join(", ")+" "+r[1]}function d(t){return Array.isArray(t)}function y(t){return"boolean"==typeof t}function v(t){return null===t}function g(t){return null==t}function m(t){return"number"==typeof t}function b(t){return"string"==typeof t}function w(t){return"symbol"==typeof t}function E(t){return void 0===t}function _(t){return x(t)&&"[object RegExp]"===I(t)}function x(t){return"object"==typeof t&&null!==t}function S(t){return x(t)&&"[object Date]"===I(t)}function A(t){return x(t)&&("[object Error]"===I(t)||t instanceof Error)}function R(t){return"function"==typeof t}function T(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||"undefined"==typeof t}function I(t){return Object.prototype.toString.call(t)}function C(t){return 10>t?"0"+t.toString(10):t.toString(10)}function j(){var t=new Date,e=[C(t.getHours()),C(t.getMinutes()),C(t.getSeconds())].join(":");return[t.getDate(),P[t.getMonth()],e].join(" ")}function L(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var O=/%[sdj%]/g;r.format=function(t){if(!b(t)){for(var e=[],r=0;r<arguments.length;r++)e.push(i(arguments[r]));return e.join(" ")}for(var r=1,n=arguments,o=n.length,s=String(t).replace(O,function(t){if("%%"===t)return"%";if(r>=o)return t;switch(t){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return t}}),a=n[r];o>r;a=n[++r])s+=v(a)||!x(a)?" "+a:" "+i(a);return s},r.deprecate=function(t,i){function o(){if(!s){if(e.throwDeprecation)throw new Error(i);e.traceDeprecation?console.trace(i):console.error(i),s=!0}return t.apply(this,arguments)}if(E(n.process))return function(){return r.deprecate(t,i).apply(this,arguments)};if(e.noDeprecation===!0)return t;var s=!1;return o};var q,D={};r.debuglog=function(t){if(E(q)&&(q=e.env.NODE_DEBUG||""),t=t.toUpperCase(),!D[t])if(new RegExp("\\b"+t+"\\b","i").test(q)){var n=e.pid;D[t]=function(){var e=r.format.apply(r,arguments);console.error("%s %d: %s",t,n,e)}}else D[t]=function(){};return D[t]},r.inspect=i,i.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},i.styles={special:"cyan",number:"yellow","boolean":"yellow",undefined:"grey","null":"bold",string:"green",date:"magenta",regexp:"red"},r.isArray=d,r.isBoolean=y,r.isNull=v,r.isNullOrUndefined=g,r.isNumber=m,r.isString=b,r.isSymbol=w,r.isUndefined=E,r.isRegExp=_,r.isObject=x,r.isDate=S,r.isError=A,r.isFunction=R,r.isPrimitive=T,r.isBuffer=t("./support/isBuffer");var P=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];r.log=function(){console.log("%s - %s",j(),r.format.apply(r,arguments))},r.inherits=t("inherits"),r._extend=function(t,e){if(!e||!x(e))return t;for(var r=Object.keys(e),n=r.length;n--;)t[r[n]]=e[r[n]];return t}}).call(this,t("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./support/isBuffer":19,_process:13,inherits:12}],19:[function(t,e,r){e.exports=function(t){return t&&"object"==typeof t&&"function"==typeof t.copy&&"function"==typeof t.fill&&"function"==typeof t.readUInt8}},{}],18:[function(t,e,r){function n(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function i(t,e,r){if(t&&c(t)&&t instanceof n)return t;var i=new n;return i.parse(t,e,r),i}function o(t){return u(t)&&(t=i(t)),t instanceof n?t.format():n.prototype.format.call(t)}function s(t,e){return i(t,!1,!0).resolve(e)}function a(t,e){return t?i(t,!1,!0).resolveObject(e):e}function u(t){return"string"==typeof t}function c(t){return"object"==typeof t&&null!==t}function l(t){return null===t}function h(t){return null==t}var p=t("punycode");r.parse=i,r.resolve=s,r.resolveObject=a,r.format=o,r.Url=n;var f=/^([a-z0-9.+-]+:)/i,d=/:[0-9]*$/,y=["<",">",'"',"`"," ","\r","\n","	"],v=["{","}","|","\\","^","`"].concat(y),g=["'"].concat(v),m=["%","/","?",";","#"].concat(g),b=["/","?","#"],w=255,E=/^[a-z0-9A-Z_-]{0,63}$/,_=/^([a-z0-9A-Z_-]{0,63})(.*)$/,x={javascript:!0,"javascript:":!0},S={javascript:!0,"javascript:":!0},A={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},R=t("querystring");n.prototype.parse=function(t,e,r){if(!u(t))throw new TypeError("Parameter 'url' must be a string, not "+typeof t);var n=t;n=n.trim();var i=f.exec(n);if(i){i=i[0];var o=i.toLowerCase();this.protocol=o,n=n.substr(i.length)}if(r||i||n.match(/^\/\/[^@\/]+@[^@\/]+/)){var s="//"===n.substr(0,2);!s||i&&S[i]||(n=n.substr(2),this.slashes=!0)}if(!S[i]&&(s||i&&!A[i])){for(var a=-1,c=0;c<b.length;c++){var l=n.indexOf(b[c]);-1!==l&&(-1===a||a>l)&&(a=l)}var h,d;d=-1===a?n.lastIndexOf("@"):n.lastIndexOf("@",a),-1!==d&&(h=n.slice(0,d),n=n.slice(d+1),this.auth=decodeURIComponent(h)),a=-1;for(var c=0;c<m.length;c++){var l=n.indexOf(m[c]);-1!==l&&(-1===a||a>l)&&(a=l)}-1===a&&(a=n.length),this.host=n.slice(0,a),n=n.slice(a),this.parseHost(),this.hostname=this.hostname||"";var y="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!y)for(var v=this.hostname.split(/\./),c=0,T=v.length;T>c;c++){var I=v[c];if(I&&!I.match(E)){for(var C="",j=0,L=I.length;L>j;j++)C+=I.charCodeAt(j)>127?"x":I[j];if(!C.match(E)){var O=v.slice(0,c),q=v.slice(c+1),D=I.match(_);D&&(O.push(D[1]),q.unshift(D[2])),q.length&&(n="/"+q.join(".")+n),this.hostname=O.join(".");break}}}if(this.hostname.length>w?this.hostname="":this.hostname=this.hostname.toLowerCase(),!y){for(var P=this.hostname.split("."),k=[],c=0;c<P.length;++c){var N=P[c];k.push(N.match(/[^A-Za-z0-9_-]/)?"xn--"+p.encode(N):N)}this.hostname=k.join(".")}var M=this.port?":"+this.port:"",U=this.hostname||"";this.host=U+M,this.href+=this.host,y&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==n[0]&&(n="/"+n))}if(!x[o])for(var c=0,T=g.length;T>c;c++){var B=g[c],F=encodeURIComponent(B);
F===B&&(F=escape(B)),n=n.split(B).join(F)}var z=n.indexOf("#");-1!==z&&(this.hash=n.substr(z),n=n.slice(0,z));var H=n.indexOf("?");if(-1!==H?(this.search=n.substr(H),this.query=n.substr(H+1),e&&(this.query=R.parse(this.query)),n=n.slice(0,H)):e&&(this.search="",this.query={}),n&&(this.pathname=n),A[o]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var M=this.pathname||"",N=this.search||"";this.path=M+N}return this.href=this.format(),this},n.prototype.format=function(){var t=this.auth||"";t&&(t=encodeURIComponent(t),t=t.replace(/%3A/i,":"),t+="@");var e=this.protocol||"",r=this.pathname||"",n=this.hash||"",i=!1,o="";this.host?i=t+this.host:this.hostname&&(i=t+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(i+=":"+this.port)),this.query&&c(this.query)&&Object.keys(this.query).length&&(o=R.stringify(this.query));var s=this.search||o&&"?"+o||"";return e&&":"!==e.substr(-1)&&(e+=":"),this.slashes||(!e||A[e])&&i!==!1?(i="//"+(i||""),r&&"/"!==r.charAt(0)&&(r="/"+r)):i||(i=""),n&&"#"!==n.charAt(0)&&(n="#"+n),s&&"?"!==s.charAt(0)&&(s="?"+s),r=r.replace(/[?#]/g,function(t){return encodeURIComponent(t)}),s=s.replace("#","%23"),e+i+r+s+n},n.prototype.resolve=function(t){return this.resolveObject(i(t,!1,!0)).format()},n.prototype.resolveObject=function(t){if(u(t)){var e=new n;e.parse(t,!1,!0),t=e}var r=new n;if(Object.keys(this).forEach(function(t){r[t]=this[t]},this),r.hash=t.hash,""===t.href)return r.href=r.format(),r;if(t.slashes&&!t.protocol)return Object.keys(t).forEach(function(e){"protocol"!==e&&(r[e]=t[e])}),A[r.protocol]&&r.hostname&&!r.pathname&&(r.path=r.pathname="/"),r.href=r.format(),r;if(t.protocol&&t.protocol!==r.protocol){if(!A[t.protocol])return Object.keys(t).forEach(function(e){r[e]=t[e]}),r.href=r.format(),r;if(r.protocol=t.protocol,t.host||S[t.protocol])r.pathname=t.pathname;else{for(var i=(t.pathname||"").split("/");i.length&&!(t.host=i.shift()););t.host||(t.host=""),t.hostname||(t.hostname=""),""!==i[0]&&i.unshift(""),i.length<2&&i.unshift(""),r.pathname=i.join("/")}if(r.search=t.search,r.query=t.query,r.host=t.host||"",r.auth=t.auth,r.hostname=t.hostname||t.host,r.port=t.port,r.pathname||r.search){var o=r.pathname||"",s=r.search||"";r.path=o+s}return r.slashes=r.slashes||t.slashes,r.href=r.format(),r}var a=r.pathname&&"/"===r.pathname.charAt(0),c=t.host||t.pathname&&"/"===t.pathname.charAt(0),p=c||a||r.host&&t.pathname,f=p,d=r.pathname&&r.pathname.split("/")||[],i=t.pathname&&t.pathname.split("/")||[],y=r.protocol&&!A[r.protocol];if(y&&(r.hostname="",r.port=null,r.host&&(""===d[0]?d[0]=r.host:d.unshift(r.host)),r.host="",t.protocol&&(t.hostname=null,t.port=null,t.host&&(""===i[0]?i[0]=t.host:i.unshift(t.host)),t.host=null),p=p&&(""===i[0]||""===d[0])),c)r.host=t.host||""===t.host?t.host:r.host,r.hostname=t.hostname||""===t.hostname?t.hostname:r.hostname,r.search=t.search,r.query=t.query,d=i;else if(i.length)d||(d=[]),d.pop(),d=d.concat(i),r.search=t.search,r.query=t.query;else if(!h(t.search)){if(y){r.hostname=r.host=d.shift();var v=r.host&&r.host.indexOf("@")>0?r.host.split("@"):!1;v&&(r.auth=v.shift(),r.host=r.hostname=v.shift())}return r.search=t.search,r.query=t.query,l(r.pathname)&&l(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.href=r.format(),r}if(!d.length)return r.pathname=null,r.search?r.path="/"+r.search:r.path=null,r.href=r.format(),r;for(var g=d.slice(-1)[0],m=(r.host||t.host)&&("."===g||".."===g)||""===g,b=0,w=d.length;w>=0;w--)g=d[w],"."==g?d.splice(w,1):".."===g?(d.splice(w,1),b++):b&&(d.splice(w,1),b--);if(!p&&!f)for(;b--;b)d.unshift("..");!p||""===d[0]||d[0]&&"/"===d[0].charAt(0)||d.unshift(""),m&&"/"!==d.join("/").substr(-1)&&d.push("");var E=""===d[0]||d[0]&&"/"===d[0].charAt(0);if(y){r.hostname=r.host=E?"":d.length?d.shift():"";var v=r.host&&r.host.indexOf("@")>0?r.host.split("@"):!1;v&&(r.auth=v.shift(),r.host=r.hostname=v.shift())}return p=p||r.host&&d.length,p&&!E&&d.unshift(""),d.length?r.pathname=d.join("/"):(r.pathname=null,r.path=null),l(r.pathname)&&l(r.search)||(r.path=(r.pathname?r.pathname:"")+(r.search?r.search:"")),r.auth=t.auth||r.auth,r.slashes=r.slashes||t.slashes,r.href=r.format(),r},n.prototype.parseHost=function(){var t=this.host,e=d.exec(t);e&&(e=e[0],":"!==e&&(this.port=e.substr(1)),t=t.substr(0,t.length-e.length)),t&&(this.hostname=t)}},{punycode:14,querystring:17}],17:[function(t,e,r){"use strict";r.decode=r.parse=t("./decode"),r.encode=r.stringify=t("./encode")},{"./decode":15,"./encode":16}],16:[function(t,e,r){"use strict";function n(t,e){if(t.map)return t.map(e);for(var r=[],n=0;n<t.length;n++)r.push(e(t[n],n));return r}var i=function(t){switch(typeof t){case"string":return t;case"boolean":return t?"true":"false";case"number":return isFinite(t)?t:"";default:return""}};e.exports=function(t,e,r,a){return e=e||"&",r=r||"=",null===t&&(t=void 0),"object"==typeof t?n(s(t),function(s){var a=encodeURIComponent(i(s))+r;return o(t[s])?n(t[s],function(t){return a+encodeURIComponent(i(t))}).join(e):a+encodeURIComponent(i(t[s]))}).join(e):a?encodeURIComponent(i(a))+r+encodeURIComponent(i(t)):""};var o=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},s=Object.keys||function(t){var e=[];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.push(r);return e}},{}],15:[function(t,e,r){"use strict";function n(t,e){return Object.prototype.hasOwnProperty.call(t,e)}e.exports=function(t,e,r,o){e=e||"&",r=r||"=";var s={};if("string"!=typeof t||0===t.length)return s;var a=/\+/g;t=t.split(e);var u=1e3;o&&"number"==typeof o.maxKeys&&(u=o.maxKeys);var c=t.length;u>0&&c>u&&(c=u);for(var l=0;c>l;++l){var h,p,f,d,y=t[l].replace(a,"%20"),v=y.indexOf(r);v>=0?(h=y.substr(0,v),p=y.substr(v+1)):(h=y,p=""),f=decodeURIComponent(h),d=decodeURIComponent(p),n(s,f)?i(s[f])?s[f].push(d):s[f]=[s[f],d]:s[f]=d}return s};var i=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)}},{}],14:[function(t,e,r){(function(t){!function(n){function i(t){throw RangeError(q[t])}function o(t,e){for(var r=t.length;r--;)t[r]=e(t[r]);return t}function s(t,e){return o(t.split(O),e).join(".")}function a(t){for(var e,r,n=[],i=0,o=t.length;o>i;)e=t.charCodeAt(i++),e>=55296&&56319>=e&&o>i?(r=t.charCodeAt(i++),56320==(64512&r)?n.push(((1023&e)<<10)+(1023&r)+65536):(n.push(e),i--)):n.push(e);return n}function u(t){return o(t,function(t){var e="";return t>65535&&(t-=65536,e+=k(t>>>10&1023|55296),t=56320|1023&t),e+=k(t)}).join("")}function c(t){return 10>t-48?t-22:26>t-65?t-65:26>t-97?t-97:_}function l(t,e){return t+22+75*(26>t)-((0!=e)<<5)}function h(t,e,r){var n=0;for(t=r?P(t/R):t>>1,t+=P(t/e);t>D*S>>1;n+=_)t=P(t/D);return P(n+(D+1)*t/(t+A))}function p(t){var e,r,n,o,s,a,l,p,f,d,y=[],v=t.length,g=0,m=I,b=T;for(r=t.lastIndexOf(C),0>r&&(r=0),n=0;r>n;++n)t.charCodeAt(n)>=128&&i("not-basic"),y.push(t.charCodeAt(n));for(o=r>0?r+1:0;v>o;){for(s=g,a=1,l=_;o>=v&&i("invalid-input"),p=c(t.charCodeAt(o++)),(p>=_||p>P((E-g)/a))&&i("overflow"),g+=p*a,f=b>=l?x:l>=b+S?S:l-b,!(f>p);l+=_)d=_-f,a>P(E/d)&&i("overflow"),a*=d;e=y.length+1,b=h(g-s,e,0==s),P(g/e)>E-m&&i("overflow"),m+=P(g/e),g%=e,y.splice(g++,0,m)}return u(y)}function f(t){var e,r,n,o,s,u,c,p,f,d,y,v,g,m,b,w=[];for(t=a(t),v=t.length,e=I,r=0,s=T,u=0;v>u;++u)y=t[u],128>y&&w.push(k(y));for(n=o=w.length,o&&w.push(C);v>n;){for(c=E,u=0;v>u;++u)y=t[u],y>=e&&c>y&&(c=y);for(g=n+1,c-e>P((E-r)/g)&&i("overflow"),r+=(c-e)*g,e=c,u=0;v>u;++u)if(y=t[u],e>y&&++r>E&&i("overflow"),y==e){for(p=r,f=_;d=s>=f?x:f>=s+S?S:f-s,!(d>p);f+=_)b=p-d,m=_-d,w.push(k(l(d+b%m,0))),p=P(b/m);w.push(k(l(p,0))),s=h(r,g,n==o),r=0,++n}++r,++e}return w.join("")}function d(t){return s(t,function(t){return j.test(t)?p(t.slice(4).toLowerCase()):t})}function y(t){return s(t,function(t){return L.test(t)?"xn--"+f(t):t})}var v="object"==typeof r&&r,g="object"==typeof e&&e&&e.exports==v&&e,m="object"==typeof t&&t;(m.global===m||m.window===m)&&(n=m);var b,w,E=2147483647,_=36,x=1,S=26,A=38,R=700,T=72,I=128,C="-",j=/^xn--/,L=/[^ -~]/,O=/\x2E|\u3002|\uFF0E|\uFF61/g,q={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},D=_-x,P=Math.floor,k=String.fromCharCode;if(b={version:"1.2.4",ucs2:{decode:a,encode:u},decode:p,encode:f,toASCII:y,toUnicode:d},"function"=="function"&&"object"==typeof __webpack_require__(165)&&__webpack_require__(165))!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return b}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if(v&&!v.nodeType)if(g)g.exports=b;else for(w in b)b.hasOwnProperty(w)&&(v[w]=b[w]);else n.punycode=b}(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],13:[function(t,e,r){function n(){if(!a){a=!0;for(var t,e=s.length;e;){t=s,s=[];for(var r=-1;++r<e;)t[r]();e=s.length}a=!1}}function i(){}var o=e.exports={},s=[],a=!1;o.nextTick=function(t){s.push(t),a||setTimeout(n,0)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=i,o.addListener=i,o.once=i,o.off=i,o.removeListener=i,o.removeAllListeners=i,o.emit=i,o.binding=function(t){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(t){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},{}],12:[function(t,e,r){"function"==typeof Object.create?e.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:e.exports=function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},{}],6:[function(t,e,r){function n(t,e,r){a.isBuffer(e)||(e=new a(e)),a.isBuffer(r)||(r=new a(r)),e.length>f?e=t(e):e.length<f&&(e=a.concat([e,d],f));for(var n=new a(f),i=new a(f),o=0;f>o;o++)n[o]=54^e[o],i[o]=92^e[o];var s=t(a.concat([n,r]));return t(a.concat([i,s]))}function i(t,e){t=t||"sha1";var r=p[t],i=[],s=0;return r||o("algorithm:",t,"is not yet supported"),{update:function(t){return a.isBuffer(t)||(t=new a(t)),i.push(t),s+=t.length,this},digest:function(t){var o=a.concat(i),s=e?n(r,e,o):r(o);return i=null,t?s.toString(t):s}}}function o(){var t=[].slice.call(arguments).join(" ");throw new Error([t,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}function s(t,e){for(var r in t)e(t[r],r)}var a=t("buffer").Buffer,u=t("./sha"),c=t("./sha256"),l=t("./rng"),h=t("./md5"),p={sha1:u,sha256:c,md5:h},f=64,d=new a(f);d.fill(0),r.createHash=function(t){return i(t)},r.createHmac=function(t,e){return i(t,e)},r.randomBytes=function(t,e){if(!e||!e.call)return new a(l(t));try{e.call(this,void 0,new a(l(t)))}catch(r){e(r)}},s(["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],function(t){r[t]=function(){o("sorry,",t,"is not implemented yet")}})},{"./md5":7,"./rng":8,"./sha":9,"./sha256":10,buffer:1}],10:[function(t,e,r){var n=t("./helpers"),i=function(t,e){var r=(65535&t)+(65535&e),n=(t>>16)+(e>>16)+(r>>16);return n<<16|65535&r},o=function(t,e){return t>>>e|t<<32-e},s=function(t,e){return t>>>e},a=function(t,e,r){return t&e^~t&r},u=function(t,e,r){return t&e^t&r^e&r},c=function(t){return o(t,2)^o(t,13)^o(t,22)},l=function(t){return o(t,6)^o(t,11)^o(t,25)},h=function(t){return o(t,7)^o(t,18)^s(t,3)},p=function(t){return o(t,17)^o(t,19)^s(t,10)},f=function(t,e){var r,n,o,s,f,d,y,v,g,m,b,w,E=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),_=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),x=new Array(64);t[e>>5]|=128<<24-e%32,t[(e+64>>9<<4)+15]=e;for(var g=0;g<t.length;g+=16){r=_[0],n=_[1],o=_[2],s=_[3],f=_[4],d=_[5],y=_[6],v=_[7];for(var m=0;64>m;m++)16>m?x[m]=t[m+g]:x[m]=i(i(i(p(x[m-2]),x[m-7]),h(x[m-15])),x[m-16]),b=i(i(i(i(v,l(f)),a(f,d,y)),E[m]),x[m]),w=i(c(r),u(r,n,o)),v=y,y=d,d=f,f=i(s,b),s=o,o=n,n=r,r=i(b,w);_[0]=i(r,_[0]),_[1]=i(n,_[1]),_[2]=i(o,_[2]),_[3]=i(s,_[3]),_[4]=i(f,_[4]),_[5]=i(d,_[5]),_[6]=i(y,_[6]),_[7]=i(v,_[7])}return _};e.exports=function(t){return n.hash(t,f,32,!0)}},{"./helpers":5}],9:[function(t,e,r){function n(t,e){t[e>>5]|=128<<24-e%32,t[(e+64>>9<<4)+15]=e;for(var r=Array(80),n=1732584193,u=-271733879,c=-1732584194,l=271733878,h=-1009589776,p=0;p<t.length;p+=16){for(var f=n,d=u,y=c,v=l,g=h,m=0;80>m;m++){16>m?r[m]=t[p+m]:r[m]=a(r[m-3]^r[m-8]^r[m-14]^r[m-16],1);var b=s(s(a(n,5),i(m,u,c,l)),s(s(h,r[m]),o(m)));h=l,l=c,c=a(u,30),u=n,n=b}n=s(n,f),u=s(u,d),c=s(c,y),l=s(l,v),h=s(h,g)}return Array(n,u,c,l,h)}function i(t,e,r,n){return 20>t?e&r|~e&n:40>t?e^r^n:60>t?e&r|e&n|r&n:e^r^n}function o(t){return 20>t?1518500249:40>t?1859775393:60>t?-1894007588:-899497514}function s(t,e){var r=(65535&t)+(65535&e),n=(t>>16)+(e>>16)+(r>>16);return n<<16|65535&r}function a(t,e){return t<<e|t>>>32-e}var u=t("./helpers");e.exports=function(t){return u.hash(t,n,20,!0)}},{"./helpers":5}],8:[function(t,e,r){!function(){var t,r,n=this;t=function(t){for(var e,e,r=new Array(t),n=0;t>n;n++)0==(3&n)&&(e=4294967296*Math.random()),r[n]=e>>>((3&n)<<3)&255;return r},n.crypto&&crypto.getRandomValues&&(r=function(t){var e=new Uint8Array(t);return crypto.getRandomValues(e),e}),e.exports=r||t}()},{}],7:[function(t,e,r){function n(t,e){t[e>>5]|=128<<e%32,t[(e+64>>>9<<4)+14]=e;for(var r=1732584193,n=-271733879,i=-1732584194,l=271733878,h=0;h<t.length;h+=16){var p=r,f=n,d=i,y=l;r=o(r,n,i,l,t[h+0],7,-680876936),l=o(l,r,n,i,t[h+1],12,-389564586),i=o(i,l,r,n,t[h+2],17,606105819),n=o(n,i,l,r,t[h+3],22,-1044525330),r=o(r,n,i,l,t[h+4],7,-176418897),l=o(l,r,n,i,t[h+5],12,1200080426),i=o(i,l,r,n,t[h+6],17,-1473231341),n=o(n,i,l,r,t[h+7],22,-45705983),r=o(r,n,i,l,t[h+8],7,1770035416),l=o(l,r,n,i,t[h+9],12,-1958414417),i=o(i,l,r,n,t[h+10],17,-42063),n=o(n,i,l,r,t[h+11],22,-1990404162),r=o(r,n,i,l,t[h+12],7,1804603682),l=o(l,r,n,i,t[h+13],12,-40341101),i=o(i,l,r,n,t[h+14],17,-1502002290),n=o(n,i,l,r,t[h+15],22,1236535329),r=s(r,n,i,l,t[h+1],5,-165796510),l=s(l,r,n,i,t[h+6],9,-1069501632),i=s(i,l,r,n,t[h+11],14,643717713),n=s(n,i,l,r,t[h+0],20,-373897302),r=s(r,n,i,l,t[h+5],5,-701558691),l=s(l,r,n,i,t[h+10],9,38016083),i=s(i,l,r,n,t[h+15],14,-660478335),n=s(n,i,l,r,t[h+4],20,-405537848),r=s(r,n,i,l,t[h+9],5,568446438),l=s(l,r,n,i,t[h+14],9,-1019803690),i=s(i,l,r,n,t[h+3],14,-187363961),n=s(n,i,l,r,t[h+8],20,1163531501),r=s(r,n,i,l,t[h+13],5,-1444681467),l=s(l,r,n,i,t[h+2],9,-51403784),i=s(i,l,r,n,t[h+7],14,1735328473),n=s(n,i,l,r,t[h+12],20,-1926607734),r=a(r,n,i,l,t[h+5],4,-378558),l=a(l,r,n,i,t[h+8],11,-2022574463),i=a(i,l,r,n,t[h+11],16,1839030562),n=a(n,i,l,r,t[h+14],23,-35309556),r=a(r,n,i,l,t[h+1],4,-1530992060),l=a(l,r,n,i,t[h+4],11,1272893353),i=a(i,l,r,n,t[h+7],16,-155497632),n=a(n,i,l,r,t[h+10],23,-1094730640),r=a(r,n,i,l,t[h+13],4,681279174),l=a(l,r,n,i,t[h+0],11,-358537222),i=a(i,l,r,n,t[h+3],16,-722521979),n=a(n,i,l,r,t[h+6],23,76029189),r=a(r,n,i,l,t[h+9],4,-640364487),l=a(l,r,n,i,t[h+12],11,-421815835),i=a(i,l,r,n,t[h+15],16,530742520),n=a(n,i,l,r,t[h+2],23,-995338651),r=u(r,n,i,l,t[h+0],6,-198630844),l=u(l,r,n,i,t[h+7],10,1126891415),i=u(i,l,r,n,t[h+14],15,-1416354905),n=u(n,i,l,r,t[h+5],21,-57434055),r=u(r,n,i,l,t[h+12],6,1700485571),l=u(l,r,n,i,t[h+3],10,-1894986606),i=u(i,l,r,n,t[h+10],15,-1051523),n=u(n,i,l,r,t[h+1],21,-2054922799),r=u(r,n,i,l,t[h+8],6,1873313359),l=u(l,r,n,i,t[h+15],10,-30611744),i=u(i,l,r,n,t[h+6],15,-1560198380),n=u(n,i,l,r,t[h+13],21,1309151649),r=u(r,n,i,l,t[h+4],6,-145523070),l=u(l,r,n,i,t[h+11],10,-1120210379),i=u(i,l,r,n,t[h+2],15,718787259),n=u(n,i,l,r,t[h+9],21,-343485551),r=c(r,p),n=c(n,f),i=c(i,d),l=c(l,y)}return Array(r,n,i,l)}function i(t,e,r,n,i,o){return c(l(c(c(e,t),c(n,o)),i),r)}function o(t,e,r,n,o,s,a){return i(e&r|~e&n,t,e,o,s,a)}function s(t,e,r,n,o,s,a){return i(e&n|r&~n,t,e,o,s,a)}function a(t,e,r,n,o,s,a){return i(e^r^n,t,e,o,s,a)}function u(t,e,r,n,o,s,a){return i(r^(e|~n),t,e,o,s,a)}function c(t,e){var r=(65535&t)+(65535&e),n=(t>>16)+(e>>16)+(r>>16);return n<<16|65535&r}function l(t,e){return t<<e|t>>>32-e}var h=t("./helpers");e.exports=function(t){return h.hash(t,n,16)}},{"./helpers":5}],5:[function(t,e,r){function n(t,e){if(t.length%a!==0){var r=t.length+(a-t.length%a);t=s.concat([t,u],r)}for(var n=[],i=e?t.readInt32BE:t.readInt32LE,o=0;o<t.length;o+=a)n.push(i.call(t,o));return n}function i(t,e,r){for(var n=new s(e),i=r?n.writeInt32BE:n.writeInt32LE,o=0;o<t.length;o++)i.call(n,t[o],4*o,!0);return n}function o(t,e,r,o){s.isBuffer(t)||(t=new s(t));var a=e(n(t,o),t.length*c);return i(a,r,o)}var s=t("buffer").Buffer,a=4,u=new s(a);u.fill(0);var c=8;e.exports={hash:o}},{buffer:1}],1:[function(t,e,r){function n(){return i.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function i(t){return this instanceof i?(this.length=0,this.parent=void 0,"number"==typeof t?o(this,t):"string"==typeof t?s(this,t,arguments.length>1?arguments[1]:"utf8"):a(this,t)):arguments.length>1?new i(t,arguments[1]):new i(t)}function o(t,e){if(t=f(t,0>e?0:0|d(e)),!i.TYPED_ARRAY_SUPPORT)for(var r=0;e>r;r++)t[r]=0;return t}function s(t,e,r){("string"!=typeof r||""===r)&&(r="utf8");var n=0|v(e,r);return t=f(t,n),t.write(e,r),t}function a(t,e){if(i.isBuffer(e))return u(t,e);if(Y(e))return c(t,e);if(null==e)throw new TypeError("must start with number, buffer, array or string");return"undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer?l(t,e):e.length?h(t,e):p(t,e)}function u(t,e){var r=0|d(e.length);return t=f(t,r),e.copy(t,0,0,r),t}function c(t,e){var r=0|d(e.length);t=f(t,r);for(var n=0;r>n;n+=1)t[n]=255&e[n];return t}function l(t,e){var r=0|d(e.length);t=f(t,r);for(var n=0;r>n;n+=1)t[n]=255&e[n];return t}function h(t,e){var r=0|d(e.length);t=f(t,r);for(var n=0;r>n;n+=1)t[n]=255&e[n];return t}function p(t,e){var r,n=0;"Buffer"===e.type&&Y(e.data)&&(r=e.data,n=0|d(r.length)),t=f(t,n);for(var i=0;n>i;i+=1)t[i]=255&r[i];return t}function f(t,e){i.TYPED_ARRAY_SUPPORT?t=i._augment(new Uint8Array(e)):(t.length=e,t._isBuffer=!0);var r=0!==e&&e<=i.poolSize>>>1;return r&&(t.parent=J),t}function d(t){if(t>=n())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+n().toString(16)+" bytes");return 0|t}function y(t,e){if(!(this instanceof y))return new y(t,e);var r=new i(t,e);return delete r.parent,r}function v(t,e){"string"!=typeof t&&(t=""+t);var r=t.length;if(0===r)return 0;for(var n=!1;;)switch(e){case"ascii":case"binary":case"raw":case"raws":return r;case"utf8":case"utf-8":return B(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return H(t).length;default:if(n)return B(t).length;e=(""+e).toLowerCase(),n=!0}}function g(t,e,r){var n=!1;if(e=0|e,r=void 0===r||r===1/0?this.length:0|r,t||(t="utf8"),0>e&&(e=0),r>this.length&&(r=this.length),e>=r)return"";for(;;)switch(t){case"hex":return I(this,e,r);case"utf8":case"utf-8":return A(this,e,r);case"ascii":return R(this,e,r);case"binary":return T(this,e,r);case"base64":return S(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return C(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function m(t,e,r,n){r=Number(r)||0;var i=t.length-r;n?(n=Number(n),n>i&&(n=i)):n=i;var o=e.length;if(o%2!==0)throw new Error("Invalid hex string");n>o/2&&(n=o/2);for(var s=0;n>s;s++){var a=parseInt(e.substr(2*s,2),16);if(isNaN(a))throw new Error("Invalid hex string");t[r+s]=a}return s}function b(t,e,r,n){return X(B(e,t.length-r),t,r,n)}function w(t,e,r,n){return X(F(e),t,r,n)}function E(t,e,r,n){return w(t,e,r,n)}function _(t,e,r,n){return X(H(e),t,r,n)}function x(t,e,r,n){return X(z(e,t.length-r),t,r,n)}function S(t,e,r){return 0===e&&r===t.length?K.fromByteArray(t):K.fromByteArray(t.slice(e,r))}function A(t,e,r){var n="",i="";r=Math.min(t.length,r);for(var o=e;r>o;o++)t[o]<=127?(n+=V(i)+String.fromCharCode(t[o]),i=""):i+="%"+t[o].toString(16);return n+V(i)}function R(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;r>i;i++)n+=String.fromCharCode(127&t[i]);return n}function T(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;r>i;i++)n+=String.fromCharCode(t[i]);return n}function I(t,e,r){var n=t.length;(!e||0>e)&&(e=0),(!r||0>r||r>n)&&(r=n);for(var i="",o=e;r>o;o++)i+=U(t[o]);return i}function C(t,e,r){for(var n=t.slice(e,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function j(t,e,r){if(t%1!==0||0>t)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function L(t,e,r,n,o,s){if(!i.isBuffer(t))throw new TypeError("buffer must be a Buffer instance");if(e>o||s>e)throw new RangeError("value is out of bounds");if(r+n>t.length)throw new RangeError("index out of range")}function O(t,e,r,n){0>e&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-r,2);o>i;i++)t[r+i]=(e&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function q(t,e,r,n){0>e&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-r,4);o>i;i++)t[r+i]=e>>>8*(n?i:3-i)&255}function D(t,e,r,n,i,o){if(e>i||o>e)throw new RangeError("value is out of bounds");if(r+n>t.length)throw new RangeError("index out of range");if(0>r)throw new RangeError("index out of range")}function P(t,e,r,n,i){return i||D(t,e,r,4,3.4028234663852886e38,-3.4028234663852886e38),W.write(t,e,r,n,23,4),r+4}function k(t,e,r,n,i){return i||D(t,e,r,8,1.7976931348623157e308,-1.7976931348623157e308),W.write(t,e,r,n,52,8),r+8}function N(t){if(t=M(t).replace($,""),t.length<2)return"";for(;t.length%4!==0;)t+="=";return t}function M(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function U(t){return 16>t?"0"+t.toString(16):t.toString(16)}function B(t,e){e=e||1/0;for(var r,n=t.length,i=null,o=[],s=0;n>s;s++){if(r=t.charCodeAt(s),r>55295&&57344>r){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(56320>r){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=i-55296<<10|r-56320|65536,i=null}else i&&((e-=3)>-1&&o.push(239,191,189),i=null);if(128>r){if((e-=1)<0)break;o.push(r)}else if(2048>r){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(65536>r){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(2097152>r))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function F(t){for(var e=[],r=0;r<t.length;r++)e.push(255&t.charCodeAt(r));return e}function z(t,e){for(var r,n,i,o=[],s=0;s<t.length&&!((e-=2)<0);s++)r=t.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}function H(t){return K.toByteArray(N(t))}function X(t,e,r,n){for(var i=0;n>i&&!(i+r>=e.length||i>=t.length);i++)e[i+r]=t[i];return i}function V(t){try{return decodeURIComponent(t)}catch(e){return String.fromCharCode(65533)}}var K=t("base64-js"),W=t("ieee754"),Y=t("is-array");r.Buffer=i,r.SlowBuffer=y,r.INSPECT_MAX_BYTES=50,i.poolSize=8192;var J={};i.TYPED_ARRAY_SUPPORT=function(){try{var t=new ArrayBuffer(0),e=new Uint8Array(t);return e.foo=function(){return 42},42===e.foo()&&"function"==typeof e.subarray&&0===new Uint8Array(1).subarray(1,1).byteLength}catch(r){return!1}}(),i.isBuffer=function(t){return!(null==t||!t._isBuffer)},i.compare=function(t,e){if(!i.isBuffer(t)||!i.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var r=t.length,n=e.length,o=0,s=Math.min(r,n);s>o&&t[o]===e[o];)++o;return o!==s&&(r=t[o],n=e[o]),n>r?-1:r>n?1:0},i.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},i.concat=function(t,e){if(!Y(t))throw new TypeError("list argument must be an Array of Buffers.");if(0===t.length)return new i(0);if(1===t.length)return t[0];var r;if(void 0===e)for(e=0,r=0;r<t.length;r++)e+=t[r].length;var n=new i(e),o=0;for(r=0;r<t.length;r++){var s=t[r];s.copy(n,o),o+=s.length}return n},i.byteLength=v,i.prototype.length=void 0,i.prototype.parent=void 0,i.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?A(this,0,t):g.apply(this,arguments)},i.prototype.equals=function(t){if(!i.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t?!0:0===i.compare(this,t)},i.prototype.inspect=function(){var t="",e=r.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,e).match(/.{2}/g).join(" "),this.length>e&&(t+=" ... ")),"<Buffer "+t+">"},i.prototype.compare=function(t){if(!i.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t?0:i.compare(this,t)},i.prototype.indexOf=function(t,e){function r(t,e,r){for(var n=-1,i=0;r+i<t.length;i++)if(t[r+i]===e[-1===n?0:i-n]){if(-1===n&&(n=i),i-n+1===e.length)return r+n}else n=-1;return-1}if(e>2147483647?e=2147483647:-2147483648>e&&(e=-2147483648),e>>=0,0===this.length)return-1;if(e>=this.length)return-1;if(0>e&&(e=Math.max(this.length+e,0)),"string"==typeof t)return 0===t.length?-1:String.prototype.indexOf.call(this,t,e);if(i.isBuffer(t))return r(this,t,e);if("number"==typeof t)return i.TYPED_ARRAY_SUPPORT&&"function"===Uint8Array.prototype.indexOf?Uint8Array.prototype.indexOf.call(this,t,e):r(this,[t],e);throw new TypeError("val must be string, number or Buffer")},i.prototype.get=function(t){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(t)},i.prototype.set=function(t,e){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(t,e)},i.prototype.write=function(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)n=e,r=this.length,e=0;else if(isFinite(e))e=0|e,isFinite(r)?(r=0|r,void 0===n&&(n="utf8")):(n=r,r=void 0);else{var i=n;n=e,e=0|r,r=i}var o=this.length-e;if((void 0===r||r>o)&&(r=o),t.length>0&&(0>r||0>e)||e>this.length)throw new RangeError("attempt to write outside buffer bounds");n||(n="utf8");for(var s=!1;;)switch(n){case"hex":return m(this,t,e,r);case"utf8":case"utf-8":return b(this,t,e,r);case"ascii":return w(this,t,e,r);case"binary":return E(this,t,e,r);case"base64":return _(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,t,e,r);default:if(s)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),s=!0}},i.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},i.prototype.slice=function(t,e){var r=this.length;t=~~t,e=void 0===e?r:~~e,0>t?(t+=r,0>t&&(t=0)):t>r&&(t=r),0>e?(e+=r,0>e&&(e=0)):e>r&&(e=r),t>e&&(e=t);var n;if(i.TYPED_ARRAY_SUPPORT)n=i._augment(this.subarray(t,e));else{var o=e-t;n=new i(o,void 0);for(var s=0;o>s;s++)n[s]=this[s+t]}return n.length&&(n.parent=this.parent||this),n},i.prototype.readUIntLE=function(t,e,r){t=0|t,e=0|e,r||j(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return n},i.prototype.readUIntBE=function(t,e,r){t=0|t,e=0|e,r||j(t,e,this.length);for(var n=this[t+--e],i=1;e>0&&(i*=256);)n+=this[t+--e]*i;return n},i.prototype.readUInt8=function(t,e){return e||j(t,1,this.length),this[t]},i.prototype.readUInt16LE=function(t,e){return e||j(t,2,this.length),this[t]|this[t+1]<<8},i.prototype.readUInt16BE=function(t,e){return e||j(t,2,this.length),this[t]<<8|this[t+1]},i.prototype.readUInt32LE=function(t,e){return e||j(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},i.prototype.readUInt32BE=function(t,e){return e||j(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},i.prototype.readIntLE=function(t,e,r){t=0|t,e=0|e,r||j(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*e)),n},i.prototype.readIntBE=function(t,e,r){t=0|t,e=0|e,r||j(t,e,this.length);for(var n=e,i=1,o=this[t+--n];n>0&&(i*=256);)o+=this[t+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*e)),o},i.prototype.readInt8=function(t,e){return e||j(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},i.prototype.readInt16LE=function(t,e){e||j(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},i.prototype.readInt16BE=function(t,e){e||j(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},i.prototype.readInt32LE=function(t,e){return e||j(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},i.prototype.readInt32BE=function(t,e){return e||j(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},i.prototype.readFloatLE=function(t,e){return e||j(t,4,this.length),W.read(this,t,!0,23,4)},i.prototype.readFloatBE=function(t,e){return e||j(t,4,this.length),W.read(this,t,!1,23,4)},i.prototype.readDoubleLE=function(t,e){return e||j(t,8,this.length),W.read(this,t,!0,52,8)},i.prototype.readDoubleBE=function(t,e){return e||j(t,8,this.length),W.read(this,t,!1,52,8)},i.prototype.writeUIntLE=function(t,e,r,n){t=+t,e=0|e,r=0|r,n||L(this,t,e,r,Math.pow(2,8*r),0);var i=1,o=0;for(this[e]=255&t;++o<r&&(i*=256);)this[e+o]=t/i&255;return e+r},i.prototype.writeUIntBE=function(t,e,r,n){t=+t,e=0|e,r=0|r,n||L(this,t,e,r,Math.pow(2,8*r),0);var i=r-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+r},i.prototype.writeUInt8=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,1,255,0),i.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=t,e+1},i.prototype.writeUInt16LE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,2,65535,0),i.TYPED_ARRAY_SUPPORT?(this[e]=t,this[e+1]=t>>>8):O(this,t,e,!0),e+2},i.prototype.writeUInt16BE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,2,65535,0),i.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=t):O(this,t,e,!1),e+2},i.prototype.writeUInt32LE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,4,4294967295,0),i.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=t):q(this,t,e,!0),e+4},i.prototype.writeUInt32BE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,4,4294967295,0),i.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=t):q(this,t,e,!1),e+4},i.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e=0|e,!n){var i=Math.pow(2,8*r-1);L(this,t,e,r,i-1,-i)}var o=0,s=1,a=0>t?1:0;for(this[e]=255&t;++o<r&&(s*=256);)this[e+o]=(t/s>>0)-a&255;return e+r},i.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e=0|e,!n){var i=Math.pow(2,8*r-1);L(this,t,e,r,i-1,-i)}var o=r-1,s=1,a=0>t?1:0;for(this[e+o]=255&t;--o>=0&&(s*=256);)this[e+o]=(t/s>>0)-a&255;return e+r},i.prototype.writeInt8=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,1,127,-128),i.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),0>t&&(t=255+t+1),this[e]=t,e+1},i.prototype.writeInt16LE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,2,32767,-32768),i.TYPED_ARRAY_SUPPORT?(this[e]=t,this[e+1]=t>>>8):O(this,t,e,!0),e+2},i.prototype.writeInt16BE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,2,32767,-32768),i.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=t):O(this,t,e,!1),e+2},i.prototype.writeInt32LE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,4,2147483647,-2147483648),i.TYPED_ARRAY_SUPPORT?(this[e]=t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):q(this,t,e,!0),e+4},i.prototype.writeInt32BE=function(t,e,r){return t=+t,e=0|e,r||L(this,t,e,4,2147483647,-2147483648),0>t&&(t=4294967295+t+1),i.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=t):q(this,t,e,!1),e+4},i.prototype.writeFloatLE=function(t,e,r){return P(this,t,e,!0,r)},i.prototype.writeFloatBE=function(t,e,r){return P(this,t,e,!1,r);
},i.prototype.writeDoubleLE=function(t,e,r){return k(this,t,e,!0,r)},i.prototype.writeDoubleBE=function(t,e,r){return k(this,t,e,!1,r)},i.prototype.copy=function(t,e,r,n){if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&r>n&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(0>e)throw new RangeError("targetStart out of bounds");if(0>r||r>=this.length)throw new RangeError("sourceStart out of bounds");if(0>n)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);var o=n-r;if(1e3>o||!i.TYPED_ARRAY_SUPPORT)for(var s=0;o>s;s++)t[s+e]=this[s+r];else t._set(this.subarray(r,r+o),e);return o},i.prototype.fill=function(t,e,r){if(t||(t=0),e||(e=0),r||(r=this.length),e>r)throw new RangeError("end < start");if(r!==e&&0!==this.length){if(0>e||e>=this.length)throw new RangeError("start out of bounds");if(0>r||r>this.length)throw new RangeError("end out of bounds");var n;if("number"==typeof t)for(n=e;r>n;n++)this[n]=t;else{var i=B(t.toString()),o=i.length;for(n=e;r>n;n++)this[n]=i[n%o]}return this}},i.prototype.toArrayBuffer=function(){if("undefined"!=typeof Uint8Array){if(i.TYPED_ARRAY_SUPPORT)return new i(this).buffer;for(var t=new Uint8Array(this.length),e=0,r=t.length;r>e;e+=1)t[e]=this[e];return t.buffer}throw new TypeError("Buffer.toArrayBuffer not supported in this browser")};var G=i.prototype;i._augment=function(t){return t.constructor=i,t._isBuffer=!0,t._set=t.set,t.get=G.get,t.set=G.set,t.write=G.write,t.toString=G.toString,t.toLocaleString=G.toString,t.toJSON=G.toJSON,t.equals=G.equals,t.compare=G.compare,t.indexOf=G.indexOf,t.copy=G.copy,t.slice=G.slice,t.readUIntLE=G.readUIntLE,t.readUIntBE=G.readUIntBE,t.readUInt8=G.readUInt8,t.readUInt16LE=G.readUInt16LE,t.readUInt16BE=G.readUInt16BE,t.readUInt32LE=G.readUInt32LE,t.readUInt32BE=G.readUInt32BE,t.readIntLE=G.readIntLE,t.readIntBE=G.readIntBE,t.readInt8=G.readInt8,t.readInt16LE=G.readInt16LE,t.readInt16BE=G.readInt16BE,t.readInt32LE=G.readInt32LE,t.readInt32BE=G.readInt32BE,t.readFloatLE=G.readFloatLE,t.readFloatBE=G.readFloatBE,t.readDoubleLE=G.readDoubleLE,t.readDoubleBE=G.readDoubleBE,t.writeUInt8=G.writeUInt8,t.writeUIntLE=G.writeUIntLE,t.writeUIntBE=G.writeUIntBE,t.writeUInt16LE=G.writeUInt16LE,t.writeUInt16BE=G.writeUInt16BE,t.writeUInt32LE=G.writeUInt32LE,t.writeUInt32BE=G.writeUInt32BE,t.writeIntLE=G.writeIntLE,t.writeIntBE=G.writeIntBE,t.writeInt8=G.writeInt8,t.writeInt16LE=G.writeInt16LE,t.writeInt16BE=G.writeInt16BE,t.writeInt32LE=G.writeInt32LE,t.writeInt32BE=G.writeInt32BE,t.writeFloatLE=G.writeFloatLE,t.writeFloatBE=G.writeFloatBE,t.writeDoubleLE=G.writeDoubleLE,t.writeDoubleBE=G.writeDoubleBE,t.fill=G.fill,t.inspect=G.inspect,t.toArrayBuffer=G.toArrayBuffer,t};var $=/[^+\/0-9A-z\-]/g},{"base64-js":2,ieee754:3,"is-array":4}],4:[function(t,e,r){var n=Array.isArray,i=Object.prototype.toString;e.exports=n||function(t){return!!t&&"[object Array]"==i.call(t)}},{}],3:[function(t,e,r){r.read=function(t,e,r,n,i){var o,s,a=8*i-n-1,u=(1<<a)-1,c=u>>1,l=-7,h=r?i-1:0,p=r?-1:1,f=t[e+h];for(h+=p,o=f&(1<<-l)-1,f>>=-l,l+=a;l>0;o=256*o+t[e+h],h+=p,l-=8);for(s=o&(1<<-l)-1,o>>=-l,l+=n;l>0;s=256*s+t[e+h],h+=p,l-=8);if(0===o)o=1-c;else{if(o===u)return s?NaN:(f?-1:1)*(1/0);s+=Math.pow(2,n),o-=c}return(f?-1:1)*s*Math.pow(2,o-n)},r.write=function(t,e,r,n,i,o){var s,a,u,c=8*o-i-1,l=(1<<c)-1,h=l>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,f=n?0:o-1,d=n?1:-1,y=0>e||0===e&&0>1/e?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=l):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),e+=s+h>=1?p/u:p*Math.pow(2,1-h),e*u>=2&&(s++,u/=2),s+h>=l?(a=0,s=l):s+h>=1?(a=(e*u-1)*Math.pow(2,i),s+=h):(a=e*Math.pow(2,h-1)*Math.pow(2,i),s=0));i>=8;t[r+f]=255&a,f+=d,a/=256,i-=8);for(s=s<<i|a,c+=i;c>0;t[r+f]=255&s,f+=d,s/=256,c-=8);t[r+f-d]|=128*y}},{}],2:[function(t,e,r){var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";!function(t){"use strict";function e(t){var e=t.charCodeAt(0);return e===s||e===h?62:e===a||e===p?63:u>e?-1:u+10>e?e-u+26+26:l+26>e?e-l:c+26>e?e-c+26:void 0}function r(t){function r(t){c[h++]=t}var n,i,s,a,u,c;if(t.length%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var l=t.length;u="="===t.charAt(l-2)?2:"="===t.charAt(l-1)?1:0,c=new o(3*t.length/4-u),s=u>0?t.length-4:t.length;var h=0;for(n=0,i=0;s>n;n+=4,i+=3)a=e(t.charAt(n))<<18|e(t.charAt(n+1))<<12|e(t.charAt(n+2))<<6|e(t.charAt(n+3)),r((16711680&a)>>16),r((65280&a)>>8),r(255&a);return 2===u?(a=e(t.charAt(n))<<2|e(t.charAt(n+1))>>4,r(255&a)):1===u&&(a=e(t.charAt(n))<<10|e(t.charAt(n+1))<<4|e(t.charAt(n+2))>>2,r(a>>8&255),r(255&a)),c}function i(t){function e(t){return n.charAt(t)}function r(t){return e(t>>18&63)+e(t>>12&63)+e(t>>6&63)+e(63&t)}var i,o,s,a=t.length%3,u="";for(i=0,s=t.length-a;s>i;i+=3)o=(t[i]<<16)+(t[i+1]<<8)+t[i+2],u+=r(o);switch(a){case 1:o=t[t.length-1],u+=e(o>>2),u+=e(o<<4&63),u+="==";break;case 2:o=(t[t.length-2]<<8)+t[t.length-1],u+=e(o>>10),u+=e(o>>4&63),u+=e(o<<2&63),u+="="}return u}var o="undefined"!=typeof Uint8Array?Uint8Array:Array,s="+".charCodeAt(0),a="/".charCodeAt(0),u="0".charCodeAt(0),c="a".charCodeAt(0),l="A".charCodeAt(0),h="-".charCodeAt(0),p="_".charCodeAt(0);t.toByteArray=r,t.fromByteArray=i}("undefined"==typeof r?this.base64js={}:r)},{}]},{},[]),_xamzrequire=function e(t,r,n){function i(s,a){if(!r[s]){if(!t[s]){var u="function"==typeof _xamzrequire&&_xamzrequire;if(!a&&u)return u(s,!0);if(o)return o(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var l=r[s]={exports:{}};t[s][0].call(l.exports,function(e){var r=t[s][1][e];return i(r?r:e)},l,l.exports,e,t,r,n)}return r[s].exports}for(var o="function"==typeof _xamzrequire&&_xamzrequire,s=0;s<n.length;s++)i(n[s]);return i}({21:[function(t,e,r){var n=t("./core");n.apiLoader=function(t,e){return n.apiLoader.services[t][e]},n.apiLoader.services={},n.XML.Parser=t("./xml/browser_parser"),t("./http/xhr"),"undefined"!=typeof window&&(window.AWS=n),"undefined"!=typeof e&&(e.exports=n),"undefined"!=typeof self&&(self.AWS=n)},{"./core":24,"./http/xhr":38,"./xml/browser_parser":85}],85:[function(t,e,r){function n(){}function i(t,e){switch(e||(e={}),e.type){case"structure":return o(t,e);case"map":return s(t,e);case"list":return a(t,e);case void 0:case null:return c(t);default:return u(t,e)}}function o(t,e){var r={};return null===t?r:(l.each(e.members,function(e,n){if(n.isXmlAttribute){if(Object.prototype.hasOwnProperty.call(t.attributes,n.name)){var o=t.attributes[n.name].value;r[e]=i({textContent:o},n)}}else{var s=n.flattened?t:t.getElementsByTagName(n.name)[0];s?r[e]=i(s,n):n.flattened||"list"!==n.type||(r[e]=n.defaultValue)}}),r)}function s(t,e){for(var r={},n=e.key.name||"key",o=e.value.name||"value",s=e.flattened?e.name:"entry",a=t.firstElementChild;a;){if(a.nodeName===s){var u=a.getElementsByTagName(n)[0].textContent,c=a.getElementsByTagName(o)[0];r[u]=i(c,e.value)}a=a.nextElementSibling}return r}function a(t,e){for(var r=[],n=e.flattened?e.name:e.member.name||"member",o=t.firstElementChild;o;)o.nodeName===n&&r.push(i(o,e.member)),o=o.nextElementSibling;return r}function u(t,e){if(t.getAttribute){var r=t.getAttribute("encoding");"base64"===r&&(e=new h.create({type:r}))}var n=t.textContent;return""===n&&(n=null),"function"==typeof e.toType?e.toType(n):n}function c(t){if(void 0===t||null===t)return"";if(!t.firstElementChild)return null===t.parentNode.parentNode?{}:0===t.childNodes.length?"":t.textContent;for(var e={type:"structure",members:{}},r=t.firstElementChild;r;){var n=r.nodeName;Object.prototype.hasOwnProperty.call(e.members,n)?e.members[n].type="list":e.members[n]={name:n},r=r.nextElementSibling}return o(t,e)}var l=t("../util"),h=t("../model/shape");n.prototype.parse=function(t,e){if(""===t.replace(/^\s+/,""))return{};var r,n;try{if(window.DOMParser){try{var o=new DOMParser;r=o.parseFromString(t,"text/xml")}catch(s){throw l.error(new Error("Parse error in document"),{originalError:s,code:"XMLParserError",retryable:!0})}if(null===r.documentElement)throw l.error(new Error("Cannot parse empty document."),{code:"XMLParserError",retryable:!0});var a=r.getElementsByTagName("parsererror")[0];if(a&&(a.parentNode===r||"body"===a.parentNode.nodeName||a.parentNode.parentNode===r||"body"===a.parentNode.parentNode.nodeName)){var u=a.getElementsByTagName("div")[0]||a;throw l.error(new Error(u.textContent||"Parser error in document"),{code:"XMLParserError",retryable:!0})}}else{if(!window.ActiveXObject)throw new Error("Cannot load XML parser");if(r=new window.ActiveXObject("Microsoft.XMLDOM"),r.async=!1,!r.loadXML(t))throw l.error(new Error("Parse error in document"),{code:"XMLParserError",retryable:!0})}}catch(c){n=c}if(r&&r.documentElement&&!n){var h=i(r.documentElement,e),p=r.getElementsByTagName("ResponseMetadata")[0];return p&&(h.ResponseMetadata=i(p,{})),h}if(n)throw l.error(n||new Error,{code:"XMLParserError",retryable:!0});return{}},e.exports=n},{"../model/shape":46,"../util":84}],38:[function(t,e,r){var n=t("../core"),i=t("events").EventEmitter;t("../http"),n.XHRClient=n.util.inherit({handleRequest:function(t,e,r,o){var s=this,a=t.endpoint,u=new i,c=a.protocol+"//"+a.hostname;80!==a.port&&443!==a.port&&(c+=":"+a.port),c+=t.path;var l=new XMLHttpRequest,h=!1;t.stream=l,l.addEventListener("readystatechange",function(){try{if(0===l.status)return}catch(t){return}if(this.readyState>=this.HEADERS_RECEIVED&&!h){try{l.responseType="arraybuffer"}catch(t){}u.statusCode=l.status,u.headers=s.parseHeaders(l.getAllResponseHeaders()),u.emit("headers",u.statusCode,u.headers),h=!0}this.readyState===this.DONE&&s.finishRequest(l,u)},!1),l.upload.addEventListener("progress",function(t){u.emit("sendProgress",t)}),l.addEventListener("progress",function(t){u.emit("receiveProgress",t)},!1),l.addEventListener("timeout",function(){o(n.util.error(new Error("Timeout"),{code:"TimeoutError"}))},!1),l.addEventListener("error",function(){o(n.util.error(new Error("Network Failure"),{code:"NetworkingError"}))},!1),r(u),l.open(t.method,c,e.xhrAsync!==!1),n.util.each(t.headers,function(t,e){"Content-Length"!==t&&"User-Agent"!==t&&"Host"!==t&&l.setRequestHeader(t,e)}),e.timeout&&e.xhrAsync!==!1&&(l.timeout=e.timeout),e.xhrWithCredentials&&(l.withCredentials=!0);try{l.send(t.body)}catch(p){if(!t.body||"object"!=typeof t.body.buffer)throw p;l.send(t.body.buffer)}return u},parseHeaders:function(t){var e={};return n.util.arrayEach(t.split(/\r?\n/),function(t){var r=t.split(":",1)[0],n=t.substring(r.length+2);r.length>0&&(e[r.toLowerCase()]=n)}),e},finishRequest:function(t,e){var r;if("arraybuffer"===t.responseType&&t.response){var i=t.response;r=new n.util.Buffer(i.byteLength);for(var o=new Uint8Array(i),s=0;s<r.length;++s)r[s]=o[s]}try{r||"string"!=typeof t.responseText||(r=new n.util.Buffer(t.responseText))}catch(a){}r&&e.emit("data",r),e.emit("end")}}),n.HttpClient.prototype=n.XHRClient.prototype,n.HttpClient.streamsApiVersion=1},{"../core":24,"../http":37,events:11}],11:[function(t,e,r){function n(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(t){return"function"==typeof t}function o(t){return"number"==typeof t}function s(t){return"object"==typeof t&&null!==t}function a(t){return void 0===t}e.exports=n,n.EventEmitter=n,n.prototype._events=void 0,n.prototype._maxListeners=void 0,n.defaultMaxListeners=10,n.prototype.setMaxListeners=function(t){if(!o(t)||0>t||isNaN(t))throw TypeError("n must be a positive number");return this._maxListeners=t,this},n.prototype.emit=function(t){var e,r,n,o,u,c;if(this._events||(this._events={}),"error"===t&&(!this._events.error||s(this._events.error)&&!this._events.error.length)){if(e=arguments[1],e instanceof Error)throw e;throw TypeError('Uncaught, unspecified "error" event.')}if(r=this._events[t],a(r))return!1;if(i(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:for(n=arguments.length,o=new Array(n-1),u=1;n>u;u++)o[u-1]=arguments[u];r.apply(this,o)}else if(s(r)){for(n=arguments.length,o=new Array(n-1),u=1;n>u;u++)o[u-1]=arguments[u];for(c=r.slice(),n=c.length,u=0;n>u;u++)c[u].apply(this,o)}return!0},n.prototype.addListener=function(t,e){var r;if(!i(e))throw TypeError("listener must be a function");if(this._events||(this._events={}),this._events.newListener&&this.emit("newListener",t,i(e.listener)?e.listener:e),this._events[t]?s(this._events[t])?this._events[t].push(e):this._events[t]=[this._events[t],e]:this._events[t]=e,s(this._events[t])&&!this._events[t].warned){var r;r=a(this._maxListeners)?n.defaultMaxListeners:this._maxListeners,r&&r>0&&this._events[t].length>r&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),"function"==typeof console.trace&&console.trace())}return this},n.prototype.on=n.prototype.addListener,n.prototype.once=function(t,e){function r(){this.removeListener(t,r),n||(n=!0,e.apply(this,arguments))}if(!i(e))throw TypeError("listener must be a function");var n=!1;return r.listener=e,this.on(t,r),this},n.prototype.removeListener=function(t,e){var r,n,o,a;if(!i(e))throw TypeError("listener must be a function");if(!this._events||!this._events[t])return this;if(r=this._events[t],o=r.length,n=-1,r===e||i(r.listener)&&r.listener===e)delete this._events[t],this._events.removeListener&&this.emit("removeListener",t,e);else if(s(r)){for(a=o;a-->0;)if(r[a]===e||r[a].listener&&r[a].listener===e){n=a;break}if(0>n)return this;1===r.length?(r.length=0,delete this._events[t]):r.splice(n,1),this._events.removeListener&&this.emit("removeListener",t,e)}return this},n.prototype.removeAllListeners=function(t){var e,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[t]&&delete this._events[t],this;if(0===arguments.length){for(e in this._events)"removeListener"!==e&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[t],i(r))this.removeListener(t,r);else for(;r.length;)this.removeListener(t,r[r.length-1]);return delete this._events[t],this},n.prototype.listeners=function(t){var e;return e=this._events&&this._events[t]?i(this._events[t])?[this._events[t]]:this._events[t].slice():[]},n.listenerCount=function(t,e){var r;return r=t._events&&t._events[e]?i(t._events[e])?1:t._events[e].length:0}},{}]},{},[21]);AWS.apiLoader.services.dynamodb={},AWS.DynamoDB=AWS.Service.defineService("dynamodb",["2011-12-05","2012-08-10"]),_xamzrequire=function e(t,r,n){function a(u,o){if(!r[u]){if(!t[u]){var s="function"==typeof _xamzrequire&&_xamzrequire;if(!o&&s)return s(u,!0);if(i)return i(u,!0);var c=new Error("Cannot find module '"+u+"'");throw c.code="MODULE_NOT_FOUND",c}var p=r[u]={exports:{}};t[u][0].call(p.exports,function(e){var r=t[u][1][e];return a(r?r:e)},p,p.exports,e,t,r,n)}return r[u].exports}for(var i="function"==typeof _xamzrequire&&_xamzrequire,u=0;u<n.length;u++)a(n[u]);return a}({66:[function(e,t,r){var n=e("../core");e("../dynamodb/document_client"),n.util.update(n.DynamoDB.prototype,{setupRequestListeners:function(e){e.service.config.dynamoDbCrc32&&(e.removeListener("extractData",n.EventListeners.Json.EXTRACT_DATA),e.addListener("extractData",this.checkCrc32),e.addListener("extractData",n.EventListeners.Json.EXTRACT_DATA))},checkCrc32:function(e){if(!e.httpResponse.streaming&&!e.request.service.crc32IsValid(e))throw e.data=null,e.error=n.util.error(new Error,{code:"CRC32CheckFailed",message:"CRC32 integrity check failed",retryable:!0}),e.request.haltHandlersOnError(),e.error},crc32IsValid:function(e){var t=e.httpResponse.headers["x-amz-crc32"];return t?parseInt(t,10)===n.util.crypto.crc32(e.httpResponse.body):!0},defaultRetryCount:10,retryDelays:function(e){var t=e>0?50*Math.pow(2,e-1):0;return t}})},{"../core":24,"../dynamodb/document_client":32}],32:[function(e,t,r){var n=e("../core"),a=e("./translator"),i=e("./set");n.DynamoDB.DocumentClient=n.util.inherit({operations:{batchGetItem:"batchGet",batchWriteItem:"batchWrite",putItem:"put",getItem:"get",deleteItem:"delete",updateItem:"update",scan:"scan",query:"query"},constructor:function(e){var t=this;t.options=e||{},t.configure(t.options)},configure:function(e){var t=this;t.service=e.service,t.bindServiceObject(e),t.attrValue=t.service.api.operations.putItem.input.members.Item.value.shape},bindServiceObject:function(e){var t=this;if(e=e||{},t.service){var r=n.util.copy(t.service.config);t.service=new t.service.constructor.__super__(r),t.service.config.params=n.util.merge(t.service.config.params||{},e.params)}else t.service=new n.DynamoDB(e)},batchGet:function(e,t){var r=this,n=r.service.batchGetItem(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},batchWrite:function(e,t){var r=this,n=r.service.batchWriteItem(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},"delete":function(e,t){var r=this,n=r.service.deleteItem(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},get:function(e,t){var r=this,n=r.service.getItem(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},put:function(e,t){var r=this,n=r.service.putItem(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},update:function(e,t){var r=this,n=r.service.updateItem(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},scan:function(e,t){var r=this,n=r.service.scan(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},query:function(e,t){var r=this,n=r.service.query(e);return r.setupRequest(n),r.setupResponse(n),"function"==typeof t&&n.send(t),n},createSet:function(e,t){return t=t||{},new i(e,t)},getTranslator:function(){return new a({attrValue:this.attrValue})},setupRequest:function(e){var t=this,r=t.getTranslator(),a=e.operation,i=e.service.api.operations[a].input;e._events.validate.unshift(function(e){e.rawParams=n.util.copy(e.params),e.params=r.translateInput(e.rawParams,i)})},setupResponse:function(e){var t=this,r=t.getTranslator(),a=t.service.api.operations[e.operation].output;e.on("extractData",function(e){e.data=r.translateOutput(e.data,a)});var i=e.response;i.nextPage=function(e){var r,a=this,i=a.request,u=i.service,o=i.operation;try{r=u.paginationConfig(o,!0)}catch(s){a.error=s}if(!a.hasNextPage()){if(e)e(a.error,null);else if(a.error)throw a.error;return null}var c=n.util.copy(i.rawParams);if(a.nextPageTokens){var p=r.inputToken;"string"==typeof p&&(p=[p]);for(var f=0;f<p.length;f++)c[p[f]]=a.nextPageTokens[f];return t[o](c,e)}return e?e(null,null):null}}}),t.exports=n.DynamoDB.DocumentClient},{"../core":24,"./set":33,"./translator":34}],34:[function(e,t,r){var n=e("../core").util,a=e("./converter"),i=function(e){e=e||{},this.attrValue=e.attrValue};i.prototype.translateInput=function(e,t){return this.mode="input",this.translate(e,t)},i.prototype.translateOutput=function(e,t){return this.mode="output",this.translate(e,t)},i.prototype.translate=function(e,t){var r=this;if(!t||void 0===e)return void 0;if(t.shape===r.attrValue)return a[r.mode](e);switch(t.type){case"structure":return r.translateStructure(e,t);case"map":return r.translateMap(e,t);case"list":return r.translateList(e,t);default:return r.translateScalar(e,t)}},i.prototype.translateStructure=function(e,t){var r=this;if(null==e)return void 0;var a={};return n.each(e,function(e,n){var i=t.members[e];if(i){var u=r.translate(n,i);void 0!==u&&(a[e]=u)}}),a},i.prototype.translateList=function(e,t){var r=this;if(null==e)return void 0;var a=[];return n.arrayEach(e,function(e){var n=r.translate(e,t.member);void 0===n?a.push(null):a.push(n)}),a},i.prototype.translateMap=function(e,t){var r=this;if(null==e)return void 0;var a={};return n.each(e,function(e,n){var i=r.translate(n,t.value);void 0===i?a[e]=null:a[e]=i}),a},i.prototype.translateScalar=function(e,t){return t.toType(e)},t.exports=i},{"../core":24,"./converter":31}],31:[function(e,t,r){function n(e){if("Object"===o(e)){var t={M:{}};for(var r in e)t.M[r]=n(e[r]);return t}if("Array"===o(e)){for(var i={L:[]},u=0;u<e.length;u++)i.L.push(n(e[u]));return i}return"Set"===o(e)?a(e):"String"===o(e)?{S:e}:"Number"===o(e)?{N:e.toString()}:"Binary"===o(e)?{B:e}:"Boolean"===o(e)?{BOOL:e}:"null"===o(e)?{NULL:!0}:void 0}function a(e){var t={};switch(e.type){case"String":t.SS=e.values;break;case"Binary":t.BS=e.values;break;case"Number":t.NS=e.values.map(function(e){return e.toString()})}return t}function i(e){var t,r,n;for(var a in e){var o=e[a];if("M"===a){r={};for(var c in o)r[c]=i(o[c]);return r}if("L"===a){for(t=[],n=0;n<o.length;n++)t.push(i(o[n]));return t}if("SS"===a){for(t=[],n=0;n<o.length;n++)t.push(o[n]+"");return new s(t)}if("NS"===a){for(t=[],n=0;n<o.length;n++)t.push(Number(o[n]));return new s(t)}if("BS"===a){for(t=[],n=0;n<o.length;n++)t.push(new u.Buffer(o[n]));return new s(t)}if("S"===a)return o+"";if("N"===a)return Number(o);if("B"===a)return new u.Buffer(o);if("BOOL"===a)return"true"===o||"TRUE"===o||o===!0;if("NULL"===a)return null}}var u=e("../core").util,o=e("./types").typeOf,s=e("./set");t.exports={input:n,output:i}},{"../core":24,"./set":33,"./types":35}],33:[function(e,t,r){var n=e("../core").util,a=e("./types").typeOf,i=n.inherit({constructor:function(e,t){t=t||{},this.initialize(e,t.validate)},initialize:function(e,t){var r=this;r.values=[].concat(e),r.detectType(),t&&r.validate()},detectType:function(){var e=this,t=e.values[0];if("String"===a(t))e.type="String";else if("Number"===a(t))e.type="Number";else{if("Binary"!==a(t))throw n.error(new Error,{code:"InvalidSetType",message:"Sets can contain string, number, or binary values"});e.type="Binary"}},validate:function(){for(var e=this,t=e.values.length,r=e.values,i=0;t>i;i++)if(a(r[i])!==e.type)throw n.error(new Error,{code:"InvalidType",message:e.type+" Set contains "+a(r[i])+" value"})}});t.exports=i},{"../core":24,"./types":35}],35:[function(e,t,r){function n(e){return null===e&&"object"==typeof e?"null":void 0!==e&&a(e)?"Binary":void 0!==e&&e.constructor?i.typeName(e.constructor):"undefined"}function a(e){var t=["Buffer","File","Blob","ArrayBuffer","DataView","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"];if(i.isNode()){var r=i.nodeRequire("stream").Stream;if(i.Buffer.isBuffer(e)||e instanceof r)return!0}else for(var n=0;n<t.length;n++)if(void 0!==e&&e.constructor){if(i.isType(e,t[n]))return!0;if(i.typeName(e.constructor)===t[n])return!0}return!1}var i=e("../core").util;t.exports={typeOf:n,isBinary:a}},{"../core":24}]},{},[66]);AWS.apiLoader.services.dynamodb["2012-08-10"]={version:"2.0",metadata:{apiVersion:"2012-08-10",endpointPrefix:"dynamodb",jsonVersion:"1.0",protocol:"json",serviceAbbreviation:"DynamoDB",serviceFullName:"Amazon DynamoDB",signatureVersion:"v4",targetPrefix:"DynamoDB_20120810"},operations:{BatchGetItem:{input:{type:"structure",required:["RequestItems"],members:{RequestItems:{shape:"S2"},ReturnConsumedCapacity:{}}},output:{type:"structure",members:{Responses:{type:"map",key:{},value:{shape:"Sr"}},UnprocessedKeys:{shape:"S2"},ConsumedCapacity:{shape:"St"}}},http:{}},BatchWriteItem:{input:{type:"structure",required:["RequestItems"],members:{RequestItems:{shape:"S10"},ReturnConsumedCapacity:{},ReturnItemCollectionMetrics:{}}},output:{type:"structure",members:{UnprocessedItems:{shape:"S10"},ItemCollectionMetrics:{type:"map",key:{},value:{type:"list",member:{shape:"S1a"}}},ConsumedCapacity:{shape:"St"}}},http:{}},CreateTable:{input:{type:"structure",required:["AttributeDefinitions","TableName","KeySchema","ProvisionedThroughput"],members:{AttributeDefinitions:{shape:"S1f"},TableName:{},KeySchema:{shape:"S1j"},LocalSecondaryIndexes:{type:"list",member:{type:"structure",required:["IndexName","KeySchema","Projection"],members:{IndexName:{},KeySchema:{shape:"S1j"},Projection:{shape:"S1o"}}}},GlobalSecondaryIndexes:{type:"list",member:{type:"structure",required:["IndexName","KeySchema","Projection","ProvisionedThroughput"],members:{IndexName:{},KeySchema:{shape:"S1j"},Projection:{shape:"S1o"},ProvisionedThroughput:{shape:"S1u"}}}},ProvisionedThroughput:{shape:"S1u"},StreamSpecification:{shape:"S1w"}}},output:{type:"structure",members:{TableDescription:{shape:"S20"}}},http:{}},DeleteItem:{input:{type:"structure",required:["TableName","Key"],members:{TableName:{},Key:{shape:"S6"},Expected:{shape:"S2e"},ConditionalOperator:{},ReturnValues:{},ReturnConsumedCapacity:{},ReturnItemCollectionMetrics:{},ConditionExpression:{},ExpressionAttributeNames:{shape:"Sm"},ExpressionAttributeValues:{shape:"S2m"}}},output:{type:"structure",members:{Attributes:{shape:"Ss"},ConsumedCapacity:{shape:"Su"},ItemCollectionMetrics:{shape:"S1a"}}},http:{}},DeleteTable:{input:{type:"structure",required:["TableName"],members:{TableName:{}}},output:{type:"structure",members:{TableDescription:{shape:"S20"}}},http:{}},DescribeLimits:{input:{type:"structure",members:{}},output:{type:"structure",members:{AccountMaxReadCapacityUnits:{type:"long"},AccountMaxWriteCapacityUnits:{type:"long"},TableMaxReadCapacityUnits:{type:"long"},TableMaxWriteCapacityUnits:{type:"long"}}},http:{}},DescribeTable:{input:{type:"structure",required:["TableName"],members:{TableName:{}}},output:{type:"structure",members:{Table:{shape:"S20"}}},http:{}},GetItem:{input:{type:"structure",required:["TableName","Key"],members:{TableName:{},Key:{shape:"S6"},AttributesToGet:{shape:"Sj"},ConsistentRead:{type:"boolean"},ReturnConsumedCapacity:{},ProjectionExpression:{},ExpressionAttributeNames:{shape:"Sm"}}},output:{type:"structure",members:{Item:{shape:"Ss"},ConsumedCapacity:{shape:"Su"}}},http:{}},ListTables:{input:{type:"structure",members:{ExclusiveStartTableName:{},Limit:{type:"integer"}}},output:{type:"structure",members:{TableNames:{type:"list",member:{}},LastEvaluatedTableName:{}}},http:{}},PutItem:{input:{type:"structure",required:["TableName","Item"],members:{TableName:{},Item:{shape:"S14"},Expected:{shape:"S2e"},ReturnValues:{},ReturnConsumedCapacity:{},ReturnItemCollectionMetrics:{},ConditionalOperator:{},ConditionExpression:{},ExpressionAttributeNames:{shape:"Sm"},ExpressionAttributeValues:{shape:"S2m"}}},output:{type:"structure",members:{Attributes:{shape:"Ss"},ConsumedCapacity:{shape:"Su"},ItemCollectionMetrics:{shape:"S1a"}}},http:{}},Query:{input:{type:"structure",required:["TableName"],members:{TableName:{},IndexName:{},Select:{},AttributesToGet:{shape:"Sj"},Limit:{type:"integer"},ConsistentRead:{type:"boolean"},KeyConditions:{type:"map",key:{},value:{shape:"S37"}},QueryFilter:{shape:"S38"},ConditionalOperator:{},ScanIndexForward:{type:"boolean"},ExclusiveStartKey:{shape:"S6"},ReturnConsumedCapacity:{},ProjectionExpression:{},FilterExpression:{},KeyConditionExpression:{},ExpressionAttributeNames:{shape:"Sm"},ExpressionAttributeValues:{shape:"S2m"}}},output:{type:"structure",members:{Items:{shape:"Sr"},Count:{type:"integer"},ScannedCount:{type:"integer"},LastEvaluatedKey:{shape:"S6"},ConsumedCapacity:{shape:"Su"}}},http:{}},Scan:{input:{type:"structure",required:["TableName"],members:{TableName:{},IndexName:{},AttributesToGet:{shape:"Sj"},Limit:{type:"integer"},Select:{},ScanFilter:{shape:"S38"},ConditionalOperator:{},ExclusiveStartKey:{shape:"S6"},ReturnConsumedCapacity:{},TotalSegments:{type:"integer"},Segment:{type:"integer"},ProjectionExpression:{},FilterExpression:{},ExpressionAttributeNames:{shape:"Sm"},ExpressionAttributeValues:{shape:"S2m"},ConsistentRead:{type:"boolean"}}},output:{type:"structure",members:{Items:{shape:"Sr"},Count:{type:"integer"},ScannedCount:{type:"integer"},LastEvaluatedKey:{shape:"S6"},ConsumedCapacity:{shape:"Su"}}},http:{}},UpdateItem:{input:{type:"structure",required:["TableName","Key"],members:{TableName:{},Key:{shape:"S6"},AttributeUpdates:{type:"map",key:{},value:{type:"structure",members:{Value:{shape:"S8"},Action:{}}}},Expected:{shape:"S2e"},ConditionalOperator:{},ReturnValues:{},ReturnConsumedCapacity:{},ReturnItemCollectionMetrics:{},UpdateExpression:{},ConditionExpression:{},ExpressionAttributeNames:{shape:"Sm"},ExpressionAttributeValues:{shape:"S2m"}}},output:{type:"structure",members:{Attributes:{shape:"Ss"},ConsumedCapacity:{shape:"Su"},ItemCollectionMetrics:{shape:"S1a"}}},http:{}},UpdateTable:{input:{type:"structure",required:["TableName"],members:{AttributeDefinitions:{shape:"S1f"},TableName:{},ProvisionedThroughput:{shape:"S1u"},GlobalSecondaryIndexUpdates:{type:"list",member:{type:"structure",members:{Update:{type:"structure",required:["IndexName","ProvisionedThroughput"],members:{IndexName:{},ProvisionedThroughput:{shape:"S1u"}}},Create:{type:"structure",required:["IndexName","KeySchema","Projection","ProvisionedThroughput"],members:{IndexName:{},KeySchema:{shape:"S1j"},Projection:{shape:"S1o"},ProvisionedThroughput:{shape:"S1u"}}},Delete:{type:"structure",required:["IndexName"],members:{IndexName:{}}}}}},StreamSpecification:{shape:"S1w"}}},output:{type:"structure",members:{TableDescription:{shape:"S20"}}},http:{}}},shapes:{S2:{type:"map",key:{},value:{type:"structure",required:["Keys"],members:{Keys:{type:"list",member:{shape:"S6"}},AttributesToGet:{shape:"Sj"},ConsistentRead:{type:"boolean"},ProjectionExpression:{},ExpressionAttributeNames:{shape:"Sm"}}}},S6:{type:"map",key:{},value:{shape:"S8"}},S8:{type:"structure",members:{S:{},N:{},B:{type:"blob"},SS:{type:"list",member:{}},NS:{type:"list",member:{}},BS:{type:"list",member:{type:"blob"}},M:{type:"map",key:{},value:{shape:"S8"}},L:{type:"list",member:{shape:"S8"}},NULL:{type:"boolean"},BOOL:{type:"boolean"}}},Sj:{type:"list",member:{}},Sm:{type:"map",key:{},value:{}},Sr:{type:"list",member:{shape:"Ss"}},Ss:{type:"map",key:{},value:{shape:"S8"}},St:{type:"list",member:{shape:"Su"}},Su:{type:"structure",members:{TableName:{},CapacityUnits:{type:"double"},Table:{shape:"Sw"},LocalSecondaryIndexes:{shape:"Sx"},GlobalSecondaryIndexes:{shape:"Sx"}}},Sw:{type:"structure",members:{CapacityUnits:{type:"double"}}},Sx:{type:"map",key:{},value:{shape:"Sw"}},S10:{type:"map",key:{},value:{type:"list",member:{type:"structure",members:{PutRequest:{type:"structure",required:["Item"],members:{Item:{shape:"S14"}}},DeleteRequest:{type:"structure",required:["Key"],members:{Key:{shape:"S6"}}}}}}},S14:{type:"map",key:{},value:{shape:"S8"}},S1a:{type:"structure",members:{ItemCollectionKey:{type:"map",key:{},value:{shape:"S8"}},SizeEstimateRangeGB:{type:"list",member:{type:"double"}}}},S1f:{type:"list",member:{type:"structure",required:["AttributeName","AttributeType"],members:{AttributeName:{},AttributeType:{}}}},S1j:{type:"list",member:{type:"structure",required:["AttributeName","KeyType"],members:{AttributeName:{},KeyType:{}}}},S1o:{type:"structure",members:{ProjectionType:{},NonKeyAttributes:{type:"list",member:{}}}},S1u:{type:"structure",required:["ReadCapacityUnits","WriteCapacityUnits"],members:{ReadCapacityUnits:{type:"long"},WriteCapacityUnits:{type:"long"}}},S1w:{type:"structure",members:{StreamEnabled:{type:"boolean"},StreamViewType:{}}},S20:{type:"structure",members:{AttributeDefinitions:{shape:"S1f"},TableName:{},KeySchema:{shape:"S1j"},TableStatus:{},CreationDateTime:{type:"timestamp"},ProvisionedThroughput:{shape:"S23"},TableSizeBytes:{type:"long"},ItemCount:{type:"long"},TableArn:{},LocalSecondaryIndexes:{type:"list",member:{type:"structure",members:{IndexName:{},KeySchema:{shape:"S1j"},Projection:{shape:"S1o"},IndexSizeBytes:{type:"long"},ItemCount:{type:"long"},IndexArn:{}}}},GlobalSecondaryIndexes:{type:"list",member:{type:"structure",members:{IndexName:{},KeySchema:{shape:"S1j"},Projection:{shape:"S1o"},IndexStatus:{},Backfilling:{type:"boolean"},ProvisionedThroughput:{shape:"S23"},IndexSizeBytes:{type:"long"},ItemCount:{type:"long"},IndexArn:{}}}},StreamSpecification:{shape:"S1w"},LatestStreamLabel:{},LatestStreamArn:{}}},S23:{type:"structure",members:{LastIncreaseDateTime:{type:"timestamp"},LastDecreaseDateTime:{type:"timestamp"},NumberOfDecreasesToday:{type:"long"},ReadCapacityUnits:{type:"long"},WriteCapacityUnits:{type:"long"}}},S2e:{type:"map",key:{},value:{type:"structure",members:{Value:{shape:"S8"},Exists:{type:"boolean"},ComparisonOperator:{},AttributeValueList:{shape:"S2i"}}}},S2i:{type:"list",member:{shape:"S8"}},S2m:{type:"map",key:{},value:{shape:"S8"}},S37:{type:"structure",required:["ComparisonOperator"],members:{AttributeValueList:{shape:"S2i"},ComparisonOperator:{}}},S38:{type:"map",key:{},value:{shape:"S37"}}},paginators:{BatchGetItem:{input_token:"RequestItems",output_token:"UnprocessedKeys"},ListTables:{input_token:"ExclusiveStartTableName",output_token:"LastEvaluatedTableName",limit_key:"Limit",result_key:"TableNames"},Query:{input_token:"ExclusiveStartKey",output_token:"LastEvaluatedKey",limit_key:"Limit",result_key:"Items"},Scan:{input_token:"ExclusiveStartKey",output_token:"LastEvaluatedKey",limit_key:"Limit",result_key:"Items"}},waiters:{TableExists:{delay:20,operation:"DescribeTable",maxAttempts:25,acceptors:[{expected:"ACTIVE",matcher:"path",state:"success",argument:"Table.TableStatus"},{expected:"ResourceNotFoundException",matcher:"error",state:"retry"}]},TableNotExists:{delay:20,operation:"DescribeTable",maxAttempts:25,acceptors:[{expected:"ResourceNotFoundException",matcher:"error",state:"success"}]}}};AWS.apiLoader.services.lambda={},AWS.Lambda=AWS.Service.defineService("lambda",["2014-11-11","2015-03-31"]);AWS.apiLoader.services.lambda["2015-03-31"]={version:"2.0",metadata:{apiVersion:"2015-03-31",endpointPrefix:"lambda",protocol:"rest-json",serviceFullName:"AWS Lambda",signatureVersion:"v4"},operations:{AddPermission:{http:{requestUri:"/2015-03-31/functions/{FunctionName}/policy",responseCode:201},input:{type:"structure",required:["FunctionName","StatementId","Action","Principal"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},StatementId:{},Action:{},Principal:{},SourceArn:{},SourceAccount:{},EventSourceToken:{},Qualifier:{location:"querystring",locationName:"Qualifier"}}},output:{type:"structure",members:{Statement:{}}}},CreateAlias:{http:{requestUri:"/2015-03-31/functions/{FunctionName}/aliases",responseCode:201},input:{type:"structure",required:["FunctionName","Name","FunctionVersion"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Name:{},FunctionVersion:{},Description:{}}},output:{shape:"Sg"}},CreateEventSourceMapping:{http:{requestUri:"/2015-03-31/event-source-mappings/",responseCode:202},input:{type:"structure",required:["EventSourceArn","FunctionName","StartingPosition"],members:{EventSourceArn:{},FunctionName:{},Enabled:{type:"boolean"},BatchSize:{type:"integer"},StartingPosition:{}}},output:{shape:"Sm"}},CreateFunction:{http:{requestUri:"/2015-03-31/functions",responseCode:201},input:{type:"structure",required:["FunctionName","Runtime","Role","Handler","Code"],members:{FunctionName:{},Runtime:{},Role:{},Handler:{},Code:{type:"structure",members:{ZipFile:{type:"blob"},S3Bucket:{},S3Key:{},S3ObjectVersion:{}}},Description:{},Timeout:{type:"integer"},MemorySize:{type:"integer"},Publish:{type:"boolean"},VpcConfig:{shape:"S10"}}},output:{shape:"S15"}},DeleteAlias:{http:{method:"DELETE",requestUri:"/2015-03-31/functions/{FunctionName}/aliases/{Name}",responseCode:204},input:{type:"structure",required:["FunctionName","Name"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Name:{location:"uri",locationName:"Name"}}}},DeleteEventSourceMapping:{http:{method:"DELETE",requestUri:"/2015-03-31/event-source-mappings/{UUID}",responseCode:202},input:{type:"structure",required:["UUID"],members:{UUID:{location:"uri",locationName:"UUID"}}},output:{shape:"Sm"}},DeleteFunction:{http:{method:"DELETE",requestUri:"/2015-03-31/functions/{FunctionName}",responseCode:204},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Qualifier:{location:"querystring",locationName:"Qualifier"}}}},GetAlias:{http:{method:"GET",requestUri:"/2015-03-31/functions/{FunctionName}/aliases/{Name}",responseCode:200},input:{type:"structure",required:["FunctionName","Name"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Name:{location:"uri",locationName:"Name"}}},output:{shape:"Sg"}},GetEventSourceMapping:{http:{method:"GET",requestUri:"/2015-03-31/event-source-mappings/{UUID}",responseCode:200},input:{type:"structure",required:["UUID"],members:{UUID:{location:"uri",locationName:"UUID"}}},output:{shape:"Sm"}},GetFunction:{http:{method:"GET",requestUri:"/2015-03-31/functions/{FunctionName}",responseCode:200},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Qualifier:{location:"querystring",locationName:"Qualifier"}}},output:{type:"structure",members:{Configuration:{shape:"S15"},Code:{type:"structure",members:{RepositoryType:{},Location:{}}}}}},GetFunctionConfiguration:{http:{method:"GET",requestUri:"/2015-03-31/functions/{FunctionName}/configuration",responseCode:200},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Qualifier:{location:"querystring",locationName:"Qualifier"}}},output:{shape:"S15"}},GetPolicy:{http:{method:"GET",requestUri:"/2015-03-31/functions/{FunctionName}/policy",responseCode:200},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Qualifier:{location:"querystring",locationName:"Qualifier"}}},output:{type:"structure",members:{Policy:{}}}},Invoke:{http:{requestUri:"/2015-03-31/functions/{FunctionName}/invocations"},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},InvocationType:{location:"header",locationName:"X-Amz-Invocation-Type"},LogType:{location:"header",locationName:"X-Amz-Log-Type"},ClientContext:{location:"header",locationName:"X-Amz-Client-Context"},Payload:{type:"blob"},Qualifier:{location:"querystring",locationName:"Qualifier"}},payload:"Payload"},output:{type:"structure",members:{StatusCode:{location:"statusCode",type:"integer"},FunctionError:{location:"header",locationName:"X-Amz-Function-Error"},LogResult:{location:"header",locationName:"X-Amz-Log-Result"},Payload:{type:"blob"}},payload:"Payload"}},InvokeAsync:{http:{requestUri:"/2014-11-13/functions/{FunctionName}/invoke-async/",responseCode:202},input:{type:"structure",required:["FunctionName","InvokeArgs"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},InvokeArgs:{type:"blob",streaming:!0}},deprecated:!0,payload:"InvokeArgs"},output:{type:"structure",members:{Status:{location:"statusCode",type:"integer"}},deprecated:!0},deprecated:!0},ListAliases:{http:{method:"GET",requestUri:"/2015-03-31/functions/{FunctionName}/aliases",responseCode:200},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},FunctionVersion:{location:"querystring",locationName:"FunctionVersion"},Marker:{location:"querystring",locationName:"Marker"},MaxItems:{location:"querystring",locationName:"MaxItems",type:"integer"}}},output:{type:"structure",members:{NextMarker:{},Aliases:{type:"list",member:{shape:"Sg"}}}}},ListEventSourceMappings:{http:{method:"GET",requestUri:"/2015-03-31/event-source-mappings/",responseCode:200},input:{type:"structure",members:{EventSourceArn:{location:"querystring",locationName:"EventSourceArn"},FunctionName:{location:"querystring",locationName:"FunctionName"},Marker:{location:"querystring",locationName:"Marker"},MaxItems:{location:"querystring",locationName:"MaxItems",type:"integer"}}},output:{type:"structure",members:{NextMarker:{},EventSourceMappings:{type:"list",member:{shape:"Sm"}}}}},ListFunctions:{http:{method:"GET",requestUri:"/2015-03-31/functions/",responseCode:200},input:{type:"structure",members:{Marker:{location:"querystring",locationName:"Marker"},MaxItems:{location:"querystring",locationName:"MaxItems",type:"integer"}}},output:{type:"structure",members:{NextMarker:{},Functions:{shape:"S23"}}}},ListVersionsByFunction:{http:{method:"GET",requestUri:"/2015-03-31/functions/{FunctionName}/versions",responseCode:200},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Marker:{location:"querystring",locationName:"Marker"},MaxItems:{location:"querystring",locationName:"MaxItems",type:"integer"}}},output:{type:"structure",members:{NextMarker:{},Versions:{shape:"S23"}}}},PublishVersion:{http:{requestUri:"/2015-03-31/functions/{FunctionName}/versions",responseCode:201},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},CodeSha256:{},Description:{}}},output:{shape:"S15"}},RemovePermission:{http:{method:"DELETE",requestUri:"/2015-03-31/functions/{FunctionName}/policy/{StatementId}",responseCode:204},input:{type:"structure",required:["FunctionName","StatementId"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},StatementId:{location:"uri",locationName:"StatementId"},Qualifier:{location:"querystring",locationName:"Qualifier"}}}},UpdateAlias:{http:{method:"PUT",requestUri:"/2015-03-31/functions/{FunctionName}/aliases/{Name}",responseCode:200},input:{type:"structure",required:["FunctionName","Name"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Name:{location:"uri",locationName:"Name"},FunctionVersion:{},Description:{}}},output:{shape:"Sg"}},UpdateEventSourceMapping:{http:{method:"PUT",requestUri:"/2015-03-31/event-source-mappings/{UUID}",responseCode:202},input:{type:"structure",required:["UUID"],members:{UUID:{location:"uri",locationName:"UUID"},FunctionName:{},Enabled:{type:"boolean"},BatchSize:{type:"integer"}}},output:{shape:"Sm"}},UpdateFunctionCode:{http:{method:"PUT",requestUri:"/2015-03-31/functions/{FunctionName}/code",responseCode:200},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},ZipFile:{type:"blob"},S3Bucket:{},S3Key:{},S3ObjectVersion:{},Publish:{type:"boolean"}}},output:{shape:"S15"}},UpdateFunctionConfiguration:{http:{method:"PUT",requestUri:"/2015-03-31/functions/{FunctionName}/configuration",responseCode:200},input:{type:"structure",required:["FunctionName"],members:{FunctionName:{location:"uri",locationName:"FunctionName"},Role:{},Handler:{},Description:{},Timeout:{type:"integer"},MemorySize:{type:"integer"},VpcConfig:{shape:"S10"},Runtime:{}}},output:{shape:"S15"}}},shapes:{Sg:{type:"structure",members:{AliasArn:{},Name:{},FunctionVersion:{},Description:{}}},Sm:{type:"structure",members:{UUID:{},BatchSize:{type:"integer"},EventSourceArn:{},FunctionArn:{},LastModified:{type:"timestamp"},LastProcessingResult:{},State:{},StateTransitionReason:{}}},S10:{type:"structure",members:{SubnetIds:{shape:"S11"},SecurityGroupIds:{shape:"S13"}}},S11:{type:"list",member:{}},S13:{type:"list",member:{}},S15:{type:"structure",members:{FunctionName:{},FunctionArn:{},Runtime:{},Role:{},Handler:{},CodeSize:{type:"long"},Description:{},Timeout:{type:"integer"},MemorySize:{type:"integer"},LastModified:{},CodeSha256:{},Version:{},VpcConfig:{type:"structure",members:{SubnetIds:{shape:"S11"},SecurityGroupIds:{shape:"S13"},VpcId:{}}}}},S23:{type:"list",member:{shape:"S15"}}},paginators:{ListEventSourceMappings:{input_token:"Marker",output_token:"NextMarker",limit_key:"MaxItems",result_key:"EventSourceMappings"},ListFunctions:{input_token:"Marker",output_token:"NextMarker",limit_key:"MaxItems",result_key:"Functions"}}};AWS.apiLoader.services.s3={},AWS.S3=AWS.Service.defineService("s3",["2006-03-01"]),_xamzrequire=function e(t,r,n){function i(o,s){if(!r[o]){if(!t[o]){var u="function"==typeof _xamzrequire&&_xamzrequire;if(!s&&u)return u(o,!0);if(a)return a(o,!0);var c=new Error("Cannot find module '"+o+"'");throw c.code="MODULE_NOT_FOUND",c}var l=r[o]={exports:{}};t[o][0].call(l.exports,function(e){var r=t[o][1][e];return i(r?r:e)},l,l.exports,e,t,r,n)}return r[o].exports}for(var a="function"==typeof _xamzrequire&&_xamzrequire,o=0;o<n.length;o++)i(n[o]);return i}({72:[function(e,t,r){var n=e("../core");e("../s3/managed_upload");var i={completeMultipartUpload:!0,copyObject:!0,uploadPartCopy:!0},a=["AuthorizationHeaderMalformed","BadRequest","PermanentRedirect",301];n.util.update(n.S3.prototype,{getSignerClass:function(e){var t=this.api.signatureVersion,r=this._originalConfig?this._originalConfig.signatureVersion:null,i=this.config.signatureVersion,a=e?e.isPresigned():!1;return r?(r="v2"===r?"s3":r,n.Signers.RequestSigner.getVersion(r)):(a!==!0?t="v4":i&&(t=i),n.Signers.RequestSigner.getVersion(t))},validateService:function(){if(this.config.region||(this.config.region="us-east-1"),!this.config.endpoint&&this.config.s3BucketEndpoint){var e="An endpoint must be provided when configuring `s3BucketEndpoint` to true.";throw n.util.error(new Error,{name:"InvalidEndpoint",message:e})}},shouldDisableBodySigning:function(e){var t=this.getSignerClass();return this.config.s3DisableBodySigning===!0&&t===n.Signers.V4&&"https:"===e.httpRequest.endpoint.protocol?!0:!1},setupRequestListeners:function(e){e.addListener("validate",this.validateScheme),e.addListener("validate",this.validateBucketEndpoint),e.addListener("validate",this.correctBucketRegionFromCache),e.addListener("build",this.addContentType),e.addListener("build",this.populateURI),e.addListener("build",this.computeContentMd5),e.addListener("build",this.computeSseCustomerKeyMd5),e.addListener("afterBuild",this.addExpect100Continue),e.removeListener("validate",n.EventListeners.Core.VALIDATE_REGION),e.addListener("extractError",this.extractError),e.onAsync("extractError",this.requestBucketRegion),e.addListener("extractData",this.extractData),e.addListener("extractData",n.util.hoistPayloadMember),e.addListener("beforePresign",this.prepareSignedUrl),n.util.isBrowser()&&e.onAsync("retry",this.reqRegionForNetworkingError),this.shouldDisableBodySigning(e)&&(e.removeListener("afterBuild",n.EventListeners.Core.COMPUTE_SHA256),e.addListener("afterBuild",this.disableBodySigning))},validateScheme:function(e){var t=e.params,r=e.httpRequest.endpoint.protocol,i=t.SSECustomerKey||t.CopySourceSSECustomerKey;if(i&&"https:"!==r){var a="Cannot send SSE keys over HTTP. Set 'sslEnabled'to 'true' in your configuration";throw n.util.error(new Error,{code:"ConfigError",message:a})}},validateBucketEndpoint:function(e){if(!e.params.Bucket&&e.service.config.s3BucketEndpoint){var t="Cannot send requests to root API with `s3BucketEndpoint` set.";throw n.util.error(new Error,{code:"ConfigError",message:t})}},isValidAccelerateOperation:function(e){var t=["createBucket","deleteBucket","listBuckets"];return-1===t.indexOf(e)},populateURI:function(e){var t=e.httpRequest,r=e.params.Bucket,n=e.service,i=t.endpoint;if(r&&!n.pathStyleBucketName(r)){n.config.useAccelerateEndpoint&&n.isValidAccelerateOperation(e.operation)?i.hostname=r+".s3-accelerate.amazonaws.com":n.config.s3BucketEndpoint||(i.hostname=r+"."+i.hostname);var a=i.port;80!==a&&443!==a?i.host=i.hostname+":"+i.port:i.host=i.hostname,t.virtualHostedBucket=r,n.removeVirtualHostedBucketFromPath(e)}},removeVirtualHostedBucketFromPath:function(e){var t=e.httpRequest,r=t.virtualHostedBucket;r&&t.path&&(t.path=t.path.replace(new RegExp("/"+r),""),"/"!==t.path[0]&&(t.path="/"+t.path))},addExpect100Continue:function(e){var t=e.httpRequest.headers["Content-Length"];n.util.isNode()&&t>=1048576&&(e.httpRequest.headers.Expect="100-continue")},addContentType:function(e){var t=e.httpRequest;if("GET"===t.method||"HEAD"===t.method)return void delete t.headers["Content-Type"];t.headers["Content-Type"]||(t.headers["Content-Type"]="application/octet-stream");var r=t.headers["Content-Type"];if(n.util.isBrowser())if("string"!=typeof t.body||r.match(/;\s*charset=/)){var i=function(e,t,r){return t+r.toUpperCase()};t.headers["Content-Type"]=r.replace(/(;\s*charset=)(.+)$/,i)}else{var a="; charset=UTF-8";t.headers["Content-Type"]+=a}},computableChecksumOperations:{putBucketCors:!0,putBucketLifecycle:!0,putBucketLifecycleConfiguration:!0,putBucketTagging:!0,deleteObjects:!0,putBucketReplication:!0},willComputeChecksums:function(e){if(this.computableChecksumOperations[e.operation])return!0;if(!this.config.computeChecksums)return!1;if(!n.util.Buffer.isBuffer(e.httpRequest.body)&&"string"!=typeof e.httpRequest.body)return!1;var t=e.service.api.operations[e.operation].input.members;return e.service.shouldDisableBodySigning(e)&&!Object.prototype.hasOwnProperty.call(e.httpRequest.headers,"presigned-expires")&&t.ContentMD5&&!e.params.ContentMD5?!0:e.service.getSignerClass(e)===n.Signers.V4&&t.ContentMD5&&!t.ContentMD5.required?!1:t.ContentMD5&&!e.params.ContentMD5?!0:void 0},computeContentMd5:function(e){if(e.service.willComputeChecksums(e)){var t=n.util.crypto.md5(e.httpRequest.body,"base64");e.httpRequest.headers["Content-MD5"]=t}},computeSseCustomerKeyMd5:function(e){var t={SSECustomerKey:"x-amz-server-side-encryption-customer-key-MD5",CopySourceSSECustomerKey:"x-amz-copy-source-server-side-encryption-customer-key-MD5"};n.util.each(t,function(t,r){if(e.params[t]){var i=n.util.crypto.md5(e.params[t],"base64");e.httpRequest.headers[r]=i}})},pathStyleBucketName:function(e){return this.config.s3ForcePathStyle?!0:this.config.s3BucketEndpoint?!1:this.dnsCompatibleBucketName(e)?this.config.sslEnabled&&e.match(/\./)?!0:!1:!0},dnsCompatibleBucketName:function(e){var t=e,r=new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/),n=new RegExp(/(\d+\.){3}\d+/),i=new RegExp(/\.\./);return!t.match(r)||t.match(n)||t.match(i)?!1:!0},successfulResponse:function(e){var t=e.request,r=e.httpResponse;return i[t.operation]&&r.body.toString().match("<Error>")?!1:r.statusCode<300},retryableError:function(e,t){if(i[t.operation]&&200===e.statusCode)return!0;if(t._requestRegionForBucket&&t.service.bucketRegionCache[t._requestRegionForBucket])return!1;if(e&&"RequestTimeout"===e.code)return!0;if(e&&-1!=a.indexOf(e.code)&&e.region&&e.region!=t.httpRequest.region)return t.httpRequest.region=e.region,301===e.statusCode&&t.service.updateReqBucketRegion(t),!0;var r=n.Service.prototype.retryableError;return r.call(this,e,t)},updateReqBucketRegion:function(e,t){var r=e.httpRequest;if("string"==typeof t&&t.length&&(r.region=t),r.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)){var i=e.service,a=i.config,o=a.s3BucketEndpoint;o&&delete a.s3BucketEndpoint;var s=n.util.copy(a);delete s.endpoint,s.region=r.region,r.endpoint=new n.S3(s).endpoint,i.populateURI(e),a.s3BucketEndpoint=o,r.headers.Host=r.endpoint.host,"validate"===e._asm.currentState&&(e.removeListener("build",i.populateURI),e.addListener("build",i.removeVirtualHostedBucketFromPath))}},extractData:function(e){var t=e.request;if("getBucketLocation"===t.operation){var r=e.httpResponse.body.toString().match(/>(.+)<\/Location/);delete e.data._,r?e.data.LocationConstraint=r[1]:e.data.LocationConstraint=""}var n=t.params.Bucket||null;if("deleteBucket"!==t.operation||"string"!=typeof n||e.error){var i=e.httpResponse.headers||{},a=i["x-amz-bucket-region"]||null;if(!a&&"createBucket"===t.operation&&!e.error){var o=t.params.CreateBucketConfiguration;a=o?"EU"===o.LocationConstraint?"eu-west-1":o.LocationConstraint:"us-east-1"}a&&n&&a!==t.service.bucketRegionCache[n]&&(t.service.bucketRegionCache[n]=a)}else t.service.clearBucketRegionCache(n);t.service.extractRequestIds(e)},extractError:function(e){var t={304:"NotModified",403:"Forbidden",400:"BadRequest",404:"NotFound"},r=e.request,i=e.httpResponse.statusCode,a=e.httpResponse.body||"",o=e.httpResponse.headers||{},s=o["x-amz-bucket-region"]||null,u=r.params.Bucket||null,c=r.service.bucketRegionCache;s&&u&&s!==c[u]&&(c[u]=s);var l;if(t[i]&&0===a.length)u&&!s&&(l=c[u]||null,l!==r.httpRequest.region&&(s=l)),e.error=n.util.error(new Error,{code:t[i],message:null,region:s});else{var d=(new n.XML.Parser).parse(a.toString());d.Region&&!s?(s=d.Region,u&&s!==c[u]&&(c[u]=s)):!u||s||d.Region||(l=c[u]||null,l!==r.httpRequest.region&&(s=l)),e.error=n.util.error(new Error,{code:d.Code||i,message:d.Message||null,region:s})}r.service.extractRequestIds(e)},requestBucketRegion:function(e,t){var r=e.error,i=e.request,o=i.params.Bucket||null;if(!r||!o||r.region||"listObjects"===i.operation||n.util.isNode()&&"headBucket"===i.operation||400===r.statusCode&&"headObject"!==i.operation||-1===a.indexOf(r.code))return t();var s=n.util.isNode()?"headBucket":"listObjects",u={Bucket:o};"listObjects"===s&&(u.MaxKeys=0);var c=i.service[s](u);c._requestRegionForBucket=o,c.send(function(){var e=i.service.bucketRegionCache[o]||null;r.region=e,t()})},reqRegionForNetworkingError:function(e,t){if(!n.util.isBrowser())return t();var r=e.error,i=e.request,a=i.params.Bucket;if(!r||"NetworkingError"!==r.code||!a||"us-east-1"===i.httpRequest.region)return t();var o=i.service,s=o.bucketRegionCache,u=s[a]||null;if(u&&u!==i.httpRequest.region)o.updateReqBucketRegion(i,u),t();else if(o.dnsCompatibleBucketName(a))if(i.httpRequest.virtualHostedBucket){var c=o.listObjects({Bucket:a,MaxKeys:0});o.updateReqBucketRegion(c,"us-east-1"),c._requestRegionForBucket=a,c.send(function(){var e=o.bucketRegionCache[a]||null;e&&e!==i.httpRequest.region&&o.updateReqBucketRegion(i,e),t()})}else t();else o.updateReqBucketRegion(i,"us-east-1"),"us-east-1"!==s[a]&&(s[a]="us-east-1"),t()},bucketRegionCache:{},clearBucketRegionCache:function(e){var t=this.bucketRegionCache;e?"string"==typeof e&&(e=[e]):e=Object.keys(t);for(var r=0;r<e.length;r++)delete t[e[r]];return t},correctBucketRegionFromCache:function(e){var t=e.params.Bucket||null;if(t){var r=e.service,n=e.httpRequest.region,i=r.bucketRegionCache[t];i&&i!==n&&r.updateReqBucketRegion(e,i)}},extractRequestIds:function(e){var t=e.httpResponse.headers?e.httpResponse.headers["x-amz-id-2"]:null,r=e.httpResponse.headers?e.httpResponse.headers["x-amz-cf-id"]:null;e.extendedRequestId=t,e.cfId=r,e.error&&(e.error.requestId=e.requestId||null,e.error.extendedRequestId=t,e.error.cfId=r)},getSignedUrl:function(e,t,r){t=n.util.copy(t||{});var i=t.Expires||900;delete t.Expires;var a=this.makeRequest(e,t);return a.presign(i,r)},prepareSignedUrl:function(e){e.addListener("validate",e.service.noPresignedContentLength),e.removeListener("build",e.service.addContentType),e.params.Body?e.addListener("afterBuild",n.EventListeners.Core.COMPUTE_SHA256):e.removeListener("build",e.service.computeContentMd5)},disableBodySigning:function(e){var t=e.httpRequest.headers;Object.prototype.hasOwnProperty.call(t,"presigned-expires")||(t["X-Amz-Content-Sha256"]="UNSIGNED-PAYLOAD")},noPresignedContentLength:function(e){if(void 0!==e.params.ContentLength)throw n.util.error(new Error,{code:"UnexpectedParameter",message:"ContentLength is not supported in pre-signed URLs."})},createBucket:function(e,t){"function"!=typeof e&&e||(t=t||e,e={});var r=this.endpoint.hostname;return r===this.api.globalEndpoint||e.CreateBucketConfiguration||(e.CreateBucketConfiguration={LocationConstraint:this.config.region}),this.makeRequest("createBucket",e,t)},upload:function(e,t,r){"function"==typeof t&&void 0===r&&(r=t,t=null),t=t||{},t=n.util.merge(t||{},{service:this,params:e});var i=new n.S3.ManagedUpload(t);return"function"==typeof r&&i.send(r),i}})},{"../core":24,"../s3/managed_upload":59}],59:[function(e,t,r){(function(r){var n=e("../core"),i=n.util.string.byteLength;n.S3.ManagedUpload=n.util.inherit({constructor:function(e){var t=this;n.SequentialExecutor.call(t),t.body=null,t.sliceFn=null,t.callback=null,t.parts={},t.completeInfo=[],t.fillQueue=function(){t.callback(new Error("Unsupported body payload "+typeof t.body))},t.configure(e)},configure:function(e){if(e=e||{},this.partSize=this.minPartSize,e.queueSize&&(this.queueSize=e.queueSize),e.partSize&&(this.partSize=e.partSize),e.leavePartsOnError&&(this.leavePartsOnError=!0),this.partSize<this.minPartSize)throw new Error("partSize must be greater than "+this.minPartSize);this.service=e.service,this.bindServiceObject(e.params),this.validateBody(),this.adjustTotalBytes()},leavePartsOnError:!1,queueSize:4,partSize:null,minPartSize:5242880,maxTotalParts:1e4,send:function(e){var t=this;t.failed=!1,t.callback=e||function(e){if(e)throw e};var r=!0;if(t.sliceFn)t.fillQueue=t.fillBuffer;else if(n.util.isNode()){var i=n.util.nodeRequire("stream").Stream;t.body instanceof i&&(r=!1,t.fillQueue=t.fillStream,t.partBuffers=[],t.body.on("readable",function(){t.fillQueue()}).on("end",function(){t.isDoneChunking=!0,t.numParts=t.totalPartNumbers,t.fillQueue.call(t)}))}r&&t.fillQueue.call(t)},abort:function(){this.cleanup(n.util.error(new Error("Request aborted by user"),{code:"RequestAbortedError",retryable:!1}))},validateBody:function(){var e=this;if(e.body=e.service.config.params.Body,!e.body)throw new Error("params.Body is required");"string"==typeof e.body&&(e.body=new n.util.Buffer(e.body)),e.sliceFn=n.util.arraySliceFn(e.body)},bindServiceObject:function(e){e=e||{};var t=this;if(t.service){var r=n.util.copy(t.service.config);t.service=new t.service.constructor.__super__(r),t.service.config.params=n.util.merge(t.service.config.params||{},e)}else t.service=new n.S3({params:e})},adjustTotalBytes:function(){var e=this;try{e.totalBytes=i(e.body)}catch(t){}if(e.totalBytes){var r=Math.ceil(e.totalBytes/e.maxTotalParts);r>e.partSize&&(e.partSize=r)}else e.totalBytes=void 0},isDoneChunking:!1,partPos:0,totalChunkedBytes:0,totalUploadedBytes:0,totalBytes:void 0,numParts:0,totalPartNumbers:0,activeParts:0,doneParts:0,parts:null,completeInfo:null,failed:!1,multipartReq:null,partBuffers:null,partBufferLength:0,fillBuffer:function(){var e=this,t=i(e.body);if(0===t)return e.isDoneChunking=!0,e.numParts=1,void e.nextChunk(e.body);for(;e.activeParts<e.queueSize&&e.partPos<t;){var r=Math.min(e.partPos+e.partSize,t),n=e.sliceFn.call(e.body,e.partPos,r);e.partPos+=e.partSize,(i(n)<e.partSize||e.partPos===t)&&(e.isDoneChunking=!0,e.numParts=e.totalPartNumbers+1),e.nextChunk(n)}},fillStream:function(){var e=this;if(!(e.activeParts>=e.queueSize)){var t=e.body.read(e.partSize-e.partBufferLength)||e.body.read();if(t&&(e.partBuffers.push(t),e.partBufferLength+=t.length,e.totalChunkedBytes+=t.length),e.partBufferLength>=e.partSize){var n=1===e.partBuffers.length?e.partBuffers[0]:r.concat(e.partBuffers);if(e.partBuffers=[],e.partBufferLength=0,n.length>e.partSize){var i=n.slice(e.partSize);e.partBuffers.push(i),e.partBufferLength+=i.length,n=n.slice(0,e.partSize)}e.nextChunk(n)}e.isDoneChunking&&!e.isDoneSending&&(n=1===e.partBuffers.length?e.partBuffers[0]:r.concat(e.partBuffers),e.partBuffers=[],e.partBufferLength=0,e.totalBytes=e.totalChunkedBytes,e.isDoneSending=!0,(0===e.numParts||n.length>0)&&(e.numParts++,e.nextChunk(n))),e.body.read(0)}},nextChunk:function(e){var t=this;if(t.failed)return null;var r=++t.totalPartNumbers;if(t.isDoneChunking&&1===r){var i=t.service.putObject({Body:e});return i._managedUpload=t,i.on("httpUploadProgress",t.progress).send(t.finishSinglePart),null}if(t.service.config.params.ContentMD5){var a=n.util.error(new Error("The Content-MD5 you specified is invalid for multi-part uploads."),{code:"InvalidDigest",retryable:!1});return t.cleanup(a),null}return t.completeInfo[r]&&null!==t.completeInfo[r].ETag?null:(t.activeParts++,void(t.service.config.params.UploadId?t.uploadPart(e,r):t.multipartReq?t.queueChunks(e,r):(t.multipartReq=t.service.createMultipartUpload(),t.multipartReq.on("success",function(e){t.service.config.params.UploadId=e.data.UploadId,t.multipartReq=null}),t.queueChunks(e,r),t.multipartReq.on("error",function(e){t.cleanup(e)}),t.multipartReq.send())))},uploadPart:function(e,t){var r=this,i={Body:e,ContentLength:n.util.string.byteLength(e),PartNumber:t},a={ETag:null,PartNumber:t};r.completeInfo[t]=a;var o=r.service.uploadPart(i);r.parts[t]=o,o._lastUploadedBytes=0,o._managedUpload=r,o.on("httpUploadProgress",r.progress),o.send(function(e,t){if(delete r.parts[i.PartNumber],r.activeParts--,!(e||t&&t.ETag)){var o="No access to ETag property on response.";n.util.isBrowser()&&(o+=" Check CORS configuration to expose ETag header."),e=n.util.error(new Error(o),{code:"ETagMissing",retryable:!1})}return e?r.cleanup(e):(a.ETag=t.ETag,r.doneParts++,void(r.isDoneChunking&&r.doneParts===r.numParts?r.finishMultiPart():r.fillQueue.call(r)))})},queueChunks:function(e,t){var r=this;r.multipartReq.on("success",function(){r.uploadPart(e,t)})},cleanup:function(e){var t=this;t.failed||("function"==typeof t.body.removeAllListeners&&"function"==typeof t.body.resume&&(t.body.removeAllListeners("readable"),t.body.removeAllListeners("end"),t.body.resume()),t.service.config.params.UploadId&&!t.leavePartsOnError&&t.service.abortMultipartUpload().send(),n.util.each(t.parts,function(e,t){t.removeAllListeners("complete"),t.abort()}),t.activeParts=0,t.partPos=0,t.numParts=0,t.totalPartNumbers=0,t.parts={},t.failed=!0,t.callback(e))},finishMultiPart:function(){var e=this,t={MultipartUpload:{Parts:e.completeInfo.slice(1)}};e.service.completeMultipartUpload(t,function(t,r){return t?e.cleanup(t):void e.callback(t,r)})},finishSinglePart:function(e,t){var r=this.request._managedUpload,n=this.request.httpRequest,i=n.endpoint;return e?r.callback(e):(t.Location=[i.protocol,"//",i.host,n.path].join(""),t.key=this.request.params.Key,t.Key=this.request.params.Key,t.Bucket=this.request.params.Bucket,void r.callback(e,t))},progress:function(e){var t=this._managedUpload;"putObject"===this.operation?(e.part=1,e.key=this.params.Key):(t.totalUploadedBytes+=e.loaded-this._lastUploadedBytes,this._lastUploadedBytes=e.loaded,e={loaded:t.totalUploadedBytes,total:t.totalBytes,part:this.params.PartNumber,key:this.params.Key}),t.emit("httpUploadProgress",[e])}}),n.util.mixin(n.S3.ManagedUpload,n.SequentialExecutor),t.exports=n.S3.ManagedUpload}).call(this,e("buffer").Buffer)},{"../core":24,buffer:1}]},{},[72]);AWS.apiLoader.services.s3["2006-03-01"]={version:"2.0",metadata:{apiVersion:"2006-03-01",checksumFormat:"md5",endpointPrefix:"s3",globalEndpoint:"s3.amazonaws.com",protocol:"rest-xml",serviceAbbreviation:"Amazon S3",serviceFullName:"Amazon Simple Storage Service",signatureVersion:"s3",timestampFormat:"rfc822"},operations:{AbortMultipartUpload:{http:{method:"DELETE",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key","UploadId"],members:{Bucket:{location:"uri",locationName:"Bucket"},Key:{location:"uri",locationName:"Key"},UploadId:{location:"querystring",locationName:"uploadId"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},CompleteMultipartUpload:{http:{requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key","UploadId"],members:{Bucket:{location:"uri",locationName:"Bucket"},Key:{location:"uri",locationName:"Key"},MultipartUpload:{locationName:"CompleteMultipartUpload",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",members:{Parts:{locationName:"Part",type:"list",member:{type:"structure",members:{ETag:{},PartNumber:{type:"integer"}}},flattened:!0}}},UploadId:{location:"querystring",locationName:"uploadId"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}},payload:"MultipartUpload"},output:{type:"structure",members:{Location:{},Bucket:{},Key:{},Expiration:{location:"header",locationName:"x-amz-expiration"},ETag:{},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},VersionId:{location:"header",locationName:"x-amz-version-id"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},CopyObject:{http:{method:"PUT",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","CopySource","Key"],members:{ACL:{location:"header",locationName:"x-amz-acl"},Bucket:{location:"uri",locationName:"Bucket"},CacheControl:{location:"header",locationName:"Cache-Control"},ContentDisposition:{location:"header",locationName:"Content-Disposition"},ContentEncoding:{location:"header",locationName:"Content-Encoding"},ContentLanguage:{location:"header",locationName:"Content-Language"},ContentType:{location:"header",locationName:"Content-Type"},CopySource:{location:"header",locationName:"x-amz-copy-source"},CopySourceIfMatch:{location:"header",locationName:"x-amz-copy-source-if-match"},CopySourceIfModifiedSince:{location:"header",locationName:"x-amz-copy-source-if-modified-since",type:"timestamp"},CopySourceIfNoneMatch:{location:"header",locationName:"x-amz-copy-source-if-none-match"},CopySourceIfUnmodifiedSince:{location:"header",locationName:"x-amz-copy-source-if-unmodified-since",type:"timestamp"},Expires:{location:"header",locationName:"Expires",type:"timestamp"},GrantFullControl:{location:"header",locationName:"x-amz-grant-full-control"},GrantRead:{location:"header",locationName:"x-amz-grant-read"},GrantReadACP:{location:"header",locationName:"x-amz-grant-read-acp"},GrantWriteACP:{location:"header",locationName:"x-amz-grant-write-acp"},Key:{location:"uri",locationName:"Key"},Metadata:{shape:"S11",location:"headers",locationName:"x-amz-meta-"},MetadataDirective:{location:"header",locationName:"x-amz-metadata-directive"},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},StorageClass:{location:"header",locationName:"x-amz-storage-class"},WebsiteRedirectLocation:{location:"header",locationName:"x-amz-website-redirect-location"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKey:{shape:"S18",location:"header",locationName:"x-amz-server-side-encryption-customer-key"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},CopySourceSSECustomerAlgorithm:{location:"header",locationName:"x-amz-copy-source-server-side-encryption-customer-algorithm"},CopySourceSSECustomerKey:{shape:"S1b",location:"header",locationName:"x-amz-copy-source-server-side-encryption-customer-key"},CopySourceSSECustomerKeyMD5:{location:"header",locationName:"x-amz-copy-source-server-side-encryption-customer-key-MD5"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{CopyObjectResult:{type:"structure",members:{ETag:{},LastModified:{type:"timestamp"}}},Expiration:{location:"header",locationName:"x-amz-expiration"},CopySourceVersionId:{location:"header",locationName:"x-amz-copy-source-version-id"},VersionId:{location:"header",locationName:"x-amz-version-id"},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}},payload:"CopyObjectResult"},alias:"PutObjectCopy"},CreateBucket:{http:{method:"PUT",requestUri:"/{Bucket}"},input:{type:"structure",required:["Bucket"],members:{ACL:{location:"header",locationName:"x-amz-acl"},Bucket:{location:"uri",locationName:"Bucket"},CreateBucketConfiguration:{locationName:"CreateBucketConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",members:{LocationConstraint:{}}},GrantFullControl:{location:"header",locationName:"x-amz-grant-full-control"},GrantRead:{location:"header",locationName:"x-amz-grant-read"},GrantReadACP:{location:"header",locationName:"x-amz-grant-read-acp"},GrantWrite:{location:"header",locationName:"x-amz-grant-write"},GrantWriteACP:{location:"header",locationName:"x-amz-grant-write-acp"}},payload:"CreateBucketConfiguration"},output:{type:"structure",members:{Location:{location:"header",locationName:"Location"}}},alias:"PutBucket"},CreateMultipartUpload:{http:{requestUri:"/{Bucket}/{Key+}?uploads"},input:{type:"structure",required:["Bucket","Key"],members:{ACL:{location:"header",locationName:"x-amz-acl"},Bucket:{location:"uri",locationName:"Bucket"},CacheControl:{location:"header",locationName:"Cache-Control"},ContentDisposition:{location:"header",locationName:"Content-Disposition"},ContentEncoding:{location:"header",locationName:"Content-Encoding"},ContentLanguage:{location:"header",locationName:"Content-Language"},ContentType:{location:"header",locationName:"Content-Type"},Expires:{location:"header",locationName:"Expires",type:"timestamp"},GrantFullControl:{location:"header",locationName:"x-amz-grant-full-control"},GrantRead:{location:"header",locationName:"x-amz-grant-read"},GrantReadACP:{location:"header",locationName:"x-amz-grant-read-acp"},GrantWriteACP:{location:"header",locationName:"x-amz-grant-write-acp"},Key:{location:"uri",locationName:"Key"},Metadata:{shape:"S11",location:"headers",locationName:"x-amz-meta-"},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},StorageClass:{location:"header",locationName:"x-amz-storage-class"},WebsiteRedirectLocation:{location:"header",locationName:"x-amz-website-redirect-location"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKey:{shape:"S18",location:"header",locationName:"x-amz-server-side-encryption-customer-key"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{AbortDate:{location:"header",locationName:"x-amz-abort-date",type:"timestamp"},AbortRuleId:{location:"header",locationName:"x-amz-abort-rule-id"},Bucket:{locationName:"Bucket"},Key:{},UploadId:{},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}},alias:"InitiateMultipartUpload"},DeleteBucket:{http:{method:"DELETE",requestUri:"/{Bucket}"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},DeleteBucketCors:{http:{method:"DELETE",requestUri:"/{Bucket}?cors"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},DeleteBucketLifecycle:{http:{method:"DELETE",requestUri:"/{Bucket}?lifecycle"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},DeleteBucketPolicy:{http:{method:"DELETE",requestUri:"/{Bucket}?policy"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},DeleteBucketReplication:{http:{method:"DELETE",requestUri:"/{Bucket}?replication"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},DeleteBucketTagging:{http:{method:"DELETE",requestUri:"/{Bucket}?tagging"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},DeleteBucketWebsite:{http:{method:"DELETE",requestUri:"/{Bucket}?website"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},DeleteObject:{http:{method:"DELETE",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key"],members:{Bucket:{location:"uri",locationName:"Bucket"},Key:{location:"uri",locationName:"Key"},MFA:{location:"header",locationName:"x-amz-mfa"},VersionId:{location:"querystring",locationName:"versionId"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{DeleteMarker:{location:"header",locationName:"x-amz-delete-marker",type:"boolean"},VersionId:{location:"header",locationName:"x-amz-version-id"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},DeleteObjects:{http:{requestUri:"/{Bucket}?delete"},input:{type:"structure",required:["Bucket","Delete"],members:{Bucket:{location:"uri",locationName:"Bucket"},Delete:{locationName:"Delete",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",required:["Objects"],members:{Objects:{locationName:"Object",type:"list",member:{type:"structure",required:["Key"],members:{Key:{},VersionId:{}}},flattened:!0},Quiet:{type:"boolean"}}},MFA:{location:"header",locationName:"x-amz-mfa"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}},payload:"Delete"},output:{type:"structure",members:{Deleted:{type:"list",member:{type:"structure",members:{Key:{},VersionId:{},DeleteMarker:{type:"boolean"},DeleteMarkerVersionId:{}}},flattened:!0},RequestCharged:{location:"header",locationName:"x-amz-request-charged"},Errors:{locationName:"Error",type:"list",member:{type:"structure",members:{Key:{},VersionId:{},Code:{},Message:{}}},flattened:!0}}},alias:"DeleteMultipleObjects"},GetBucketAccelerateConfiguration:{http:{method:"GET",requestUri:"/{Bucket}?accelerate"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{Status:{}}}},GetBucketAcl:{http:{method:"GET",requestUri:"/{Bucket}?acl"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{Owner:{shape:"S2k"},Grants:{shape:"S2n",locationName:"AccessControlList"}}}},GetBucketCors:{http:{method:"GET",requestUri:"/{Bucket}?cors"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{CORSRules:{shape:"S2w",locationName:"CORSRule"}}}},GetBucketLifecycle:{http:{method:"GET",requestUri:"/{Bucket}?lifecycle"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{Rules:{shape:"S39",locationName:"Rule"}}},deprecated:!0},GetBucketLifecycleConfiguration:{http:{method:"GET",requestUri:"/{Bucket}?lifecycle"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{Rules:{shape:"S3p",locationName:"Rule"}}}},GetBucketLocation:{http:{method:"GET",requestUri:"/{Bucket}?location"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{LocationConstraint:{}}}},GetBucketLogging:{http:{method:"GET",requestUri:"/{Bucket}?logging"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{LoggingEnabled:{shape:"S3x"}}}},GetBucketNotification:{http:{method:"GET",requestUri:"/{Bucket}?notification"},input:{shape:"S43"},output:{shape:"S44"},deprecated:!0},GetBucketNotificationConfiguration:{http:{method:"GET",requestUri:"/{Bucket}?notification"},input:{shape:"S43"},output:{shape:"S4f"}},GetBucketPolicy:{http:{method:"GET",requestUri:"/{Bucket}?policy"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{Policy:{}},payload:"Policy"}},GetBucketReplication:{http:{method:"GET",requestUri:"/{Bucket}?replication"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{ReplicationConfiguration:{shape:"S4y"}},payload:"ReplicationConfiguration"}},GetBucketRequestPayment:{http:{method:"GET",requestUri:"/{Bucket}?requestPayment"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{Payer:{}}}},GetBucketTagging:{http:{method:"GET",requestUri:"/{Bucket}?tagging"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",required:["TagSet"],members:{TagSet:{shape:"S59"}}}},GetBucketVersioning:{http:{method:"GET",requestUri:"/{Bucket}?versioning"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{Status:{},MFADelete:{locationName:"MfaDelete"}}}},GetBucketWebsite:{http:{method:"GET",requestUri:"/{Bucket}?website"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},output:{type:"structure",members:{RedirectAllRequestsTo:{shape:"S5i"},IndexDocument:{shape:"S5l"},ErrorDocument:{shape:"S5n"},RoutingRules:{shape:"S5o"}}}},GetObject:{http:{method:"GET",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key"],members:{Bucket:{location:"uri",locationName:"Bucket"},IfMatch:{location:"header",locationName:"If-Match"},IfModifiedSince:{location:"header",locationName:"If-Modified-Since",type:"timestamp"},IfNoneMatch:{location:"header",locationName:"If-None-Match"},IfUnmodifiedSince:{location:"header",locationName:"If-Unmodified-Since",type:"timestamp"},Key:{location:"uri",locationName:"Key"},Range:{location:"header",locationName:"Range"},ResponseCacheControl:{location:"querystring",locationName:"response-cache-control"},ResponseContentDisposition:{location:"querystring",locationName:"response-content-disposition"},ResponseContentEncoding:{location:"querystring",locationName:"response-content-encoding"},ResponseContentLanguage:{location:"querystring",locationName:"response-content-language"},ResponseContentType:{location:"querystring",locationName:"response-content-type"},ResponseExpires:{location:"querystring",locationName:"response-expires",type:"timestamp"},VersionId:{location:"querystring",locationName:"versionId"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKey:{shape:"S18",location:"header",locationName:"x-amz-server-side-encryption-customer-key"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{Body:{streaming:!0,type:"blob"},DeleteMarker:{location:"header",locationName:"x-amz-delete-marker",type:"boolean"},AcceptRanges:{location:"header",locationName:"accept-ranges"},Expiration:{location:"header",locationName:"x-amz-expiration"},Restore:{location:"header",locationName:"x-amz-restore"},LastModified:{location:"header",locationName:"Last-Modified",type:"timestamp"},ContentLength:{location:"header",locationName:"Content-Length",type:"long"},ETag:{location:"header",locationName:"ETag"},MissingMeta:{location:"header",locationName:"x-amz-missing-meta",type:"integer"},VersionId:{location:"header",locationName:"x-amz-version-id"},CacheControl:{location:"header",locationName:"Cache-Control"},ContentDisposition:{location:"header",locationName:"Content-Disposition"},ContentEncoding:{location:"header",locationName:"Content-Encoding"},ContentLanguage:{location:"header",locationName:"Content-Language"},ContentRange:{location:"header",locationName:"Content-Range"},ContentType:{location:"header",locationName:"Content-Type"},Expires:{location:"header",locationName:"Expires",type:"timestamp"},WebsiteRedirectLocation:{location:"header",locationName:"x-amz-website-redirect-location"},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},Metadata:{shape:"S11",location:"headers",locationName:"x-amz-meta-"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},StorageClass:{location:"header",locationName:"x-amz-storage-class"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"},ReplicationStatus:{location:"header",locationName:"x-amz-replication-status"}},payload:"Body"}},GetObjectAcl:{http:{method:"GET",requestUri:"/{Bucket}/{Key+}?acl"},input:{type:"structure",required:["Bucket","Key"],members:{Bucket:{location:"uri",locationName:"Bucket"},Key:{location:"uri",locationName:"Key"},VersionId:{location:"querystring",locationName:"versionId"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{Owner:{shape:"S2k"},Grants:{shape:"S2n",locationName:"AccessControlList"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},GetObjectTorrent:{http:{method:"GET",requestUri:"/{Bucket}/{Key+}?torrent"},input:{type:"structure",required:["Bucket","Key"],members:{Bucket:{location:"uri",locationName:"Bucket"},Key:{location:"uri",locationName:"Key"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{Body:{streaming:!0,type:"blob"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}},payload:"Body"}},HeadBucket:{http:{method:"HEAD",requestUri:"/{Bucket}"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}}},HeadObject:{http:{method:"HEAD",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key"],members:{Bucket:{location:"uri",locationName:"Bucket"},IfMatch:{location:"header",locationName:"If-Match"},IfModifiedSince:{location:"header",locationName:"If-Modified-Since",type:"timestamp"},IfNoneMatch:{location:"header",locationName:"If-None-Match"},IfUnmodifiedSince:{location:"header",locationName:"If-Unmodified-Since",type:"timestamp"},Key:{location:"uri",locationName:"Key"},Range:{location:"header",locationName:"Range"},VersionId:{location:"querystring",locationName:"versionId"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKey:{shape:"S18",location:"header",locationName:"x-amz-server-side-encryption-customer-key"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{DeleteMarker:{location:"header",locationName:"x-amz-delete-marker",type:"boolean"},AcceptRanges:{location:"header",locationName:"accept-ranges"},Expiration:{location:"header",locationName:"x-amz-expiration"},Restore:{location:"header",locationName:"x-amz-restore"},LastModified:{location:"header",locationName:"Last-Modified",type:"timestamp"},ContentLength:{location:"header",locationName:"Content-Length",type:"long"},ETag:{location:"header",locationName:"ETag"},MissingMeta:{location:"header",locationName:"x-amz-missing-meta",type:"integer"},VersionId:{location:"header",locationName:"x-amz-version-id"},CacheControl:{location:"header",locationName:"Cache-Control"},ContentDisposition:{location:"header",locationName:"Content-Disposition"},ContentEncoding:{location:"header",locationName:"Content-Encoding"},ContentLanguage:{location:"header",locationName:"Content-Language"},ContentType:{location:"header",locationName:"Content-Type"},Expires:{location:"header",locationName:"Expires",type:"timestamp"},WebsiteRedirectLocation:{location:"header",locationName:"x-amz-website-redirect-location"},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},Metadata:{shape:"S11",location:"headers",locationName:"x-amz-meta-"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},StorageClass:{location:"header",locationName:"x-amz-storage-class"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"},ReplicationStatus:{location:"header",locationName:"x-amz-replication-status"}}}},ListBuckets:{http:{method:"GET"},output:{type:"structure",members:{Buckets:{type:"list",member:{locationName:"Bucket",type:"structure",members:{Name:{},CreationDate:{type:"timestamp"}}}},Owner:{shape:"S2k"}}},alias:"GetService"},ListMultipartUploads:{http:{method:"GET",requestUri:"/{Bucket}?uploads"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"},Delimiter:{location:"querystring",locationName:"delimiter"},EncodingType:{location:"querystring",locationName:"encoding-type"},KeyMarker:{location:"querystring",locationName:"key-marker"},MaxUploads:{location:"querystring",locationName:"max-uploads",type:"integer"},Prefix:{location:"querystring",locationName:"prefix"},UploadIdMarker:{location:"querystring",locationName:"upload-id-marker"}}},output:{type:"structure",members:{Bucket:{},KeyMarker:{},UploadIdMarker:{},NextKeyMarker:{},Prefix:{},Delimiter:{},NextUploadIdMarker:{},MaxUploads:{type:"integer"},IsTruncated:{type:"boolean"},Uploads:{locationName:"Upload",type:"list",member:{type:"structure",members:{UploadId:{},Key:{},Initiated:{type:"timestamp"},StorageClass:{},Owner:{shape:"S2k"},Initiator:{shape:"S75"}}},flattened:!0},CommonPrefixes:{shape:"S76"},EncodingType:{}}}},ListObjectVersions:{http:{method:"GET",requestUri:"/{Bucket}?versions"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"},Delimiter:{location:"querystring",locationName:"delimiter"},EncodingType:{location:"querystring",locationName:"encoding-type"},KeyMarker:{location:"querystring",locationName:"key-marker"},MaxKeys:{location:"querystring",locationName:"max-keys",type:"integer"},Prefix:{location:"querystring",locationName:"prefix"},VersionIdMarker:{location:"querystring",locationName:"version-id-marker"}}},output:{type:"structure",members:{IsTruncated:{type:"boolean"},KeyMarker:{},VersionIdMarker:{},NextKeyMarker:{},NextVersionIdMarker:{},Versions:{locationName:"Version",type:"list",member:{type:"structure",members:{ETag:{},Size:{type:"integer"},StorageClass:{},Key:{},VersionId:{},IsLatest:{type:"boolean"},LastModified:{type:"timestamp"},Owner:{shape:"S2k"}}},flattened:!0},DeleteMarkers:{locationName:"DeleteMarker",type:"list",member:{type:"structure",members:{Owner:{shape:"S2k"},Key:{},VersionId:{},IsLatest:{type:"boolean"},LastModified:{type:"timestamp"}}},flattened:!0},Name:{},Prefix:{},Delimiter:{},MaxKeys:{type:"integer"},CommonPrefixes:{shape:"S76"},EncodingType:{}}},alias:"GetBucketObjectVersions"},ListObjects:{http:{method:"GET",requestUri:"/{Bucket}"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"},Delimiter:{location:"querystring",locationName:"delimiter"},EncodingType:{location:"querystring",locationName:"encoding-type"},Marker:{location:"querystring",locationName:"marker"},MaxKeys:{location:"querystring",locationName:"max-keys",type:"integer"},Prefix:{location:"querystring",locationName:"prefix"}}},output:{type:"structure",members:{IsTruncated:{type:"boolean"},Marker:{},NextMarker:{},Contents:{shape:"S7o"},Name:{},Prefix:{},Delimiter:{},MaxKeys:{type:"integer"},CommonPrefixes:{shape:"S76"},EncodingType:{}}},alias:"GetBucket"},ListObjectsV2:{http:{method:"GET",requestUri:"/{Bucket}?list-type=2"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"},Delimiter:{location:"querystring",locationName:"delimiter"},EncodingType:{location:"querystring",locationName:"encoding-type"},MaxKeys:{location:"querystring",locationName:"max-keys",type:"integer"},Prefix:{location:"querystring",locationName:"prefix"},ContinuationToken:{location:"querystring",locationName:"continuation-token"},FetchOwner:{location:"querystring",locationName:"fetch-owner",type:"boolean"},StartAfter:{location:"querystring",locationName:"start-after"}}},output:{type:"structure",members:{IsTruncated:{type:"boolean"},Contents:{shape:"S7o"},Name:{},Prefix:{},Delimiter:{},MaxKeys:{type:"integer"},CommonPrefixes:{shape:"S76"},EncodingType:{},KeyCount:{type:"integer"},ContinuationToken:{},NextContinuationToken:{},StartAfter:{}}}},ListParts:{http:{method:"GET",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key","UploadId"],members:{Bucket:{location:"uri",locationName:"Bucket"},Key:{location:"uri",locationName:"Key"},MaxParts:{location:"querystring",locationName:"max-parts",type:"integer"},PartNumberMarker:{location:"querystring",locationName:"part-number-marker",type:"integer"},UploadId:{location:"querystring",locationName:"uploadId"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{AbortDate:{location:"header",locationName:"x-amz-abort-date",type:"timestamp"},AbortRuleId:{location:"header",locationName:"x-amz-abort-rule-id"},Bucket:{},Key:{},UploadId:{},PartNumberMarker:{type:"integer"},NextPartNumberMarker:{type:"integer"},MaxParts:{type:"integer"},IsTruncated:{type:"boolean"},Parts:{locationName:"Part",type:"list",member:{type:"structure",members:{PartNumber:{type:"integer"},LastModified:{type:"timestamp"},ETag:{},Size:{type:"integer"}}},flattened:!0},Initiator:{shape:"S75"},Owner:{shape:"S2k"},StorageClass:{},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},PutBucketAccelerateConfiguration:{http:{method:"PUT",requestUri:"/{Bucket}?accelerate"},input:{type:"structure",required:["Bucket","AccelerateConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},AccelerateConfiguration:{locationName:"AccelerateConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",members:{Status:{}}}},payload:"AccelerateConfiguration"}},PutBucketAcl:{http:{method:"PUT",requestUri:"/{Bucket}?acl"},input:{type:"structure",required:["Bucket"],members:{ACL:{location:"header",locationName:"x-amz-acl"},AccessControlPolicy:{shape:"S88",locationName:"AccessControlPolicy",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"}},Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},GrantFullControl:{location:"header",locationName:"x-amz-grant-full-control"},GrantRead:{location:"header",locationName:"x-amz-grant-read"},GrantReadACP:{location:"header",locationName:"x-amz-grant-read-acp"},GrantWrite:{location:"header",locationName:"x-amz-grant-write"},GrantWriteACP:{location:"header",locationName:"x-amz-grant-write-acp"}},payload:"AccessControlPolicy"}},PutBucketCors:{http:{method:"PUT",requestUri:"/{Bucket}?cors"},input:{type:"structure",required:["Bucket","CORSConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},CORSConfiguration:{locationName:"CORSConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",required:["CORSRules"],members:{CORSRules:{shape:"S2w",locationName:"CORSRule"}}},ContentMD5:{location:"header",locationName:"Content-MD5"}},payload:"CORSConfiguration"}},PutBucketLifecycle:{http:{method:"PUT",requestUri:"/{Bucket}?lifecycle"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},LifecycleConfiguration:{locationName:"LifecycleConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",required:["Rules"],members:{Rules:{shape:"S39",locationName:"Rule"}}}},payload:"LifecycleConfiguration"},deprecated:!0},PutBucketLifecycleConfiguration:{http:{method:"PUT",requestUri:"/{Bucket}?lifecycle"},input:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"},LifecycleConfiguration:{locationName:"LifecycleConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",required:["Rules"],members:{Rules:{shape:"S3p",locationName:"Rule"}}}},payload:"LifecycleConfiguration"}},PutBucketLogging:{http:{method:"PUT",requestUri:"/{Bucket}?logging"},input:{type:"structure",required:["Bucket","BucketLoggingStatus"],members:{Bucket:{location:"uri",locationName:"Bucket"},BucketLoggingStatus:{locationName:"BucketLoggingStatus",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",members:{LoggingEnabled:{shape:"S3x"}}},ContentMD5:{location:"header",locationName:"Content-MD5"}},payload:"BucketLoggingStatus"}},PutBucketNotification:{http:{method:"PUT",requestUri:"/{Bucket}?notification"},input:{type:"structure",required:["Bucket","NotificationConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},NotificationConfiguration:{shape:"S44",locationName:"NotificationConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"}}},payload:"NotificationConfiguration"},deprecated:!0},PutBucketNotificationConfiguration:{http:{method:"PUT",requestUri:"/{Bucket}?notification"},input:{type:"structure",required:["Bucket","NotificationConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},NotificationConfiguration:{shape:"S4f",locationName:"NotificationConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"}}},payload:"NotificationConfiguration"}},PutBucketPolicy:{http:{method:"PUT",requestUri:"/{Bucket}?policy"},input:{type:"structure",required:["Bucket","Policy"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},Policy:{}},
payload:"Policy"}},PutBucketReplication:{http:{method:"PUT",requestUri:"/{Bucket}?replication"},input:{type:"structure",required:["Bucket","ReplicationConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},ReplicationConfiguration:{shape:"S4y",locationName:"ReplicationConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"}}},payload:"ReplicationConfiguration"}},PutBucketRequestPayment:{http:{method:"PUT",requestUri:"/{Bucket}?requestPayment"},input:{type:"structure",required:["Bucket","RequestPaymentConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},RequestPaymentConfiguration:{locationName:"RequestPaymentConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",required:["Payer"],members:{Payer:{}}}},payload:"RequestPaymentConfiguration"}},PutBucketTagging:{http:{method:"PUT",requestUri:"/{Bucket}?tagging"},input:{type:"structure",required:["Bucket","Tagging"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},Tagging:{locationName:"Tagging",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",required:["TagSet"],members:{TagSet:{shape:"S59"}}}},payload:"Tagging"}},PutBucketVersioning:{http:{method:"PUT",requestUri:"/{Bucket}?versioning"},input:{type:"structure",required:["Bucket","VersioningConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},MFA:{location:"header",locationName:"x-amz-mfa"},VersioningConfiguration:{locationName:"VersioningConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",members:{MFADelete:{locationName:"MfaDelete"},Status:{}}}},payload:"VersioningConfiguration"}},PutBucketWebsite:{http:{method:"PUT",requestUri:"/{Bucket}?website"},input:{type:"structure",required:["Bucket","WebsiteConfiguration"],members:{Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},WebsiteConfiguration:{locationName:"WebsiteConfiguration",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",members:{ErrorDocument:{shape:"S5n"},IndexDocument:{shape:"S5l"},RedirectAllRequestsTo:{shape:"S5i"},RoutingRules:{shape:"S5o"}}}},payload:"WebsiteConfiguration"}},PutObject:{http:{method:"PUT",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key"],members:{ACL:{location:"header",locationName:"x-amz-acl"},Body:{streaming:!0,type:"blob"},Bucket:{location:"uri",locationName:"Bucket"},CacheControl:{location:"header",locationName:"Cache-Control"},ContentDisposition:{location:"header",locationName:"Content-Disposition"},ContentEncoding:{location:"header",locationName:"Content-Encoding"},ContentLanguage:{location:"header",locationName:"Content-Language"},ContentLength:{location:"header",locationName:"Content-Length",type:"long"},ContentMD5:{location:"header",locationName:"Content-MD5"},ContentType:{location:"header",locationName:"Content-Type"},Expires:{location:"header",locationName:"Expires",type:"timestamp"},GrantFullControl:{location:"header",locationName:"x-amz-grant-full-control"},GrantRead:{location:"header",locationName:"x-amz-grant-read"},GrantReadACP:{location:"header",locationName:"x-amz-grant-read-acp"},GrantWriteACP:{location:"header",locationName:"x-amz-grant-write-acp"},Key:{location:"uri",locationName:"Key"},Metadata:{shape:"S11",location:"headers",locationName:"x-amz-meta-"},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},StorageClass:{location:"header",locationName:"x-amz-storage-class"},WebsiteRedirectLocation:{location:"header",locationName:"x-amz-website-redirect-location"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKey:{shape:"S18",location:"header",locationName:"x-amz-server-side-encryption-customer-key"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}},payload:"Body"},output:{type:"structure",members:{Expiration:{location:"header",locationName:"x-amz-expiration"},ETag:{location:"header",locationName:"ETag"},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},VersionId:{location:"header",locationName:"x-amz-version-id"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},PutObjectAcl:{http:{method:"PUT",requestUri:"/{Bucket}/{Key+}?acl"},input:{type:"structure",required:["Bucket","Key"],members:{ACL:{location:"header",locationName:"x-amz-acl"},AccessControlPolicy:{shape:"S88",locationName:"AccessControlPolicy",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"}},Bucket:{location:"uri",locationName:"Bucket"},ContentMD5:{location:"header",locationName:"Content-MD5"},GrantFullControl:{location:"header",locationName:"x-amz-grant-full-control"},GrantRead:{location:"header",locationName:"x-amz-grant-read"},GrantReadACP:{location:"header",locationName:"x-amz-grant-read-acp"},GrantWrite:{location:"header",locationName:"x-amz-grant-write"},GrantWriteACP:{location:"header",locationName:"x-amz-grant-write-acp"},Key:{location:"uri",locationName:"Key"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"},VersionId:{location:"querystring",locationName:"versionId"}},payload:"AccessControlPolicy"},output:{type:"structure",members:{RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},RestoreObject:{http:{requestUri:"/{Bucket}/{Key+}?restore"},input:{type:"structure",required:["Bucket","Key"],members:{Bucket:{location:"uri",locationName:"Bucket"},Key:{location:"uri",locationName:"Key"},VersionId:{location:"querystring",locationName:"versionId"},RestoreRequest:{locationName:"RestoreRequest",xmlNamespace:{uri:"http://s3.amazonaws.com/doc/2006-03-01/"},type:"structure",required:["Days"],members:{Days:{type:"integer"}}},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}},payload:"RestoreRequest"},output:{type:"structure",members:{RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}},alias:"PostObjectRestore"},UploadPart:{http:{method:"PUT",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","Key","PartNumber","UploadId"],members:{Body:{streaming:!0,type:"blob"},Bucket:{location:"uri",locationName:"Bucket"},ContentLength:{location:"header",locationName:"Content-Length",type:"long"},ContentMD5:{location:"header",locationName:"Content-MD5"},Key:{location:"uri",locationName:"Key"},PartNumber:{location:"querystring",locationName:"partNumber",type:"integer"},UploadId:{location:"querystring",locationName:"uploadId"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKey:{shape:"S18",location:"header",locationName:"x-amz-server-side-encryption-customer-key"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}},payload:"Body"},output:{type:"structure",members:{ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},ETag:{location:"header",locationName:"ETag"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}}}},UploadPartCopy:{http:{method:"PUT",requestUri:"/{Bucket}/{Key+}"},input:{type:"structure",required:["Bucket","CopySource","Key","PartNumber","UploadId"],members:{Bucket:{location:"uri",locationName:"Bucket"},CopySource:{location:"header",locationName:"x-amz-copy-source"},CopySourceIfMatch:{location:"header",locationName:"x-amz-copy-source-if-match"},CopySourceIfModifiedSince:{location:"header",locationName:"x-amz-copy-source-if-modified-since",type:"timestamp"},CopySourceIfNoneMatch:{location:"header",locationName:"x-amz-copy-source-if-none-match"},CopySourceIfUnmodifiedSince:{location:"header",locationName:"x-amz-copy-source-if-unmodified-since",type:"timestamp"},CopySourceRange:{location:"header",locationName:"x-amz-copy-source-range"},Key:{location:"uri",locationName:"Key"},PartNumber:{location:"querystring",locationName:"partNumber",type:"integer"},UploadId:{location:"querystring",locationName:"uploadId"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKey:{shape:"S18",location:"header",locationName:"x-amz-server-side-encryption-customer-key"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},CopySourceSSECustomerAlgorithm:{location:"header",locationName:"x-amz-copy-source-server-side-encryption-customer-algorithm"},CopySourceSSECustomerKey:{shape:"S1b",location:"header",locationName:"x-amz-copy-source-server-side-encryption-customer-key"},CopySourceSSECustomerKeyMD5:{location:"header",locationName:"x-amz-copy-source-server-side-encryption-customer-key-MD5"},RequestPayer:{location:"header",locationName:"x-amz-request-payer"}}},output:{type:"structure",members:{CopySourceVersionId:{location:"header",locationName:"x-amz-copy-source-version-id"},CopyPartResult:{type:"structure",members:{ETag:{},LastModified:{type:"timestamp"}}},ServerSideEncryption:{location:"header",locationName:"x-amz-server-side-encryption"},SSECustomerAlgorithm:{location:"header",locationName:"x-amz-server-side-encryption-customer-algorithm"},SSECustomerKeyMD5:{location:"header",locationName:"x-amz-server-side-encryption-customer-key-MD5"},SSEKMSKeyId:{shape:"Sj",location:"header",locationName:"x-amz-server-side-encryption-aws-kms-key-id"},RequestCharged:{location:"header",locationName:"x-amz-request-charged"}},payload:"CopyPartResult"}}},shapes:{Sj:{type:"string",sensitive:!0},S11:{type:"map",key:{},value:{}},S18:{type:"blob",sensitive:!0},S1b:{type:"blob",sensitive:!0},S2k:{type:"structure",members:{DisplayName:{},ID:{}}},S2n:{type:"list",member:{locationName:"Grant",type:"structure",members:{Grantee:{shape:"S2p"},Permission:{}}}},S2p:{type:"structure",required:["Type"],members:{DisplayName:{},EmailAddress:{},ID:{},Type:{locationName:"xsi:type",xmlAttribute:!0},URI:{}},xmlNamespace:{prefix:"xsi",uri:"http://www.w3.org/2001/XMLSchema-instance"}},S2w:{type:"list",member:{type:"structure",required:["AllowedMethods","AllowedOrigins"],members:{AllowedHeaders:{locationName:"AllowedHeader",type:"list",member:{},flattened:!0},AllowedMethods:{locationName:"AllowedMethod",type:"list",member:{},flattened:!0},AllowedOrigins:{locationName:"AllowedOrigin",type:"list",member:{},flattened:!0},ExposeHeaders:{locationName:"ExposeHeader",type:"list",member:{},flattened:!0},MaxAgeSeconds:{type:"integer"}}},flattened:!0},S39:{type:"list",member:{type:"structure",required:["Prefix","Status"],members:{Expiration:{shape:"S3b"},ID:{},Prefix:{},Status:{},Transition:{shape:"S3h"},NoncurrentVersionTransition:{shape:"S3j"},NoncurrentVersionExpiration:{shape:"S3k"},AbortIncompleteMultipartUpload:{shape:"S3l"}}},flattened:!0},S3b:{type:"structure",members:{Date:{shape:"S3c"},Days:{type:"integer"},ExpiredObjectDeleteMarker:{type:"boolean"}}},S3c:{type:"timestamp",timestampFormat:"iso8601"},S3h:{type:"structure",members:{Date:{shape:"S3c"},Days:{type:"integer"},StorageClass:{}}},S3j:{type:"structure",members:{NoncurrentDays:{type:"integer"},StorageClass:{}}},S3k:{type:"structure",members:{NoncurrentDays:{type:"integer"}}},S3l:{type:"structure",members:{DaysAfterInitiation:{type:"integer"}}},S3p:{type:"list",member:{type:"structure",required:["Prefix","Status"],members:{Expiration:{shape:"S3b"},ID:{},Prefix:{},Status:{},Transitions:{locationName:"Transition",type:"list",member:{shape:"S3h"},flattened:!0},NoncurrentVersionTransitions:{locationName:"NoncurrentVersionTransition",type:"list",member:{shape:"S3j"},flattened:!0},NoncurrentVersionExpiration:{shape:"S3k"},AbortIncompleteMultipartUpload:{shape:"S3l"}}},flattened:!0},S3x:{type:"structure",members:{TargetBucket:{},TargetGrants:{type:"list",member:{locationName:"Grant",type:"structure",members:{Grantee:{shape:"S2p"},Permission:{}}}},TargetPrefix:{}}},S43:{type:"structure",required:["Bucket"],members:{Bucket:{location:"uri",locationName:"Bucket"}}},S44:{type:"structure",members:{TopicConfiguration:{type:"structure",members:{Id:{},Events:{shape:"S47",locationName:"Event"},Event:{deprecated:!0},Topic:{}}},QueueConfiguration:{type:"structure",members:{Id:{},Event:{deprecated:!0},Events:{shape:"S47",locationName:"Event"},Queue:{}}},CloudFunctionConfiguration:{type:"structure",members:{Id:{},Event:{deprecated:!0},Events:{shape:"S47",locationName:"Event"},CloudFunction:{},InvocationRole:{}}}}},S47:{type:"list",member:{},flattened:!0},S4f:{type:"structure",members:{TopicConfigurations:{locationName:"TopicConfiguration",type:"list",member:{type:"structure",required:["TopicArn","Events"],members:{Id:{},TopicArn:{locationName:"Topic"},Events:{shape:"S47",locationName:"Event"},Filter:{shape:"S4i"}}},flattened:!0},QueueConfigurations:{locationName:"QueueConfiguration",type:"list",member:{type:"structure",required:["QueueArn","Events"],members:{Id:{},QueueArn:{locationName:"Queue"},Events:{shape:"S47",locationName:"Event"},Filter:{shape:"S4i"}}},flattened:!0},LambdaFunctionConfigurations:{locationName:"CloudFunctionConfiguration",type:"list",member:{type:"structure",required:["LambdaFunctionArn","Events"],members:{Id:{},LambdaFunctionArn:{locationName:"CloudFunction"},Events:{shape:"S47",locationName:"Event"},Filter:{shape:"S4i"}}},flattened:!0}}},S4i:{type:"structure",members:{Key:{locationName:"S3Key",type:"structure",members:{FilterRules:{locationName:"FilterRule",type:"list",member:{type:"structure",members:{Name:{},Value:{}}},flattened:!0}}}}},S4y:{type:"structure",required:["Role","Rules"],members:{Role:{},Rules:{locationName:"Rule",type:"list",member:{type:"structure",required:["Prefix","Status","Destination"],members:{ID:{},Prefix:{},Status:{},Destination:{type:"structure",required:["Bucket"],members:{Bucket:{},StorageClass:{}}}}},flattened:!0}}},S59:{type:"list",member:{locationName:"Tag",type:"structure",required:["Key","Value"],members:{Key:{},Value:{}}}},S5i:{type:"structure",required:["HostName"],members:{HostName:{},Protocol:{}}},S5l:{type:"structure",required:["Suffix"],members:{Suffix:{}}},S5n:{type:"structure",required:["Key"],members:{Key:{}}},S5o:{type:"list",member:{locationName:"RoutingRule",type:"structure",required:["Redirect"],members:{Condition:{type:"structure",members:{HttpErrorCodeReturnedEquals:{},KeyPrefixEquals:{}}},Redirect:{type:"structure",members:{HostName:{},HttpRedirectCode:{},Protocol:{},ReplaceKeyPrefixWith:{},ReplaceKeyWith:{}}}}}},S75:{type:"structure",members:{ID:{},DisplayName:{}}},S76:{type:"list",member:{type:"structure",members:{Prefix:{}}},flattened:!0},S7o:{type:"list",member:{type:"structure",members:{Key:{},LastModified:{type:"timestamp"},ETag:{},Size:{type:"integer"},StorageClass:{},Owner:{shape:"S2k"}}},flattened:!0},S88:{type:"structure",members:{Grants:{shape:"S2n",locationName:"AccessControlList"},Owner:{shape:"S2k"}}}},paginators:{ListBuckets:{result_key:"Buckets"},ListMultipartUploads:{limit_key:"MaxUploads",more_results:"IsTruncated",output_token:["NextKeyMarker","NextUploadIdMarker"],input_token:["KeyMarker","UploadIdMarker"],result_key:["Uploads","CommonPrefixes"]},ListObjectVersions:{more_results:"IsTruncated",limit_key:"MaxKeys",output_token:["NextKeyMarker","NextVersionIdMarker"],input_token:["KeyMarker","VersionIdMarker"],result_key:["Versions","DeleteMarkers","CommonPrefixes"]},ListObjects:{more_results:"IsTruncated",limit_key:"MaxKeys",output_token:"NextMarker || Contents[-1].Key",input_token:"Marker",result_key:["Contents","CommonPrefixes"]},ListObjectsV2:{limit_key:"MaxKeys",output_token:"NextContinuationToken",input_token:"ContinuationToken",result_key:["Contents","CommonPrefixes"]},ListParts:{more_results:"IsTruncated",limit_key:"MaxParts",output_token:"NextPartNumberMarker",input_token:"PartNumberMarker",result_key:"Parts"}},waiters:{BucketExists:{delay:5,operation:"HeadBucket",maxAttempts:20,acceptors:[{expected:200,matcher:"status",state:"success"},{expected:301,matcher:"status",state:"success"},{expected:403,matcher:"status",state:"success"},{expected:404,matcher:"status",state:"retry"}]},BucketNotExists:{delay:5,operation:"HeadBucket",maxAttempts:20,acceptors:[{expected:404,matcher:"status",state:"success"}]},ObjectExists:{delay:5,operation:"HeadObject",maxAttempts:20,acceptors:[{expected:200,matcher:"status",state:"success"},{expected:404,matcher:"status",state:"retry"}]},ObjectNotExists:{delay:5,operation:"HeadObject",maxAttempts:20,acceptors:[{expected:404,matcher:"status",state:"success"}]}}};AWS.apiLoader.services.sts={},AWS.STS=AWS.Service.defineService("sts",["2011-06-15"]),_xamzrequire=function e(r,t,n){function i(o,a){if(!t[o]){if(!r[o]){var u="function"==typeof _xamzrequire&&_xamzrequire;if(!a&&u)return u(o,!0);if(s)return s(o,!0);var c=new Error("Cannot find module '"+o+"'");throw c.code="MODULE_NOT_FOUND",c}var d=t[o]={exports:{}};r[o][0].call(d.exports,function(e){var t=r[o][1][e];return i(t?t:e)},d,d.exports,e,r,t,n)}return t[o].exports}for(var s="function"==typeof _xamzrequire&&_xamzrequire,o=0;o<n.length;o++)i(n[o]);return i}({74:[function(e,r,t){var n=e("../core");n.util.update(n.STS.prototype,{credentialsFrom:function(e,r){return e?(r||(r=new n.TemporaryCredentials),r.expired=!1,r.accessKeyId=e.Credentials.AccessKeyId,r.secretAccessKey=e.Credentials.SecretAccessKey,r.sessionToken=e.Credentials.SessionToken,r.expireTime=e.Credentials.Expiration,r):null},assumeRoleWithWebIdentity:function(e,r){return this.makeUnauthenticatedRequest("assumeRoleWithWebIdentity",e,r)},assumeRoleWithSAML:function(e,r){return this.makeUnauthenticatedRequest("assumeRoleWithSAML",e,r)}})},{"../core":24}]},{},[74]);AWS.apiLoader.services.sts["2011-06-15"]={version:"2.0",metadata:{apiVersion:"2011-06-15",endpointPrefix:"sts",globalEndpoint:"sts.amazonaws.com",protocol:"query",serviceAbbreviation:"AWS STS",serviceFullName:"AWS Security Token Service",signatureVersion:"v4",xmlNamespace:"https://sts.amazonaws.com/doc/2011-06-15/"},operations:{AssumeRole:{input:{type:"structure",required:["RoleArn","RoleSessionName"],members:{RoleArn:{},RoleSessionName:{},Policy:{},DurationSeconds:{type:"integer"},ExternalId:{},SerialNumber:{},TokenCode:{}}},output:{resultWrapper:"AssumeRoleResult",type:"structure",members:{Credentials:{shape:"Sa"},AssumedRoleUser:{shape:"Sf"},PackedPolicySize:{type:"integer"}}},http:{}},AssumeRoleWithSAML:{input:{type:"structure",required:["RoleArn","PrincipalArn","SAMLAssertion"],members:{RoleArn:{},PrincipalArn:{},SAMLAssertion:{},Policy:{},DurationSeconds:{type:"integer"}}},output:{resultWrapper:"AssumeRoleWithSAMLResult",type:"structure",members:{Credentials:{shape:"Sa"},AssumedRoleUser:{shape:"Sf"},PackedPolicySize:{type:"integer"},Subject:{},SubjectType:{},Issuer:{},Audience:{},NameQualifier:{}}},http:{}},AssumeRoleWithWebIdentity:{input:{type:"structure",required:["RoleArn","RoleSessionName","WebIdentityToken"],members:{RoleArn:{},RoleSessionName:{},WebIdentityToken:{},ProviderId:{},Policy:{},DurationSeconds:{type:"integer"}}},output:{resultWrapper:"AssumeRoleWithWebIdentityResult",type:"structure",members:{Credentials:{shape:"Sa"},SubjectFromWebIdentityToken:{},AssumedRoleUser:{shape:"Sf"},PackedPolicySize:{type:"integer"},Provider:{},Audience:{}}},http:{}},DecodeAuthorizationMessage:{input:{type:"structure",required:["EncodedMessage"],members:{EncodedMessage:{}}},output:{resultWrapper:"DecodeAuthorizationMessageResult",type:"structure",members:{DecodedMessage:{}}},http:{}},GetCallerIdentity:{input:{type:"structure",members:{}},output:{resultWrapper:"GetCallerIdentityResult",type:"structure",members:{UserId:{},Account:{},Arn:{}}},http:{}},GetFederationToken:{input:{type:"structure",required:["Name"],members:{Name:{},Policy:{},DurationSeconds:{type:"integer"}}},output:{resultWrapper:"GetFederationTokenResult",type:"structure",members:{Credentials:{shape:"Sa"},FederatedUser:{type:"structure",required:["FederatedUserId","Arn"],members:{FederatedUserId:{},Arn:{}}},PackedPolicySize:{type:"integer"}}},http:{}},GetSessionToken:{input:{type:"structure",members:{DurationSeconds:{type:"integer"},SerialNumber:{},TokenCode:{}}},output:{resultWrapper:"GetSessionTokenResult",type:"structure",members:{Credentials:{shape:"Sa"}}},http:{}}},shapes:{Sa:{type:"structure",required:["AccessKeyId","SecretAccessKey","SessionToken","Expiration"],members:{AccessKeyId:{},SecretAccessKey:{},SessionToken:{},Expiration:{type:"timestamp"}}},Sf:{type:"structure",required:["AssumedRoleId","Arn"],members:{AssumedRoleId:{},Arn:{}}}}};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  __webpack_require__(171);
  __webpack_require__(172);
  __webpack_require__(173);
  return __webpack_require__(174).start({
    static: { root: "./public" }
  });
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let Development;
  return (Development = Caf.defClass(
    class Development extends __webpack_require__(33).Config {},
    function(Development, classSuper, instanceSuper) {
      this.prototype.Art = {
        Aws: {
          credentials: { accessKeyId: "blah", secretAccessKey: "blahblah" },
          region: "us-east-1",
          dynamoDb: { endpoint: "http://localhost:1337/localhost:8081" }
        },
        EryExtensions: {
          Pusher: {
            key: "ee6fca952b1a40c3a5fe",
            cluster: "us2",
            verbose: true,
            verifyConnection: true
          }
        },
        Ery: { tableNamePrefix: "chat-dev." }
      };
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let Chat, PusherPipelineMixin, DynamoDbPipeline;
  ({ PusherPipelineMixin, DynamoDbPipeline } = Caf.import(
    ["PusherPipelineMixin", "DynamoDbPipeline"],
    [
      global,
      __webpack_require__(155),
      __webpack_require__(215),
      __webpack_require__(99)
    ]
  ));
  return (Chat = Caf.defClass(
    class Chat extends PusherPipelineMixin(DynamoDbPipeline) {},
    function(Chat, classSuper, instanceSuper) {
      this.globalIndexes({ chatsByChatRoom: "chatRoom/createdAt" });
      this.addDatabaseFilters({
        user: "required trimmedString",
        message: "required trimmedString",
        chatRoom: "required trimmedString"
      });
      this.publicRequestTypes("get create chatsByChatRoom");
    }
  ));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  return __webpack_require__(223);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  let config, compactFlatten;
  ({ config, compactFlatten } = Caf.import(
    ["config", "compactFlatten"],
    [global, __webpack_require__(18)]
  ));
  return {
    start: (options = {}) => {
      config.location = "server";
      return __webpack_require__(49).start(
        { verbose: config.verbose, allowAllCors: true },
        options,
        {
          handlers: compactFlatten([
            __webpack_require__(73),
            __webpack_require__(74),
            options.handlers
          ])
        }
      );
    }
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(6);
Caf.defMod(module, () => {
  return __webpack_require__(78);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var Color, Matrix, Perimeter, Point, Rectangle, _package;

Color = __webpack_require__(80);

Point = __webpack_require__(25);

Rectangle = __webpack_require__(32);

Matrix = __webpack_require__(81);

Perimeter = __webpack_require__(82);

module.exports = [
  [Color, "isColor", "newColor", "color", "hslColor", "rgb256Color", "rgbColor", "colorNames", "colorNamesMap"], [Point, "point", "point0", "point1", "isPoint", "pointWithAspectRatioAndArea"], [Rectangle, "rect", "nothing", "everything", "isRect"], [Matrix, "matrix", "identityMatrix"], [Perimeter, "perimeter", "perimeter0"], {
    "package": _package = __webpack_require__(161),
    version: _package.version
  }
];


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31);

module.exports.includeInNamespace(__webpack_require__(182)).addModules({
  Base: __webpack_require__(19),
  Color: __webpack_require__(80),
  Matrix: __webpack_require__(81),
  Perimeter: __webpack_require__(82),
  Point: __webpack_require__(25),
  Rectangle: __webpack_require__(32)
});


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(5)).vivifySubnamespace('Art');

__webpack_require__(31);


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(175);

module.exports = __webpack_require__(52);


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var _package, isNode, nodeOnlyRequire;

isNode = __webpack_require__(0).isNode;

if (isNode) {
  nodeOnlyRequire = eval('require');
  global.AWS = nodeOnlyRequire('aws-sdk');
} else {
  __webpack_require__(185);
}

if (!self.AWS) {
  throw new Error("Art.Aws: global.AWS required\n\nPlease use one of the following:\n\n  > require 'art-aws/Client'\n  > require 'art-aws/Server'");
}

module.exports = [
  {
    config: __webpack_require__(10).config
  }, __webpack_require__(84), {
    "package": _package = __webpack_require__(162),
    version: _package.version
  }
];


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Aws4RestClient, BaseClass, Config, Elasticsearch, Promise, RestClient, clone, compactFlatten, config, defineModule, log, merge, mergeInto, object, parseUrl, peek, present, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

RestClient = __webpack_require__(21);

ref = __webpack_require__(0), compactFlatten = ref.compactFlatten, mergeInto = ref.mergeInto, clone = ref.clone, object = ref.object, log = ref.log, present = ref.present, defineModule = ref.defineModule, parseUrl = ref.parseUrl, peek = ref.peek, Promise = ref.Promise, merge = ref.merge;

config = (Config = __webpack_require__(10)).config;

Aws4RestClient = __webpack_require__(83);

BaseClass = __webpack_require__(3).BaseClass;

defineModule(module, Elasticsearch = (function(superClass) {
  extend(Elasticsearch, superClass);

  function Elasticsearch(options) {
    var ref1;
    Elasticsearch.__super__.constructor.apply(this, arguments);
    ref1 = this.options = merge(config.elasticsearch, options), this.host = ref1.host, this.index = ref1.index, this.type = ref1.type, this.parentField = ref1.parentField, this.routingField = ref1.routingField;
  }

  Elasticsearch.prototype.get = function(options) {
    return this.aws4RestClient.getJson(this.getEntryUrl(this.normalizeEntryRequestParams(options)));
  };

  Elasticsearch.getter({
    aws4RestClient: function() {
      return this._aws4RestClient || (this._aws4RestClient = new Aws4RestClient(merge({
        service: 'es'
      }, config.elasticsearch)));
    }
  });

  Elasticsearch.prototype.indicesGet = function(params) {};

  Elasticsearch.property("elasticsearchType elasticsearchIndex");

  Elasticsearch.prototype.getIndexUrl = function(options) {
    return this.host + "/" + options.index;
  };

  Elasticsearch.prototype.getIndexTypeUrl = function(options) {
    return (this.getIndexUrl(options)) + "/" + options.type;
  };

  Elasticsearch.prototype.getSearchUrl = function(options) {
    return (this.getIndexTypeUrl(options)) + "/_search";
  };

  Elasticsearch.prototype.getEntryBaseUrl = function(options) {
    return (this.getIndexUrl(options)) + "/" + options.type + "/" + options.id;
  };

  Elasticsearch.prototype.getEntryUrl = function(options) {
    return "" + (this.getEntryBaseUrl(options)) + (this.getEntryUrlParams(options));
  };

  Elasticsearch.prototype.getUpdateUrl = function(options) {
    return (this.getEntryBaseUrl(options)) + "/_update" + (this.getEntryUrlParams(options));
  };


  /*
  IN: options:
    data:         (object) field data
    routingField: (string) field-name to use for routing
    parentField:  (string) field-name for parent
   */

  Elasticsearch.prototype.getEntryUrlParams = function(options) {
    var data, params, parent, routing;
    data = options.data, routing = options.routing, parent = options.parent;
    params = compactFlatten([present(routing) ? "routing=" + (encodeURIComponent(present)) : void 0, present(parent) ? "parent=" + (encodeURIComponent(parent)) : void 0]);
    return "?" + (params.join("&"));
  };

  Elasticsearch.prototype.normalizeEntryRequestParams = function(params) {
    var data, out, parentValue, routingValue;
    data = params.data;
    out = clone(params);
    if (this.routingField) {
      if (!present(routingValue = data != null ? data[this.routingField] : void 0)) {
        throw new Error("routing field '" + this.routingField + "' is not present in data: " + (formattedInspect(data)));
      }
      out.routing = data[this.routingField];
    }
    if (this.parentField) {
      if (!present(parentValue = data != null ? data[this.parentField] : void 0)) {
        throw new Error("parent field '" + this.parentField + "' is not present in data: " + (formattedInspect(data)));
      }
      out.parent = data[this.parentField];
    }
    out.index = this.index;
    out.type = this.type;
    return out;
  };

  return Elasticsearch;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, Config, Promise, QuertyString, RestClient, S3, config, defineModule, isString, log, merge, parseUrl, peek, present, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

RestClient = __webpack_require__(21);

ref = __webpack_require__(0), isString = ref.isString, log = ref.log, present = ref.present, defineModule = ref.defineModule, parseUrl = ref.parseUrl, peek = ref.peek, Promise = ref.Promise, merge = ref.merge;

QuertyString = __webpack_require__(169);

QuertyString.escape || (QuertyString.escape = encodeURIComponent);

QuertyString.unescape || (QuertyString.unescape = decodeURIComponent);

config = (Config = __webpack_require__(10)).config;

BaseClass = __webpack_require__(3).BaseClass;

defineModule(module, S3 = (function(superClass) {
  extend(S3, superClass);

  function S3() {
    return S3.__super__.constructor.apply(this, arguments);
  }


  /*
  OUT: Promise -> {location, response}
  REJECTED: Promise -> {event, request}
   */

  S3.put = function(arg) {
    var bucket, data, headers, host, mimeType, objectName, onProgress, path, ref1, url;
    bucket = arg.bucket, objectName = arg.objectName, data = arg.data, onProgress = arg.onProgress, mimeType = arg.mimeType, headers = (ref1 = arg.headers) != null ? ref1 : {};
    bucket = S3._normalizeBucket(bucket);
    if (!bucket) {
      throw new Error("no bucket!");
    }
    host = bucket + ".s3.amazonaws.com";
    path = "/" + objectName;
    url = "https://" + host + path;
    if (present(mimeType)) {
      headers["Content-Type"] = mimeType;
    }
    return RestClient.put(url, data, {
      headers: headers,
      onProgress: onProgress
    }).then(function(response) {
      return {
        location: url,
        response: response
      };
    });
  };

  S3["delete"] = function(urlOrBucketKey) {
    var bucket, key, ref1;
    if (isString) {
      ref1 = S3.parseS3Url(urlOrBucketKey), bucket = ref1.bucket, key = ref1.key;
    } else {
      bucket = urlOrBucketKey.bucket, key = urlOrBucketKey.key;
    }
    return Promise.withCallback(function(callback) {
      return S3.getS3().deleteObject(merge({
        Bucket: S3._normalizeBucket(bucket),
        Key: key
      }), callback);
    });
  };

  S3._normalizeBucket = function(bucket) {
    return config.s3Buckets[bucket] || bucket;
  };

  S3._denormalizeBucket = function(bucket) {
    var k, ref1, v;
    ref1 = config.s3Buckets;
    for (k in ref1) {
      v = ref1[k];
      if (bucket === v) {
        return k;
      }
    }
    return bucket;
  };

  S3.classGetter({
    s3: function() {
      return this._s3 || (this._s3 = new AWS.S3(Config.getNormalizedConfig("S3")));
    }
  });

  S3.parseS3Url = function(url) {
    var host, pathName, ref1;
    ref1 = parseUrl(url), host = ref1.host, pathName = ref1.pathName;
    return {
      key: peek(pathName.split("/")),
      bucket: S3._denormalizeBucket(host.split(".s3.amazonaws")[0])
    };
  };

  S3.putSdk = function(arg) {
    var body, bucket, key;
    bucket = arg.bucket, key = arg.key, body = arg.body;
    return Promise.withCallback((function(_this) {
      return function(callback) {
        return _this.getS3().putObject({
          Bucket: _this._normalizeBucket(bucket),
          Key: key,
          Body: body
        }, callback);
      };
    })(this));
  };

  S3.copy = function(arg) {
    var fromBucket, key, params, toBucket;
    key = arg.key, toBucket = arg.toBucket, fromBucket = arg.fromBucket, params = arg.params;
    toBucket = this._normalizeBucket(toBucket);
    fromBucket = this._normalizeBucket(fromBucket);
    return Promise.withCallback((function(_this) {
      return function(callback) {
        return _this.getS3().copyObject(merge(params, {
          CopySource: fromBucket + "/" + key,
          Bucket: toBucket,
          Key: key,
          MetadataDirective: "COPY"
        }), callback);
      };
    })(this)).then(function(res) {
      return {
        copyObjectResult: res,
        url: "https://" + toBucket + ".s3.amazonaws.com/" + key
      };
    });
  };

  return S3;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Config, Promise, Sqs, each, merge, ref, sqsCommands,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), merge = ref.merge, Promise = ref.Promise, each = ref.each;

BaseClass = __webpack_require__(3).BaseClass;

sqsCommands = __webpack_require__(87).sqsCommands;

Config = __webpack_require__(10);

module.exports = Sqs = (function(superClass) {
  var emptyObject, identifyFunction;

  extend(Sqs, superClass);

  Sqs.singletonClass();

  function Sqs(options) {
    if (options == null) {
      options = {};
    }
    this._awsSqs = new AWS.SQS(merge(this.sqsConfig = Config.getNormalizedConfig("sqs", options)));
  }

  emptyObject = {};

  identifyFunction = function(a) {
    return a;
  };

  each(sqsCommands, function(arg, command) {
    var postprocess, preprocess, ref1, ref2;
    preprocess = (ref1 = arg.preprocess) != null ? ref1 : identifyFunction, postprocess = (ref2 = arg.postprocess) != null ? ref2 : identifyFunction;
    return Sqs.prototype[command] = function(params) {
      return Promise.withCallback((function(_this) {
        return function(callback) {
          return _this._awsSqs[command](preprocess(params != null ? params : emptyObject), function(err, data) {
            return callback(err, postprocess(data != null ? data : emptyObject));
          });
        };
      })(this));
    };
  });

  return Sqs;

})(BaseClass);


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var CreateTable, Foundation, TableApiBaseClass, compactFlatten, deepEachAll, isPlainObject, isString, log, lowerCamelCase, uniqueValues, wordsArray,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isPlainObject = Foundation.isPlainObject, log = Foundation.log, compactFlatten = Foundation.compactFlatten, isString = Foundation.isString, compactFlatten = Foundation.compactFlatten, deepEachAll = Foundation.deepEachAll, uniqueValues = Foundation.uniqueValues;

TableApiBaseClass = __webpack_require__(12);

module.exports = CreateTable = (function(superClass) {
  extend(CreateTable, superClass);

  function CreateTable() {
    this._translateLocalIndexes = bind(this._translateLocalIndexes, this);
    this._translateGlobalIndexes = bind(this._translateGlobalIndexes, this);
    this._translateParams = bind(this._translateParams, this);
    CreateTable.__super__.constructor.apply(this, arguments);
    this._requiredAttributes = {};
  }


  /*
  IN: params:
    table:      string (required)
    attributes:     see _translateAttributes
    globalIndexes:  see _translateGlobalIndexes
    key:            see _translateKey
    provisioning:   see _translateProvisioning
    localIndexes:   see _translateLocalIndexes
  
  NOTE:
    DynamoDb requires that attributes only list attributes used in the primary and index keys.
    BUT, _translateParams takes care of removing the extra fields from your list if present.
   */

  CreateTable.prototype._translateParams = function(params) {
    this._requiredAttributes = {};
    this._translateGlobalIndexes(params);
    this._translateLocalIndexes(params);
    this._translateKey(params, this._target);
    this._translateAttributes(params);
    this._translateProvisioning(params, this._target);
    return this._target;
  };


  /*
  IN:
    attributes:
      myHashKeyName:    'string'
      myRangeKeyName:   'string'
      myNumberAttrName: 'number'
      myBinaryAttrName: 'binary'
   */

  CreateTable.prototype._translateAttributes = function(params, requiredAttributes) {
    var attributeName, defs, type;
    if (requiredAttributes == null) {
      requiredAttributes = this._requiredAttributes;
    }
    defs = params.attributes || {
      id: 'string'
    };
    this._target.AttributeDefinitions = (function() {
      var i, len, ref, results;
      if (isPlainObject(defs)) {
        ref = Object.keys(requiredAttributes).sort();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          attributeName = ref[i];
          type = defs[attributeName];
          if (!type) {
            throw new Error("Required attribute definition for '" + attributeName + "'' not present. Please add it to 'attributes'.");
          }
          results.push({
            AttributeName: attributeName,
            AttributeType: this._normalizeConstant(type)
          });
        }
        return results;
      } else {
        return defs;
      }
    }).call(this);
    return this._target;
  };


  /*
  IN:
    key:
      myHashKeyName:  'hash'
      myRangeKeyName: 'range'
  
      OR: "hashKeyField"
      OR: "hashKeyField/rangeKeyField"
        NOTE: you can use any string format that matches /[_a-zA-Z0-9]+/g
   */

  CreateTable.prototype._translateKey = function(params, target) {
    var AttributeName, hashKeyField, i, k, keySchema, len, rangeKeyField, ref, v;
    if (target == null) {
      target = {};
    }
    keySchema = params.key || params.keySchema || {
      id: 'hash'
    };
    target.KeySchema = (function() {
      var ref, results;
      if (isPlainObject(keySchema)) {
        results = [];
        for (k in keySchema) {
          v = keySchema[k];
          results.push({
            AttributeName: k,
            KeyType: this._normalizeConstant(v)
          });
        }
        return results;
      } else if (isString(keySchema)) {
        ref = keySchema.split("/"), hashKeyField = ref[0], rangeKeyField = ref[1];
        return compactFlatten([
          {
            AttributeName: hashKeyField,
            KeyType: 'HASH'
          }, rangeKeyField ? {
            AttributeName: rangeKeyField,
            KeyType: 'RANGE'
          } : void 0
        ]);
      }
    }).call(this);
    ref = target.KeySchema;
    for (i = 0, len = ref.length; i < len; i++) {
      AttributeName = ref[i].AttributeName;
      this._requiredAttributes[AttributeName] = true;
    }
    return target;
  };


  /*
  IN:
    provisioning:
      read: 5
      write: 5
   */

  CreateTable.prototype._translateProvisioning = function(params, target) {
    var provisioning;
    if (target == null) {
      target = {};
    }
    provisioning = (params != null ? params.provisioning : void 0) || (params != null ? params.provisionedThroughput : void 0) || {};
    target.ProvisionedThroughput = {
      ReadCapacityUnits: provisioning.read || provisioning.readCapacityUnits || 1,
      WriteCapacityUnits: provisioning.write || provisioning.writeCapacityUnits || 1
    };
    return target;
  };


  /*
  IN:
    globalIndexes:
      myIndexName:
        "hashKey"           # see _translateKey
        "hashKey/rangeKey"  # see _translateKey
  
        OR
  
        key:          # see _translateKey
        projection:   # see _translateProjection
        provisioning: # see _translateProvisioning
   */

  CreateTable.prototype._translateGlobalIndexes = function(params) {
    var _target, globalIndexes, indexName, indexProps;
    if (globalIndexes = params != null ? params.globalIndexes : void 0) {
      this._target.GlobalSecondaryIndexes = (function() {
        var results;
        if (isPlainObject(globalIndexes)) {
          results = [];
          for (indexName in globalIndexes) {
            indexProps = globalIndexes[indexName];
            _target = {
              IndexName: indexName
            };
            if (isString(indexProps)) {
              this._translateKey({
                key: indexProps
              }, _target);
            } else {
              this._translateKey(indexProps, _target);
            }
            this._translateProjection(indexProps, _target);
            this._translateProvisioning(indexProps, _target);
            results.push(_target);
          }
          return results;
        } else {
          return globalIndexes;
        }
      }).call(this);
    }
    return this._target;
  };


  /*
  IN:
    localIndexes:
      myIndexName:
        "hashKey"           # see _translateKey
        "hashKey/rangeKey"  # see _translateKey
  
        OR
  
        key:          # see _translateKey
        projection:   # see _translateProjection
   */

  CreateTable.prototype._translateLocalIndexes = function(params) {
    var _target, indexName, indexProps, localIndexes;
    if (localIndexes = (params != null ? params.localIndexes : void 0) || (params != null ? params.localSecondaryIndexes : void 0)) {
      this._target.LocalSecondaryIndexes = (function() {
        var results;
        if (isPlainObject(localIndexes)) {
          results = [];
          for (indexName in localIndexes) {
            indexProps = localIndexes[indexName];
            _target = {
              IndexName: indexName
            };
            if (isString(indexProps)) {
              this._translateKey({
                key: indexProps
              }, _target);
            } else {
              this._translateKey(indexProps, _target);
            }
            this._translateProjection(indexProps, _target);
            results.push(_target);
          }
          return results;
        } else {
          return globalIndexes;
        }
      }).call(this);
    }
    return this._target;
  };

  CreateTable.prototype._translateProjection = function(params, target) {
    var out, projection;
    if (target == null) {
      target = {};
    }
    projection = (params != null ? params.projection : void 0) || {
      type: 'all'
    };
    target.Projection = out = {
      ProjectionType: this._normalizeConstant(projection.type, projection.attributes ? 'INCLUDE' : 'ALL')
    };
    if (projection.attributes) {
      out.NonKeyAttributes = projection.attributes;
    }
    return out;
  };

  return CreateTable;

})(TableApiBaseClass);


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var DeleteItem, Foundation, TableApiBaseClass, compactFlatten, deepEachAll, isNumber, isPlainObject, isString, log, lowerCamelCase, uniqueValues, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isPlainObject = Foundation.isPlainObject, log = Foundation.log, compactFlatten = Foundation.compactFlatten, isString = Foundation.isString, compactFlatten = Foundation.compactFlatten, deepEachAll = Foundation.deepEachAll, uniqueValues = Foundation.uniqueValues, isNumber = Foundation.isNumber;

TableApiBaseClass = __webpack_require__(12);

module.exports = DeleteItem = (function(superClass) {
  extend(DeleteItem, superClass);

  function DeleteItem() {
    return DeleteItem.__super__.constructor.apply(this, arguments);
  }


  /*
  IN: params:
    table:                  (required) string
    key:                    (required) see TableApiBaseClass._translateKey
    conditionExpression:  (optional) see TableApiBaseClass._translateConditionExpressionParam
    returnConsumedCapacity: (optional) see TableApiBaseClass._translateConsumedCapacity
   */

  DeleteItem.prototype._translateParams = function(params) {
    this._translateKey(params);
    this._translateOptionalParams(params);
    return this._target;
  };

  DeleteItem.prototype._translateOptionalParams = function(params) {
    this._translateConditionExpressionParam(params);
    this._translateConstantParam(params, "returnConsumedCapacity");
    this._translateConstantParam(params, "returnItemCollectionMetrics");
    return this._translateConstantParam(params, "returnValues");
  };

  return DeleteItem;

})(TableApiBaseClass);


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, GetItem, TableApiBaseClass, compactFlatten, deepEachAll, isNumber, isPlainObject, isString, log, lowerCamelCase, uniqueValues, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isPlainObject = Foundation.isPlainObject, log = Foundation.log, compactFlatten = Foundation.compactFlatten, isString = Foundation.isString, compactFlatten = Foundation.compactFlatten, deepEachAll = Foundation.deepEachAll, uniqueValues = Foundation.uniqueValues, isNumber = Foundation.isNumber;

TableApiBaseClass = __webpack_require__(12);

module.exports = GetItem = (function(superClass) {
  extend(GetItem, superClass);

  function GetItem() {
    return GetItem.__super__.constructor.apply(this, arguments);
  }


  /*
  IN: params:
    table:                  string (required)
   */

  GetItem.prototype._translateParams = function(params) {
    this._translateKey(params);
    this._translateOptionalParams(params);
    return this._target;
  };

  GetItem.prototype._translateOptionalParams = function(params) {
    this._translateConsistentRead(params);
    this._translateConsumedCapacity(params);
    return this._translateSelect(params);
  };

  return GetItem;

})(TableApiBaseClass);


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, PutItem, TableApiBaseClass, compactFlatten, deepEachAll, isNumber, isPlainObject, isString, log, lowerCamelCase, uniqueValues, wordsArray,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isPlainObject = Foundation.isPlainObject, log = Foundation.log, compactFlatten = Foundation.compactFlatten, isString = Foundation.isString, compactFlatten = Foundation.compactFlatten, deepEachAll = Foundation.deepEachAll, uniqueValues = Foundation.uniqueValues, isNumber = Foundation.isNumber;

TableApiBaseClass = __webpack_require__(12);

module.exports = PutItem = (function(superClass) {
  extend(PutItem, superClass);

  function PutItem() {
    this._translateItem = bind(this._translateItem, this);
    this._translateParams = bind(this._translateParams, this);
    return PutItem.__super__.constructor.apply(this, arguments);
  }


  /*
  IN: params:
    table:                  string (required)
   */

  PutItem.prototype._translateParams = function(params) {
    this._translateItem(params);
    this._translateOptionalParams(params);
    return this._target;
  };

  PutItem.prototype._translateItem = function(params) {
    var data, item;
    item = params.item, data = params.data;
    item || (item = data);
    if (!item) {
      throw new Error("item or data required");
    }
    this._target.Item = this._encodeItem(item);
    return this._target;
  };

  PutItem.prototype._translateOptionalParams = function(params) {
    this._translateConditionExpressionParam(params);
    this._translateConstantParam(params, "returnConsumedCapacity");
    this._translateConstantParam(params, "returnItemCollectionMetrics");
    return this._translateConstantParam(params, "returnValues");
  };

  return PutItem;

})(TableApiBaseClass);


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, Query, TableApiBaseClass, compactFlatten, deepEachAll, formattedInspect, isNumber, isPlainObject, isString, log, lowerCamelCase, uniqueValues, wordsArray,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isPlainObject = Foundation.isPlainObject, log = Foundation.log, compactFlatten = Foundation.compactFlatten, isString = Foundation.isString, compactFlatten = Foundation.compactFlatten, deepEachAll = Foundation.deepEachAll, uniqueValues = Foundation.uniqueValues, formattedInspect = Foundation.formattedInspect, isNumber = Foundation.isNumber;

TableApiBaseClass = __webpack_require__(12);

module.exports = Query = (function(superClass) {
  extend(Query, superClass);

  function Query() {
    this._translateParams = bind(this._translateParams, this);
    return Query.__super__.constructor.apply(this, arguments);
  }


  /*
  IN: params:
    table:                  string (required)
    index:                  string (optional) (sets the indexName)
    limit:                  number (NOTE: DynamoDb returns as many records as match and fit  within 1MB of data, AND, if specified, no more than 'limit' records)
    consistentRead:         true/false(default) (NOTE: not supported on global index queries)
    returnConsumedCapacity: /indexes|total|none/
    descending: true (optional)
  
    select:                 "*" or "count(*)" (must be exactly these strings)
                            OR a string listing one or more fields
                              Document Paths are supported:
                                http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html
                              Delimiter:
                                any sequence of 1-or-more non-legal-doc-path-characters is a legal delimiter
                                recommendation: use commas and/or whitespace
  
                            NOTE: If you want to return a field named '*' or 'count(*)', either request more than one field,
                              or add a space before or after the field-name so it doesn't exactly match one of those strings.
                            Default: DynamoDB defaults to allAttributes when accessing a table, and allProjectedAttributes when accessing an index.
  
    where:
       * NOTE: this replaces keyConditionExpression and related params
      partitionKeyName: exactEqualValue
      sortKeyName:
        testName: testValue or testValueArray
           * test names:
          eq
          lt
          lte
          gt
          gte
          between  # testValue is a length-2 array [a, b]; returns values >= a and <= b
          beginsWith
  
       * Examples:
      where: myPartitionKey: "abc123"
      where: myPartitionKey: "abc123", mySortKey: gte: "fooBar"
      where: myPartitionKey: "abc123", mySortKey: gte: "fooBar", descending: true
      where: myPartitionKey: "abc123", mySortKey: between: ["fooBar", "zooBar"]
  
    startKey:
       * NOTE: this replaces exclusiveStartKey
       * Used to get the next 'page' of records for a given query.
       * "Use the value that was returned for LastEvaluatedKey in the previous operation."
  
    #------------------
     * TODO
    #------------------
    filterExpression:
      TODO: this will use a simlar pattern to 'where'
      I think we should allow you to just do a normal DynamoDb filterExpression.
      The 'where' pattern is useful when you need to escape things. OH, there are no literals, so you couldn't
      use this if you had any literal value to include.
  
      This is interesting since I think you can use a doc-path for your value.
  
      I don't think that is allows for the 'where' syntax anyway, but it definitly is here.
      How do we distinguish between a doc-path and a value???
  
        gut:
          myField: eq: docPath myOtherField
  
        Where docPath a function that returns a non-plain object.
  
      Reference:
        http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html#ConditionExpressionReference
        http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults
  
      Idea to support AND, OR and NOT:
        [a, "or", b]
        [a, "and", b]
        ["not", a]
        [a, "or", b, "and", c]
  
      Ex:
        filterExpression: [
            foo: eq: "foo"
            "or"
            foo: eq: "bar"
          ]
      becomes:
        FilterExpression: 'foo = "foo" OR foo = "bar"'
  
    #------------------
     * DEPRICATED (by ArtAws) DYNAMODB PARAMS:
    #------------------
       * use: 'select'
      projectionExpression:
  
       * use: 'where'
      keyConditionExpression
      scanIndexForward
      expressionAttributeNames
      expressionAttributeValues
   */

  Query.prototype._translateParams = function(params) {
    this._translateOptionalParams(params);
    this._translateWhere(params);
    return this._target;
  };

  Query.prototype._translateLimit = function(params) {
    if (params.limit != null) {
      return this._target.Limit = params.limit;
    }
  };

  Query.prototype._translateExclusiveStartKey = function(params) {
    if (params.exclusiveStartKey) {
      return this._target.ExclusiveStartKey = params.exclusiveStartKey;
    }
  };

  Query.prototype._translateDescending = function(params) {
    if (params.descending) {
      return this._target.ScanIndexForward = false;
    }
  };

  Query.prototype._translateWhere = function(params) {
    var expr, where;
    where = params.where;
    if (where == null) {
      throw new Error("where param required");
    }
    if (expr = this._translateConditionExpression(where)) {
      this._target.KeyConditionExpression = expr;
    } else {
      if (where == null) {
        throw new Error("non-empty where param required: where: " + (formattedInspect(where)));
      }
    }
    return this._target;
  };

  Query.prototype._translateFilterExpression = function(params) {
    var expr, filterExpression;
    filterExpression = params.filterExpression;
    if (!filterExpression) {
      return;
    }
    if (expr = this._translateConditionExpression(filterExpression)) {
      this._target.FilterExpression = expr;
    }
    return this._target;
  };

  Query.prototype._translateOptionalParams = function(params) {
    this._translateIndexName(params);
    this._translateLimit(params);
    this._translateConsistentRead(params);
    this._translateConsumedCapacity(params);
    this._translateDescending(params);
    this._translateExclusiveStartKey(params);
    this._translateSelect(params);
    return this._target;
  };

  return Query;

})(TableApiBaseClass);


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [__webpack_require__(53)];


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, TableApiBaseClass, UpdateItem, compactFlatten, deepEachAll, isNumber, isPlainObject, isString, log, lowerCamelCase, merge, uniqueValues, wordsArray,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

lowerCamelCase = Foundation.lowerCamelCase, wordsArray = Foundation.wordsArray, isPlainObject = Foundation.isPlainObject, log = Foundation.log, compactFlatten = Foundation.compactFlatten, isString = Foundation.isString, compactFlatten = Foundation.compactFlatten, deepEachAll = Foundation.deepEachAll, uniqueValues = Foundation.uniqueValues, isNumber = Foundation.isNumber, merge = Foundation.merge;

TableApiBaseClass = __webpack_require__(12);

module.exports = UpdateItem = (function(superClass) {
  extend(UpdateItem, superClass);

  function UpdateItem() {
    this._translateUpdateExpression = bind(this._translateUpdateExpression, this);
    this._translateParams = bind(this._translateParams, this);
    return UpdateItem.__super__.constructor.apply(this, arguments);
  }


  /*
  IN: params:
    table:                  string (required)
    key:
    item/set:               object(fields -> values): set ()
    add:                    object(fields -> values): add value to existing value (or 0, if adding a number) (using UpdateExpression's 'ADD' action)
    defaults/setDefault:    object(fields -> values): set if not present (using UpdateExpression's 'SET' and 'if_not_exists')
   */

  UpdateItem.prototype._translateParams = function(params) {
    this._translateKey(params);
    this._translateUpdateExpression(params);
    this._translateOptionalParams(params);
    return this._target;
  };


  /*
  item: plainObject
     * equivelent to updates: myAttr: set: myValue
     * for myAttr, myValue of plainObject
  OR
  
  updates:
    attributeName: set: myValue
  
    myNumberAttr: add: 10 # adds 10 (0 is the default initial value if not already set)
    mySetAttr:    add: <set> # sets mySetAttr to the merged sets
  
    attributeName: delete: # delete an element from a set
    attributeName: "remove" # remove the attribute
   */

  UpdateItem.prototype._translateUpdateExpression = function(params) {
    var actions, add, addActions, addExpression, attributeAlias, attributeName, attributeValue, data, defaults, item, remove, removeAttributes, removeExpression, set, setDefault, setDefaultActions, setExpression, uniqueId, updateExpression, valueAlias;
    item = params.item, set = params.set, data = params.data, add = params.add, remove = params.remove, setDefault = params.setDefault, defaults = params.defaults;
    item = merge(item, set, data);
    defaults = merge(setDefault, defaults);
    actions = (function() {
      var results;
      results = [];
      for (attributeName in item) {
        attributeValue = item[attributeName];
        if (!(attributeValue !== void 0)) {
          continue;
        }
        uniqueId = this._getNextUniqueExpressionAttributeId(this._target);
        attributeAlias = "#attr" + uniqueId;
        valueAlias = ":val" + uniqueId;
        this._addExpressionAttributeName(attributeAlias, attributeName);
        this._addExpressionAttributeValue(valueAlias, attributeValue);
        results.push(attributeAlias + " = " + valueAlias);
      }
      return results;
    }).call(this);
    setDefaultActions = (function() {
      var results;
      results = [];
      for (attributeName in defaults) {
        attributeValue = defaults[attributeName];
        if (!(attributeValue !== void 0)) {
          continue;
        }
        uniqueId = this._getNextUniqueExpressionAttributeId(this._target);
        attributeAlias = "#attr" + uniqueId;
        valueAlias = ":val" + uniqueId;
        this._addExpressionAttributeName(attributeAlias, attributeName);
        this._addExpressionAttributeValue(valueAlias, attributeValue);
        results.push(attributeAlias + " = if_not_exists(" + attributeAlias + ", " + valueAlias + ")");
      }
      return results;
    }).call(this);
    addActions = (function() {
      var ref, results;
      ref = add || {};
      results = [];
      for (attributeName in ref) {
        attributeValue = ref[attributeName];
        if (!(attributeValue !== void 0)) {
          continue;
        }
        uniqueId = this._getNextUniqueExpressionAttributeId(this._target);
        attributeAlias = "#attr" + uniqueId;
        valueAlias = ":val" + uniqueId;
        this._addExpressionAttributeName(attributeAlias, attributeName);
        this._addExpressionAttributeValue(valueAlias, attributeValue);
        results.push(attributeAlias + " " + valueAlias);
      }
      return results;
    }).call(this);
    removeAttributes = (function() {
      var i, len, ref, results;
      ref = remove || [];
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        attributeName = ref[i];
        uniqueId = this._getNextUniqueExpressionAttributeId(this._target);
        attributeAlias = "#attr" + uniqueId;
        this._addExpressionAttributeName(attributeAlias, attributeName);
        results.push(attributeAlias);
      }
      return results;
    }).call(this);
    if (!(actions.length + setDefaultActions.length + addActions.length > 0)) {
      throw new Error("at least one 'item/set/data', 'add' or 'defaults/setDefault' entry required");
    }
    if (actions.length + setDefaultActions.length > 0) {
      setExpression = "SET " + (compactFlatten([actions, setDefaultActions]).join(', '));
    }
    if (addActions.length > 0) {
      addExpression = "ADD " + (addActions.join(', '));
    }
    if (removeAttributes.length > 0) {
      removeExpression = "REMOVE " + (removeAttributes.join(', '));
    }
    updateExpression = compactFlatten([setExpression, addExpression, removeExpression]).join(' ');
    this._target.UpdateExpression = updateExpression;
    return this._target;
  };

  UpdateItem.prototype._translateOptionalParams = function(params) {
    this._translateConditionExpressionParam(params);
    this._translateConstantParam(params, "returnConsumedCapacity");
    this._translateConstantParam(params, "returnItemCollectionMetrics");
    return this._translateConstantParam(params, "returnValues", "updatedNew");
  };

  return UpdateItem;

})(TableApiBaseClass);


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(54);

module.exports.includeInNamespace(__webpack_require__(186)).addModules({
  Aws4RestClient: __webpack_require__(83),
  Config: __webpack_require__(10),
  DynamoDb: __webpack_require__(84),
  Elasticsearch: __webpack_require__(187),
  S3: __webpack_require__(188),
  Sqs: __webpack_require__(189),
  StreamlinedSqsApi: __webpack_require__(87)
});

__webpack_require__(85);


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(5)).vivifySubnamespace('Art');

__webpack_require__(54);


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var Components,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(88)).addNamespace('Components', Components = (function(superClass) {
  extend(Components, superClass);

  function Components() {
    return Components.__super__.constructor.apply(this, arguments);
  }

  return Components;

})(Neptune.PackageNamespace));


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = BaseObject = (function(superClass) {
  extend(BaseObject, superClass);

  function BaseObject() {
    return BaseObject.__super__.constructor.apply(this, arguments);
  }

  return BaseObject;

})(__webpack_require__(56));


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  createWithPostCreate: __webpack_require__(56).createWithPostCreate
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var defineModule, each, isPlainObject, log, lowerCamelCase, object, ref, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, object = ref.object, upperCamelCase = ref.upperCamelCase, lowerCamelCase = ref.lowerCamelCase, each = ref.each, isPlainObject = ref.isPlainObject;

defineModule(module, function() {
  return function(superClass) {
    var DeclarableMixin;
    return DeclarableMixin = (function(superClass1) {
      extend(DeclarableMixin, superClass1);

      function DeclarableMixin() {
        return DeclarableMixin.__super__.constructor.apply(this, arguments);
      }


      /*
        define a declarable field
      
        IN:
          map:
            key: name: string
            value: true-ish OR
              options:
                preprocess: (v) -> newV
                validate:   (v) -> truthish
                extendable: defaultValue
                  If present, this is an extendable property.
                  See: @extendableProperty
                  passed to: @extendableProperty "#{key}": options.extendable
              NOTE: validate is evaluated BEFORE preprocess
      
        EFFECT:
          creates:
      
             * class declarator function, with preprocessing
            @name: (...)->
      
             * class getter-function
            @getName: ->
      
             * instance-getter
            @getter name: ->
       */

      DeclarableMixin.declarable = function(map) {
        return each(map, (function(_this) {
          return function(options, name) {
            var extendable, getter, getterName, internalName, obj, preprocess, ucProp, validate;
            if (isPlainObject(options)) {
              preprocess = options.preprocess, validate = options.validate, extendable = options.extendable, getter = options.getter;
            }
            preprocess || (preprocess = function(v) {
              return v;
            });
            validate || (validate = function() {
              return true;
            });
            name = lowerCamelCase(name);
            ucProp = upperCamelCase(name);
            internalName = _this.propInternalName(name);
            getterName = "get" + ucProp;
            if (extendable) {
              return _this.extendableProperty((
                obj = {},
                obj["" + name] = extendable,
                obj
              ));
            } else {
              _this[name] = function(value) {
                if (!validate(value)) {
                  throw new Error("invalid value: " + (formattedInspect({
                    value: value,
                    name: name
                  })));
                }
                return this[internalName] = preprocess(value);
              };
              _this[getterName] = getter || function() {
                return this[internalName];
              };
              return _this.addGetter(name, function() {
                return this["class"][internalName];
              });
            }
          };
        })(this));
      };

      return DeclarableMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(204);

module.exports.includeInNamespace(__webpack_require__(201)).addModules({
  BaseClass: __webpack_require__(56),
  BaseObject: __webpack_require__(200),
  DeclarableMixin: __webpack_require__(202),
  ExtendablePropertyMixin: __webpack_require__(91),
  WebpackHotLoader: __webpack_require__(92)
});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var ClassSystem,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.ClassSystem', ClassSystem = (function(superClass) {
  extend(ClassSystem, superClass);

  function ClassSystem() {
    return ClassSystem.__super__.constructor.apply(this, arguments);
  }

  ClassSystem.version = __webpack_require__(287).version;

  return ClassSystem;

})(Neptune.PackageNamespace));


/***/ }),
/* 205 */
/***/ (function(module, exports) {

var CommunicationStatus;

module.exports = CommunicationStatus = (function() {
  var communicationStatuses, k, ref, v;

  function CommunicationStatus() {}

  CommunicationStatus.communicationStatuses = communicationStatuses = {

    /*
    status: success
    
    * An unqualified success.
    * I guess it could be qualified, with additional information in another field,
      but the 'expected' data should be present.
     */
    success: {
      httpStatus: 200

      /*
      status: missing
      
      * The request was properly formatted.
      * There were no network errors.
      * There were no server errors.
      * The only problem is the server could not find the requested resource.
       */
    },
    missing: {
      httpStatus: 404,
      failure: true

      /*
      status: clientFailure
      
      * The server rejected the request.
      * There is something wrong with the client's request.
      * It's up to the client to fix the problem.
      * This includes mal-formed requests as well as invalid data.
      * all 4xx errors except 404
      NOTE: 404 is not necessarilly a client NOR server error, therefor it's status: missing
       */
    },
    clientFailure: {
      httpStatus: 400,
      clientFailure: true,
      failure: true

      /*
      status: notAuthorized
      
      * The resource exists, but the client is not allowed to access it.
      
      This is a form of clientFailure because the client could possibly change
      something in the request to make it work.
       */
    },
    clientFailureNotAuthorized: {
      httpStatus: 403,
      clientFailure: true,
      failure: true

      /*
      status: serverFailure
      
      * There is something broken on the server.
      * There is nothing the client can do to solve this problem.
      
      SBD: Possble rename to 'internalFailure': Reason: so it also makes sense for local library calls.
        If something is failing in a local library, serverFailure makes less sense.
        Then again, local libraries pretty-much don't need communicationStatus at all - they
        can use 'throw' or 'promise.reject'
       */
    },
    serverFailure: {
      httpStatus: 500,
      failure: true,
      serverFailure: true

      /*
      status: networkFailure
      
      * The remote-server could not be reached.
      * There is nothing the code running on the Client NOR Server can do to fix this.
      * There is something wrong with the network between the client computer and the server.
      * The client can attempt to retry at a later time and it might magically work.
      * The client-side-humans or server-side-humans can attempt to fix the network.
      * The failure may be one of the following:
        a) the local computer has no internet connection OR
        b) the internet is in a shitstorm ;) OR
        c) there is an network problem within the Servers' facility.
       */
    },
    networkFailure: {
      failure: true

      /*
      status: aborted
      
      * the request was aborted, AS REQUESTED BY THE CLIENT
       */
    },
    aborted: {
      failure: true

      /*
      status: pending
      
      * The request is proceeding.
      * No errors so far.
       */
    },
    pending: {},

    /*
    status: failure
    
    Use when the same code is used clientSide and serverSide.
    
    Server code should convert :failure into :serverFailure when sending
    a failing reply to a client.
     */
    failure: {
      httpStatus: 500,
      failure: true
    }
  };

  ref = CommunicationStatus.communicationStatuses;
  for (k in ref) {
    v = ref[k];
    CommunicationStatus[k] = k;
  }

  CommunicationStatus.isClientFailure = function(status) {
    var ref1;
    return !!((ref1 = communicationStatuses[status]) != null ? ref1.clientFailure : void 0);
  };

  CommunicationStatus.isServerFailure = function(status) {
    var ref1;
    return !!((ref1 = communicationStatuses[status]) != null ? ref1.serverFailure : void 0);
  };

  CommunicationStatus.isFailure = function(status) {
    var ref1;
    return !!((ref1 = communicationStatuses[status]) != null ? ref1.failure : void 0);
  };

  CommunicationStatus.isSuccess = function(status) {
    return status === "success";
  };


  /*
  OUT: true if status is a valid status-string
   */

  CommunicationStatus.validStatus = function(status) {
    return CommunicationStatus[status] === status;
  };

  CommunicationStatus.decodeHttpStatus = function(httpStatus) {
    var status;
    if (httpStatus == null) {
      return {
        status: CommunicationStatus.networkFailure,
        message: "network failure"
      };
    }
    status = (function() {
      switch (httpStatus / 100 | 0) {
        case 2:
          return this.success;
        case 3:
          return this.missing;
        case 4:
          switch (httpStatus) {
            case 403:
              return this.clientFailureNotAuthorized;
            case 404:
              return this.missing;
            default:
              return this.clientFailure;
          }
          break;
        case 5:
          switch (httpStatus) {
            case 502:
            case 503:
            case 504:
              return this.networkFailure;
            case 501:
            case 505:
            case 530:
              return this.clientFailure;
            case 500:
              return this.serverFailure;
          }
      }
    }).call(CommunicationStatus);
    if (status == null) {
      throw new Error("unhandled httpStatus: " + httpStatus);
    }
    return {
      status: status,
      httpStatus: httpStatus,
      message: status + " (" + httpStatus + ")"
    };
  };

  CommunicationStatus.encodeHttpStatus = function(status) {
    var httpStatus, ref1;
    if (!(httpStatus = (ref1 = CommunicationStatus.communicationStatuses[status]) != null ? ref1.httpStatus : void 0)) {
      throw new Error("There is no valid HttpStatus for " + status + ".");
    }
    return httpStatus;
  };

  return CommunicationStatus;

})();


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(93);

module.exports.includeInNamespace(__webpack_require__(205));


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(5)).vivifySubnamespace('Art');

__webpack_require__(93);


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [
  {
    Config: __webpack_require__(94)
  }, __webpack_require__(96)
];


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, ConfigRegistry, Configurable, EventedMixin, deepMerge, defineModule, isPlainObject, log, merge, mergeInto, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, merge = ref.merge, isPlainObject = ref.isPlainObject, mergeInto = ref.mergeInto, deepMerge = ref.deepMerge, isPlainObject = ref.isPlainObject;

BaseClass = __webpack_require__(3).BaseClass;

ConfigRegistry = __webpack_require__(34);

EventedMixin = __webpack_require__(114).EventedMixin;


/*

TO USE:
1) Inherit from Configurable and
2) OPTIONAL: call @defaults to set configuration defaults
3) OPTIONAL, override one of:
  @configure
  @preprocessConfig
  @configured
 */

defineModule(module, Configurable = (function(superClass) {
  extend(Configurable, superClass);

  function Configurable() {
    return Configurable.__super__.constructor.apply(this, arguments);
  }

  Configurable.abstractClass();

  Configurable.defaults = function() {
    var defaults;
    defaults = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return this.defaultConfig = merge.apply(null, defaults);
  };

  Configurable.getDefaultConfig = function() {
    return this.defaultConfig;
  };

  Configurable.reset = function() {
    var k, ref1, ref2, v;
    if (this.config) {
      ref1 = this.config;
      for (k in ref1) {
        v = ref1[k];
        delete this.config[k];
      }
    } else {
      this.config = {};
    }
    if (this.defaultConfig) {
      mergeInto(this.config, this.defaultConfig);
    }
    if ((ref2 = this.namespace) != null) {
      ref2.config = this.config;
    }
    return this.config;
  };

  Configurable.getInspectedObjects = function() {
    var obj;
    return (
      obj = {},
      obj["" + (this.getConfigurationPathString())] = this.config,
      obj
    );
  };

  Configurable.getPathedDefaultConfig = function() {
    var obj;
    return (
      obj = {},
      obj["" + (this.getConfigurationPathString())] = this.getDefaultConfig(),
      obj
    );
  };

  Configurable.configure = function(globalConfig) {
    var obj;
    globalConfig.verbose && log({
      Configurable: (
        obj = {},
        obj["" + (this.getConfigurationPathString())] = this.getConfigurationFromPath(globalConfig),
        obj
      )
    });
    this.reset();
    return mergeInto(this.config, this.getConfigurationFromPath(globalConfig));
  };

  Configurable.on = function() {
    var a, ref1;
    a = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref1 = this.getSingleton()).on.apply(ref1, a);
  };

  Configurable.configured = function() {
    return this.getSingleton().handleEvent("configured");
  };

  Configurable.getConfigurationPath = function() {
    var _Configurable, _Neptune, i, path, ref1;
    ref1 = this.getNamespacePath().split('.'), _Neptune = ref1[0], path = 3 <= ref1.length ? slice.call(ref1, 1, i = ref1.length - 1) : (i = 1, []), _Configurable = ref1[i++];
    return path;
  };

  Configurable.getConfigurationPathString = function() {
    return this.getConfigurationPath().join('.');
  };

  Configurable.getConfigurationFromPath = function(config, path) {
    var el, i, len;
    if (path == null) {
      path = this.getConfigurationPath();
    }
    for (i = 0, len = path.length; i < len; i++) {
      el = path[i];
      config = config != null ? config[el] : void 0;
    }
    return config;
  };

  Configurable._register = function() {
    this.reset();
    return ConfigRegistry.registerConfigurable(this);
  };

  Configurable.postCreateConcreteClass = function(arg) {
    var hotReloaded;
    hotReloaded = arg.hotReloaded;
    if (hotReloaded) {
      ConfigRegistry.reload();
    } else {
      this._register();
    }
    return Configurable.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };

  return Configurable;

})(EventedMixin(BaseClass)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(211);

module.exports.includeInNamespace(__webpack_require__(208)).addModules({
  ConfigRegistry: __webpack_require__(34),
  Configurable: __webpack_require__(209),
  Configuration: __webpack_require__(94),
  Lib: __webpack_require__(95),
  Main: __webpack_require__(96)
});


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var Config,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.Config', Config = (function(superClass) {
  extend(Config, superClass);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }

  Config.version = __webpack_require__(289).version;

  return Config;

})(Neptune.PackageNamespace));


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, EpochClass, Promise, defineModule, evalAndThrowErrorsOutOfStack, inspect, ref, requestAnimationFrame,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(0), defineModule = ref.defineModule, inspect = ref.inspect, Promise = ref.Promise, requestAnimationFrame = ref.requestAnimationFrame, evalAndThrowErrorsOutOfStack = ref.evalAndThrowErrorsOutOfStack;

BaseClass = __webpack_require__(3).BaseClass;

defineModule(module, EpochClass = (function(superClass) {
  extend(EpochClass, superClass);

  function EpochClass(options) {
    if (options == null) {
      options = {};
    }
    EpochClass.__super__.constructor.apply(this, arguments);
    this._emptyQueueAfterProcessing = !!options.emptyQueueAfterProcessing;
    this._queuedItems = [];
    this._nextReadyQueue = [];
    this._epochQueued = false;
    this._processingEpoch = false;
    this._epochCount = 0;
    this._frameSecond = 0;
  }

  EpochClass.getter("processingEpoch epochQueued epochCount emptyQueueAfterProcessing frameSecond", {
    epochLength: function() {
      return this._queuedItems.length;
    }
  });

  EpochClass.prototype.updateGlobalCounts = function() {};


  /*
  This guarantess there will be a next "ready" event.
  If there were no setStates this epoch, then there won't be a next "ready" - unless you use this method.
  
  IN:
    f: an optional function to invoke on-next-ready
      mostly this is provided as a shortcut:
        @onNextReady =>
      is directly equivelent to:
        @onNextReady().then =>
  
  OUT: promise.then (result of calling f() or null if no f) ->
   */

  EpochClass.prototype.onNextReady = function(f, forceNextEpoch, passThroughArgument) {
    if (forceNextEpoch == null) {
      forceNextEpoch = true;
    }
    if (forceNextEpoch && !this._processingEpoch) {
      this.queueNextEpoch();
    }
    return new Promise((function(_this) {
      return function(resolve) {
        return _this._nextReadyQueue.push(function() {
          return resolve(f ? f(passThroughArgument) : passThroughArgument);
        });
      };
    })(this));
  };

  EpochClass.prototype._ready = function() {
    var f, i, len, nrq, results;
    if (!((nrq = this._nextReadyQueue).length > 0)) {
      return;
    }
    this._nextReadyQueue = [];
    results = [];
    for (i = 0, len = nrq.length; i < len; i++) {
      f = nrq[i];
      results.push(evalAndThrowErrorsOutOfStack((function(_this) {
        return function() {
          return f();
        };
      })(this)));
    }
    return results;
  };

  EpochClass.prototype.queueItem = function(item) {
    if (item) {
      this._queuedItems.push(item);
      this.queueNextEpoch();
    }
    return item;
  };

  EpochClass.prototype.isItemQueued = function(item) {
    return indexOf.call(this._queuedItems, item) >= 0;
  };

  EpochClass.prototype.queueNextEpoch = function() {
    if (!this._epochQueued) {
      this._epochQueued = true;
      return requestAnimationFrame((function(_this) {
        return function(frameTimeMs) {
          _this._frameSecond = frameTimeMs / 1000;
          _this._epochQueued = false;
          return _this.processEpoch();
        };
      })(this));
    }
  };

  EpochClass.prototype.flushEpochNow = function() {
    return this.processEpoch();
  };

  EpochClass.prototype.processEpoch = function() {
    var items;
    this._processingEpoch = true;
    items = this._queuedItems;
    if (this._emptyQueueAfterProcessing) {
      this.processEpochItemsWithErrorHandling(items);
      this._queuedItems = [];
    } else {
      this._queuedItems = [];
      this.processEpochItemsWithErrorHandling(items);
    }
    this._processingEpoch = false;
    this._epochCount++;
    return this._ready();
  };

  EpochClass.prototype.processEpochItemsWithErrorHandling = function(items) {
    return evalAndThrowErrorsOutOfStack((function(_this) {
      return function() {
        return _this.processEpochItems(items);
      };
    })(this));
  };

  EpochClass.prototype.processEpochItems = function(items) {
    var i, item, len, results;
    results = [];
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      results.push(item());
    }
    return results;
  };

  return EpochClass;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(98);

module.exports.addModules({
  EpochClass: __webpack_require__(212)
});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var Art, Neptune,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Neptune = __webpack_require__(5);

module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
  extend(Art, superClass);

  function Art() {
    return Art.__super__.constructor.apply(this, arguments);
  }

  return Art;

})(Neptune.Base));

__webpack_require__(98);


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(220);


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtAws, DynamoDb, DynamoDbPipeline, KeyFieldsMixin, Pipeline, Promise, UpdateAfterMixin, Validator, compactFlatten, compare, deepMerge, defineModule, formattedInspect, inspect, isFunction, isPlainObject, isString, log, merge, mergeInto, mergeIntoUnless, object, objectWithExistingValues, pipelines, present, ref, ref1, withSort,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, mergeInto = ref.mergeInto, Promise = ref.Promise, object = ref.object, isPlainObject = ref.isPlainObject, deepMerge = ref.deepMerge, compactFlatten = ref.compactFlatten, inspect = ref.inspect, log = ref.log, merge = ref.merge, compare = ref.compare, Validator = ref.Validator, isString = ref.isString, isFunction = ref.isFunction, withSort = ref.withSort, formattedInspect = ref.formattedInspect, mergeIntoUnless = ref.mergeIntoUnless, objectWithExistingValues = ref.objectWithExistingValues, present = ref.present, isString = ref.isString;

ref1 = __webpack_require__(13), Pipeline = ref1.Pipeline, KeyFieldsMixin = ref1.KeyFieldsMixin, pipelines = ref1.pipelines, UpdateAfterMixin = ref1.UpdateAfterMixin;

DynamoDb = (ArtAws = __webpack_require__(52)).DynamoDb;

defineModule(module, DynamoDbPipeline = (function(superClass) {
  extend(DynamoDbPipeline, superClass);

  function DynamoDbPipeline() {
    return DynamoDbPipeline.__super__.constructor.apply(this, arguments);
  }

  DynamoDbPipeline.abstractClass();

  DynamoDbPipeline.createTablesForAllRegisteredPipelines = function() {
    var name, pipeline, promises;
    promises = (function() {
      var results;
      results = [];
      for (name in pipelines) {
        pipeline = pipelines[name];
        if (isFunction(pipeline.createTable)) {
          results.push(pipeline.createTable());
        }
      }
      return results;
    })();
    return Promise.all(promises);
  };

  DynamoDbPipeline.classGetter({
    dynamoDb: function() {
      return DynamoDb.singleton;
    }
  });

  DynamoDbPipeline.globalIndexes = function(globalIndexes) {
    this._globalIndexes = globalIndexes;
    return this.query(this._getAutoDefinedQueries(globalIndexes));
  };

  DynamoDbPipeline.localIndexes = function(localIndexes) {
    this._localIndexes = localIndexes;
    return this.query(this._getAutoDefinedQueries(localIndexes));
  };

  DynamoDbPipeline.getter({
    globalIndexes: function() {
      return this._options.globalIndexes || this["class"]._globalIndexes;
    },
    localIndexes: function() {
      return this._options.localIndexes || this["class"]._localIndexes;
    }
  });

  DynamoDbPipeline.getter({
    status: function() {
      return this._vivifyTable().then(function() {
        return "OK: table exists and is reachable";
      })["catch"](function() {
        return "ERROR: could not connect to the table";
      });
    },
    dynamoDb: function() {
      return DynamoDb.singleton;
    }
  });

  DynamoDbPipeline.prototype.queryDynamoDb = function(params) {
    return this.dynamoDb.query(merge(params, {
      table: this.tableName
    }));
  };

  DynamoDbPipeline.prototype.scanDynamoDb = function(params) {
    return this.dynamoDb.scan(merge(params, {
      table: this.tableName
    }));
  };

  DynamoDbPipeline.prototype.withDynamoDb = function(action, params) {
    return this.dynamoDb[action](merge(params, {
      table: this.tableName
    }));
  };

  DynamoDbPipeline.handlers({
    createTable: function() {
      return this._vivifyTable().then(function() {
        return {
          message: "success"
        };
      });
    },
    initialize: function(request) {
      return this._vivifyTable().then(function() {
        return {
          message: "success"
        };
      });
    },
    getInitializeParams: function() {
      return this.createTableParams;
    },
    get: function(request) {
      return this._artEryToDynamoDbRequest(request, {
        requiresKey: true,
        then: (function(_this) {
          return function(params) {
            return _this.dynamoDb.getItem(params).then(function(result) {
              return result.item || request.missing();
            });
          };
        })(this)
      });
    },
    getAll: function(request) {
      return this.scanDynamoDb().then(function(arg) {
        var items;
        items = arg.items;
        log({
          getAll: {
            items: items != null ? items.length : void 0
          }
        });
        return items;
      });
    },

    /*
    TODO: make create fail if the item already exists
      WHY? we have after-triggers that need to only trigger on a real create - not a replace
      AND filters like ValidationFilter assume create is a real create and update is a real update...
      NOTE: replace should be considered an update...
      NOTE: We have createOrUpdate if you really want both.
    
      ADD "replaceOk" prop
        Only replace existing items if explicitly requested:
        {replaceOk} = request.props
        This will mostly be used internally. Use createOrUpdate for
        that behavior externally.
    
    HOW to do 'replaceOk':
    
      http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html
      To prevent a new item from replacing an existing item, use a conditional
      expression that contains the attribute_not_exists function with the name of
      the attribute being used as the partition key for the table. Since every
      record must contain that attribute, the attribute_not_exists function will
      only succeed if no matching item exists.
     */
    create: function(request) {
      return this._artEryToDynamoDbRequest(request, {
        then: (function(_this) {
          return function(params) {
            return _this.dynamoDb.putItem(params).then(function() {
              return request.data;
            });
          };
        })(this)
      });
    },

    /*
    IN: response.props:
      createOk: true/falsish
        NOTE:
          A) can only use on tables which don't auto-generate-ids
    
    OUT:
      if record didn't exist:
        if createOk
          record was created
        response.status == missing
      else
        data: all fields with their current values (returnValues: 'allNew')
    
    TODO:
      support request.props.add and request.props.setDefault
        for both: requireOriginatedOnServer
     */
    update: function(request) {
      var createOk;
      createOk = request.props.createOk;
      return request.requireServerOriginIf(createOk, "to use createOk").then((function(_this) {
        return function() {
          return request.rejectIf(createOk && _this.getKeyFieldsString() === 'id', "createOk not available on tables with auto-generated-ids");
        };
      })(this)).then((function(_this) {
        return function() {
          return _this._artEryToDynamoDbRequest(request, {
            mustExist: !createOk,
            requiresKey: true,
            then: function(dynamoDbParams) {
              return _this.dynamoDb.updateItem(dynamoDbParams).then(function(arg) {
                var data, item, modifiedFields, ref2;
                item = arg.item;
                if ((ref2 = dynamoDbParams.returnValues) != null ? ref2.match(/old/i) : void 0) {
                  return request.success({
                    props: {
                      oldData: item,
                      data: request.requestDataWithKey
                    }
                  });
                } else {
                  modifiedFields = merge(request.data, request.props.add, request.props.setDefault);
                  return request.success({
                    props: {
                      data: data = mergeInto(request.requestDataWithKey, item),
                      updatedData: object(data, {
                        when: function(v, k) {
                          return modifiedFields[k] != null;
                        }
                      })
                    }
                  });
                }
              })["catch"](function(error) {
                if (error.message.match(/ConditionalCheckFailedException/)) {
                  return request.missing("Attempted to update a non-existant record.");
                } else {
                  throw error;
                }
              });
            }
          });
        };
      })(this));
    },

    /*
    OUT:
      if record didn't exist:
        response.status == missing
      else
        data: keyFields & values
     */
    "delete": function(request) {
      return this._artEryToDynamoDbRequest(request, {
        mustExist: true,
        returnValues: "allOld",
        then: (function(_this) {
          return function(deleteItemParams) {
            return _this.dynamoDb.deleteItem(deleteItemParams).then(function(arg) {
              var item;
              item = arg.item;
              return item;
            })["catch"](function(error) {
              if (error.message.match(/ConditionalCheckFailedException/)) {
                return request.missing("Attempted to delete a non-existant record.");
              } else {
                throw error;
              }
            });
          };
        })(this)
      });
    },

    /*
    This calls 'get' first, then calls 'delete' if it exists. Therefor 'delete' hooks
    will only fire if the record actually exists.
    
    OUT: promise.then (response) -> response.data == key(s)
     */
    deleteIfExists: function(request) {
      var data, key;
      key = request.key, data = request.data;
      return request.subrequest(this.pipelineName, "delete", {
        key: key,
        data: data,
        returnNullIfMissing: true
      }).then(function(result) {
        return result != null ? result : request.success({
          data: request.requestDataWithKey
        });
      });
    },

    /*
    This calls 'update' and possibly 'create', so hooks on update OR create will be correctly triggered.
    NOTE: Only after-update OR after-create filters/events will be processed - NOT BOTH!
      Which is the whole reason this exists, really - so the correct after-filters-events fire.
    
    TODO:
      The new version should do this:
      get {key, returnNullIfMissing: true}
      .then (exists) ->
        if exists
          update {key, data}
          .catch (doesntExists???) ->
            Promise.reject raceConditionOccured: true if doesntExists
           * NOTE - ignoring the race-condition with 'delete'
        else
          create {key, data}
          .catch (exists???) ->
            Promise.reject raceConditionOccured: true if exists
      .catch ({raceConditionOccured}) ->
        if raceConditionOccured && 3 > retryCount = 1 + props.retryCount ? 0
          createOrUpdate {
            key
            props: merge props, {retryCount}
          }
        else
          throw original-error
     */
    createOrUpdate: function(request) {
      return request.requireServerOrigin().then((function(_this) {
        return function() {
          return request.rejectIf(_this.getKeyFieldsString() === 'id', "createOk not available on tables with auto-generated-ids");
        };
      })(this)).then((function(_this) {
        return function() {
          var data, key;
          data = request.data, key = request.key;
          return request.subrequest(_this.pipelineName, "update", {
            key: key,
            data: data,
            returnNullIfMissing: true
          }).then(function(result) {
            return result != null ? result : request.subrequest(_this.pipelineName, "create", {
              key: key,
              data: data
            });
          });
        };
      })(this));
    }
  });

  DynamoDbPipeline._getAutoDefinedQueries = function(indexes) {
    var indexKey, queries, queryModelName;
    if (!indexes) {
      return {};
    }
    queries = {};
    for (queryModelName in indexes) {
      indexKey = indexes[queryModelName];
      if (isString(indexKey)) {
        (function(_this) {
          return (function(queryModelName, indexKey) {
            var hashKey, ref2, sortKey, whereClause;
            ref2 = indexKey.split("/"), hashKey = ref2[0], sortKey = ref2[1];
            whereClause = {};
            return queries[queryModelName] = {
              query: function(request) {
                whereClause[hashKey] = request.key;
                return request.pipeline.queryDynamoDb({
                  index: queryModelName,
                  where: whereClause
                }).then(function(arg) {
                  var items;
                  items = arg.items;
                  return items;
                });
              },
              dataToKeyString: function(data) {
                return data[hashKey];
              },
              localSort: function(queryData) {
                return withSort(queryData, function(a, b) {
                  var ret;
                  if (0 === (ret = compare(a[sortKey], b[sortKey]))) {
                    return compare(a.id, b.id);
                  } else {
                    return ret;
                  }
                });
              }
            };
          });
        })(this)(queryModelName, indexKey);
      }
    }
    return queries;
  };

  DynamoDbPipeline.prototype._vivifyTable = function() {
    return this._vivifyTablePromise || (this._vivifyTablePromise = Promise.resolve().then((function(_this) {
      return function() {
        return _this.tablesByNameForVivification.then(function(tablesByName) {
          if (!tablesByName[_this.tableName]) {
            log.warn((_this.getClassName()) + "#_vivifyTable() dynamoDb table does not exist: " + _this.tableName + ", creating...");
            return _this._createTable();
          }
        });
      };
    })(this)));
  };

  DynamoDbPipeline.classGetter({
    tablesByNameForVivification: function() {
      return this._tablesByNameForVivificationPromise || (this._tablesByNameForVivificationPromise = this.getDynamoDb().listTables().then((function(_this) {
        return function(arg) {
          var TableNames;
          TableNames = arg.TableNames;
          return object(TableNames, function() {
            return true;
          });
        };
      })(this)));
    }
  });

  DynamoDbPipeline.getter({
    tablesByNameForVivification: function() {
      return DynamoDbPipeline.getTablesByNameForVivification();
    },
    dynamoDbCreationAttributes: function() {
      var k, out, ref2, v;
      out = {};
      ref2 = this.normalizedFields;
      for (k in ref2) {
        v = ref2[k];
        if (v.dataType === "string" || v.dataType === "number") {
          out[k] = v.dataType;
        }
      }
      return out;
    },
    streamlinedCreateTableParams: function() {
      return merge({
        table: this.tableName,
        globalIndexes: this.globalIndexes,
        localIndexes: this.localIndexes,
        attributes: this.dynamoDbCreationAttributes,
        key: this.keyFieldsString
      }, this._options);
    },
    createTableParams: function() {
      return ArtAws.StreamlinedDynamoDbApi.CreateTable.translateParams(this.streamlinedCreateTableParams);
    }
  });

  DynamoDbPipeline.prototype._createTable = function() {
    return this.dynamoDb.createTable(this.streamlinedCreateTableParams)["catch"]((function(_this) {
      return function(e) {
        log.error("DynamoDbPipeline#_createTable " + _this.tableName + " FAILED", e);
        throw e;
      };
    })(this));
  };


  /*
  IN:
    request:
      requestProps:
        key
        data: {key: value}
          NOTE: null values are moved for CREATE and converted to REMOVE (attribute)
            actions for UPDATE.
  
        add: {key: value to add} -> dynamodb ADD action
        setDefault: {key: value} -> set attribute if not present
        conditionExpresssion: dynamodb update-of condition expressiong
        returnValues:         art.aws.dynamodb return value selector type
  
    requiresKey: true/false
      true:  key and data will be normalized using the primaryKey fields
      false: there willbe no key
  
    action: (streamlinedDynamoDbParams) -> out
  
  OUT:
    promise.catch (error) ->                # only internalErrors are thrown
    promise.then (clientFailureResponse) -> # if input is invalid, return clientFailure without invoking action
    promise.then (out) ->                   # otherwise, returns action's return value
   */

  DynamoDbPipeline.prototype._artEryToDynamoDbRequest = function(request, options) {
    var add, conditionExpression, data, key, mustExist, ref2, requestType, requiresKey, returnValues, setDefault;
    if (options == null) {
      options = {};
    }
    requiresKey = options.requiresKey, mustExist = options.mustExist;
    if (mustExist) {
      requiresKey = true;
    }
    ref2 = request.props, key = ref2.key, data = ref2.data, add = ref2.add, setDefault = ref2.setDefault, conditionExpression = ref2.conditionExpression, returnValues = ref2.returnValues;
    requestType = request.requestType;
    return Promise.then((function(_this) {
      return function() {
        return request.requireServerOriginOr(!(add || setDefault || conditionExpression || returnValues), "to use add, setDefault, returnValues, or conditionExpression props");
      };
    })(this)).then((function(_this) {
      return function() {
        return request.require(!(add || setDefault) || requestType === "update", "add and setDefault only valid for update requests");
      };
    })(this)).then((function(_this) {
      return function() {
        var k, remove, v;
        if (requiresKey) {
          data = _this.dataWithoutKeyFields(data);
          key = _this.toKeyObject(request.key);
        }
        if (requestType === "update") {
          remove = (function() {
            var results;
            results = [];
            for (k in data) {
              v = data[k];
              if (v === null) {
                results.push(k);
              }
            }
            return results;
          })();
        }
        data = objectWithExistingValues(data);
        if (options.returnValues) {
          returnValues = options.returnValues;
        }
        if (requestType === "update") {
          returnValues || (returnValues = "allNew");
        }
        conditionExpression || (conditionExpression = mustExist && key);
        return objectWithExistingValues({
          tableName: _this.tableName,
          data: data,
          key: key,
          remove: remove,
          add: add,
          setDefault: setDefault,
          returnValues: returnValues,
          conditionExpression: conditionExpression
        });
      };
    })(this)).then(options.then, function(arg) {
      var message;
      message = arg.message;
      return request.clientFailure(message);
    });
  };

  return DynamoDbPipeline;

})(KeyFieldsMixin(UpdateAfterMixin(Pipeline))));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtAws, Pipeline, Promise, Sqs, SqsPipeline, defineModule, log, merge, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, Promise = ref.Promise, log = ref.log, merge = ref.merge;

Pipeline = __webpack_require__(13).Pipeline;

Sqs = (ArtAws = __webpack_require__(52)).Sqs;

defineModule(module, SqsPipeline = (function(superClass) {
  extend(SqsPipeline, superClass);

  function SqsPipeline() {
    return SqsPipeline.__super__.constructor.apply(this, arguments);
  }

  SqsPipeline.abstractClass();

  SqsPipeline.getter({
    sqs: function() {
      return Sqs.singleton;
    }
  });

  SqsPipeline.handlers({
    sendMessage: function(arg) {
      var body;
      body = arg.body;
      return this.sqs.sendMessage({
        queue: this.tableName,
        body: JSON.stringify(body)
      });
    },
    receiveMessage: function(arg) {
      var data, visibilityTimeout, wait;
      data = arg.data;
      visibilityTimeout = data.visibilityTimeout, wait = data.wait;
      return this.sqs.receiveMessage({
        queue: this.tableName
      }, {
        limit: 1,
        visibilityTimeout: visibilityTimeout,
        wait: wait
      }).then(function(messages) {
        return messages[0];
      });
    },
    receiveMessages: function(arg) {
      var data, limit, ref1, visibilityTimeout, wait;
      data = arg.data;
      limit = (ref1 = data.limit) != null ? ref1 : 10, visibilityTimeout = data.visibilityTimeout, wait = data.wait;
      return this.sqs.receiveMessage({
        queue: this.tableName
      }, {
        limit: limit,
        visibilityTimeout: visibilityTimeout,
        wait: wait
      });
    },
    deleteMessage: function(arg) {
      var key;
      key = arg.key;
      return this.sqs.deleteMessage({
        queue: this.tableName,
        receiptHandle: key
      });
    }
  });

  return SqsPipeline;

})(Pipeline));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(219);

module.exports.addModules({
  DynamoDbPipeline: __webpack_require__(216),
  SqsPipeline: __webpack_require__(217)
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var Aws,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.EryExtensions.Aws', Aws = (function(superClass) {
  extend(Aws, superClass);

  function Aws() {
    return Aws.__super__.constructor.apply(this, arguments);
  }

  Aws.version = __webpack_require__(290).version;

  return Aws;

})(Neptune.PackageNamespace));


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(218);


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var PusherFilter, PusherFluxModelMixin, defineModule,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defineModule = __webpack_require__(2).defineModule;

PusherFluxModelMixin = __webpack_require__(101);

PusherFilter = __webpack_require__(100);

defineModule(module, function() {
  return function(superClass) {
    var PusherPipelineMixin;
    return PusherPipelineMixin = (function(superClass1) {
      extend(PusherPipelineMixin, superClass1);

      function PusherPipelineMixin() {
        return PusherPipelineMixin.__super__.constructor.apply(this, arguments);
      }

      if (typeof PusherPipelineMixin.abstractClass === "function") {
        PusherPipelineMixin.abstractClass();
      }

      PusherPipelineMixin.fluxModelMixin(PusherFluxModelMixin);


      /*
      NOTE: This Filter will run very first after the handler
      since it is defined in the mixin - before the body of the
      actual class is evaluated.
      
      This is fine for now, but if we ever want to push actual data, we may
      need this to run after other filters which refine said data.
       */

      PusherPipelineMixin.filter(PusherFilter);

      return PusherPipelineMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(102);

module.exports.addModules({
  Config: __webpack_require__(57),
  PusherFilter: __webpack_require__(100),
  PusherFluxModelMixin: __webpack_require__(101),
  PusherPipelineMixin: __webpack_require__(221)
});


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(224);

module.exports.includeInNamespace(__webpack_require__(180)).addModules({
  ArtEryHandler: __webpack_require__(73),
  ArtEryInfoHandler: __webpack_require__(74),
  ArtErySessionManager: __webpack_require__(75),
  PromiseJsonWebToken: __webpack_require__(76),
  StandardImport: __webpack_require__(18)
});


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var Server,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Server', Server = (function(superClass) {
  extend(Server, superClass);

  function Server() {
    return Server.__super__.constructor.apply(this, arguments);
  }

  return Server;

})(Neptune.PackageNamespace));


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var Filters, PipelineRegistry, Promise, _package, log, ref;

PipelineRegistry = __webpack_require__(60);

Filters = __webpack_require__(36);

ref = __webpack_require__(0), log = ref.log, Promise = ref.Promise;

module.exports = [
  Filters, {
    pipelines: PipelineRegistry.pipelines,
    session: (__webpack_require__(63)).singleton,
    "package": _package = __webpack_require__(163),
    version: _package.version,
    config: __webpack_require__(11).config,
    _reset: function(pipelineTestFunction) {
      PipelineRegistry._reset(pipelineTestFunction);
      return Filters._resetFilters();
    },
    sendInitializeRequestToAllPipelines: function() {
      var k, pipeline, promises;
      promises = (function() {
        var ref1, results;
        ref1 = PipelineRegistry.pipelines;
        results = [];
        for (k in ref1) {
          pipeline = ref1[k];
          if (pipeline["class"].getHandlers().initialize) {
            results.push(pipeline.initialize());
          } else {
            results.push(void 0);
          }
        }
        return results;
      })();
      return Promise.all(promises);
    }
  }
];


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var AfterEventsFilter;

AfterEventsFilter = __webpack_require__(58);

module.exports = [
  __webpack_require__(106), {
    _resetFilters: function() {
      return AfterEventsFilter._reset();
    }
  }
];


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var FieldTypes, Filter, Uuid, UuidFilter, defineModule, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log;

Filter = __webpack_require__(9);

Uuid = __webpack_require__(170);

FieldTypes = __webpack_require__(17).FieldTypes;

defineModule(module, UuidFilter = (function(superClass) {
  extend(UuidFilter, superClass);

  function UuidFilter() {
    return UuidFilter.__super__.constructor.apply(this, arguments);
  }

  UuidFilter.alwaysForceNewIds = true;

  UuidFilter.before({
    create: function(request) {
      return request.withMergedData({
        id: UuidFilter.alwaysForceNewIds ? Uuid.v4() : request.data.id || Uuid.v4()
      });
    }
  });

  UuidFilter.fields({
    id: FieldTypes.id
  });

  return UuidFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AfterEventsFilter, KeyFieldsMixin, Pipeline, Promise, array, compactFlatten, deepMerge, defineModule, formattedInspect, log, merge, object, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log, merge = ref.merge, Promise = ref.Promise, object = ref.object, deepMerge = ref.deepMerge, compactFlatten = ref.compactFlatten, formattedInspect = ref.formattedInspect, array = ref.array;

Pipeline = __webpack_require__(111);

KeyFieldsMixin = __webpack_require__(110);

AfterEventsFilter = __webpack_require__(36).AfterEventsFilter;

defineModule(module, function() {
  return function(superClass) {
    var UpdateAfterMixin;
    return UpdateAfterMixin = (function(superClass1) {
      extend(UpdateAfterMixin, superClass1);

      function UpdateAfterMixin() {
        return UpdateAfterMixin.__super__.constructor.apply(this, arguments);
      }


      /*
      updateAfter vs afterEvent
      
      afterEvent is more basic, gives you more control, but lacks the special features
      updateAfter can deliver.
      
      afterEvent:
        Invokes the specified function when the AfterEvent fires for the specified
        type and pipeline. The return results is resolved if it is a promise, but unless
        the promise is rejected or an error is thrown, the result is ignored.
      
        That's it. That's all afterEvent does.
      
        SEE: AfterEventsFilter
      
      updateAfter:
        The specified function should return a propsObject or array-of-propsObjects
        (optionally via a promise).
        After the rootRequest(*) completes, all updateAfter props are aggregated and
        deep-merged (for the same pipeline+key) and then update is called for each
        unique pipeline+key pair.
      
        If any of the updates fail, the rootRequest fails.
        If any of the updatePropsFunctions fail, the triggering-request fails.
      
      updateAfter's key benefit:
        If you update the same record more than once for the same rootRequest via
        updateAfter functions, there will only be one 'update' request invoked.
      
        Exception/Feature: afterUpdates can trigger other afterUpdates, but they
        are always processed in a depth-first manner: all current afterUpdates
        are aggregated until no more are requested, then they are all processed,
        possibly triggering the next tier of afterUpdates.
      
      (*) Technically the update requests due to updateAfters are triggered
        after the root-most request on a pipeline that mixed in UpdateAfterMixin,
        not strictly the rootRequest. If you use the UpdateAfterMixin on all your
        pipelines, it will always be the rootRequest.
       */


      /*
      updateAfter:
        declare records in THIS pipeline that should be updated AFTER
        requests complete against another pipeline (or this one).
      
      IN: eventMap looks like:
        requestType: triggeringPipelineName: updateItemPropsFunction
      
        updateItemPropsFunction: (response) -> updateItemProps
        IN: response is the ArtEry request-response for the request-in-progress on
          the specified triggeringPipelineName.
          (response.pipelineName == the specified triggeringPipelineName)
      
        OUT: props object OR an array (compactFlattened) of props objects
          props-objects:
            Must have 'key' set to a string
            All same-key props-objects are deepMerged in the order they are listed.
              (i.e. last has priority)
      
      EXAMPLE:
        class User extends UpdateAfterMixin Pipeline
          @updateAfter
             * Increment postCount for all visible posts created by a user.
            create: post: ({data:{userId, createdAt, invisible}}) ->
              if !invisible
                key:  userId
                data: lastPostCreatedAt: createdAt
                add:  visiblePostCount: 1
       */

      UpdateAfterMixin.updateAfter = function(eventMap) {
        var pipelineName, requestType, requestTypeMap, results, updateRequestPropsFunction;
        if (this.getKeyFieldsString() !== "id") {
          throw new Error("keyFields must be 'id'");
        }
        results = [];
        for (requestType in eventMap) {
          requestTypeMap = eventMap[requestType];
          results.push((function() {
            var results1;
            results1 = [];
            for (pipelineName in requestTypeMap) {
              updateRequestPropsFunction = requestTypeMap[pipelineName];
              AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType);
              results1.push(this._addUpdateAfterFunction(pipelineName, requestType, updateRequestPropsFunction));
            }
            return results1;
          }).call(this));
        }
        return results;
      };


      /*
      afterEvent: Add your own event handler after other pipeline's successful requests.
      If you return a promise:
        The original request won't complete (or succeed) until your returned promise resolves.
        If your promise is rejected, the original request is rejected.
      
      IN: eventMap looks like:
        requestType: pipelineName: (response) -> (ignored except for errors)
       */

      UpdateAfterMixin.afterEvent = function(eventMap) {
        var afterEventFunction, pipelineName, requestType, requestTypeMap, results;
        results = [];
        for (requestType in eventMap) {
          requestTypeMap = eventMap[requestType];
          results.push((function() {
            var results1;
            results1 = [];
            for (pipelineName in requestTypeMap) {
              afterEventFunction = requestTypeMap[pipelineName];
              AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType);
              results1.push(this._addAfterEventFunction(pipelineName, requestType, afterEventFunction));
            }
            return results1;
          }).call(this));
        }
        return results;
      };

      UpdateAfterMixin.deleteAfter = function(eventMap) {
        var pipelineName;
        pipelineName = this.getPipelineName();
        return this.afterEvent(object(eventMap, function(requestTypeMap) {
          return object(requestTypeMap, function(getPropsFunction, otherPipelineName) {
            return function(response) {
              return Promise.resolve(getPropsFunction(response)).then(function(props) {
                return response.subrequest(pipelineName, "delete", props);
              });
            };
          });
        }));
      };

      UpdateAfterMixin.extendableProperty({
        updatePropsFunctions: {},
        afterEventFunctions: {}
      });

      UpdateAfterMixin._addUpdateAfterFunction = function(pipelineName, requestType, updatePropsFunction) {
        var base, base1;
        return ((base = ((base1 = this.extendUpdatePropsFunctions())[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])).push(updatePropsFunction);
      };

      UpdateAfterMixin._addAfterEventFunction = function(pipelineName, requestType, afterEventFunction) {
        var base, base1;
        return ((base = ((base1 = this.extendAfterEventFunctions())[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])).push(afterEventFunction);
      };

      UpdateAfterMixin._mergeUpdateProps = function(manyUpdateItemProps) {
        return object(compactFlatten(manyUpdateItemProps), {
          key: function(arg) {
            var key;
            key = arg.key;
            return key;
          },
          when: function(props) {
            return props;
          },
          "with": (function(_this) {
            return function(props, inputKey, into) {
              if (!props.key) {
                log.error({
                  "key not found for one or more updateItem entries": {
                    manyUpdateItemProps: manyUpdateItemProps
                  }
                });
                throw new Error((_this.getName()) + ".updateAfter: key required for each updateItem param set (see log for details)");
              }
              if (into[props.key]) {
                return deepMerge(into[props.key], props);
              } else {
                return props;
              }
            };
          })(this)
        });
      };

      UpdateAfterMixin._applyAllUpdates = function(response) {
        var updateRequestsByToUpdatePipeline;
        updateRequestsByToUpdatePipeline = response.context.updateRequestsByToUpdatePipeline;
        response.context.updateRequestsByToUpdatePipeline = null;
        if (updateRequestsByToUpdatePipeline) {
          return Promise.deepAll(updateRequestsByToUpdatePipeline).then((function(_this) {
            return function(resolvedUpdateRequestsByToUpdatePipeline) {
              return Promise.all(array(resolvedUpdateRequestsByToUpdatePipeline, function(updatePropsList, toUpdatePipelineName) {
                return Promise.all(array(_this._mergeUpdateProps(updatePropsList), function(props) {
                  return response.subrequest(toUpdatePipelineName, "update", {
                    props: props
                  });
                }));
              }));
            };
          })(this)).then((function(_this) {
            return function() {
              return _this._applyAllUpdates(response);
            };
          })(this));
        } else {
          return Promise.resolve();
        }
      };


      /*
      UpdateAfterMixinFilter provides the functionality of only triggering
      updates when the rootRequest(*) completes.
       */

      UpdateAfterMixin.filter({
        name: "UpdateAfterMixinFilter",
        group: "outter",
        filterFailures: true,
        before: {
          all: function(request) {
            request.context.updateAfterMixinDepth = (request.context.updateAfterMixinDepth || 0) + 1;
            return request;
          }
        },
        after: {
          all: function(request) {
            var p;
            p = request.context.updateAfterMixinDepth === 1 ? UpdateAfterMixin._applyAllUpdates(request) : Promise.resolve();
            return p.then(function() {
              request.context.updateAfterMixinDepth--;
              return request;
            });
          }
        }
      });

      UpdateAfterMixin.handleRequestAfterEvent = function(request) {
        var base, base1, ref1, ref2, requestType, toUpdatePipeline, toUpdatePipelineName, triggeringPipelineName;
        triggeringPipelineName = request.pipelineName, requestType = request.requestType;
        toUpdatePipeline = this.singleton;
        toUpdatePipelineName = toUpdatePipeline.pipelineName;
        ((base = ((base1 = request.context).updateRequestsByToUpdatePipeline || (base1.updateRequestsByToUpdatePipeline = {})))[toUpdatePipelineName] || (base[toUpdatePipelineName] = [])).push(array((ref1 = this.getUpdatePropsFunctions()[triggeringPipelineName]) != null ? ref1[requestType] : void 0, (function(_this) {
          return function(updateRequestPropsFunction) {
            return updateRequestPropsFunction.call(toUpdatePipeline, request);
          };
        })(this)));
        return Promise.deepAll(array((ref2 = this.getAfterEventFunctions()[triggeringPipelineName]) != null ? ref2[requestType] : void 0, (function(_this) {
          return function(afterEventFunction) {
            return afterEventFunction.call(toUpdatePipeline, request);
          };
        })(this)));
      };

      return UpdateAfterMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, EventedMixin, EventedObject, defineModule, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), defineModule = ref.defineModule, log = ref.log;

EventedMixin = __webpack_require__(118);

BaseClass = __webpack_require__(3).BaseClass;

defineModule(module, EventedObject = (function(superClass) {
  extend(EventedObject, superClass);

  function EventedObject() {
    log.error("EventedObject is DEPRICATED - use EventedMixin");
    EventedObject.__super__.constructor.apply(this, arguments);
  }

  return EventedObject;

})(EventedMixin(BaseClass)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(119);

module.exports.addModules({
  Event: __webpack_require__(64),
  EventedBaseMixin: __webpack_require__(117),
  EventedMixin: __webpack_require__(118),
  EventedObject: __webpack_require__(229),
  EventEpoch: __webpack_require__(115),
  EventManager: __webpack_require__(116)
});


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(5)).vivifySubnamespace('Art');

__webpack_require__(119);


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(233);

module.exports.includeInNamespace(__webpack_require__(181)).addModules({
  AllowAllCorsHandler: __webpack_require__(50),
  LoggingMixin: __webpack_require__(51),
  PromiseHandler: __webpack_require__(77),
  Server: __webpack_require__(78)
});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var ExpressServer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.ExpressServer', ExpressServer = (function(superClass) {
  extend(ExpressServer, superClass);

  function ExpressServer() {
    return ExpressServer.__super__.constructor.apply(this, arguments);
  }

  ExpressServer.version = __webpack_require__(293).version;

  return ExpressServer;

})(Neptune.PackageNamespace));


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtFoundationConfig, Configurable, Promise, Validator, defineModule, mergeInto, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), w = ref.w, Validator = ref.Validator, defineModule = ref.defineModule, mergeInto = ref.mergeInto, Promise = ref.Promise;

Configurable = __webpack_require__(33).Configurable;

defineModule(module, ArtFoundationConfig = (function(superClass) {
  extend(ArtFoundationConfig, superClass);

  function ArtFoundationConfig() {
    return ArtFoundationConfig.__super__.constructor.apply(this, arguments);
  }

  return ArtFoundationConfig;

})(Configurable));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(122);

module.exports = [
  __webpack_require__(65), {
    stream: (__webpack_require__(121)).stream
  }, [__webpack_require__(14), "binary binaryFromBlob"]
];


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var EncodedImage, ErrorWithInfo, HTMLImageElement, Image, Promise, StandardLib, binary, isBinary, isNode, isString, log, readFileAsDataUrl, ref, toDataUri;

StandardLib = __webpack_require__(0);

toDataUri = __webpack_require__(120).toDataUri;

isNode = StandardLib.isNode, log = StandardLib.log, Promise = StandardLib.Promise, readFileAsDataUrl = StandardLib.readFileAsDataUrl, ErrorWithInfo = StandardLib.ErrorWithInfo, isString = StandardLib.isString;

ref = __webpack_require__(14), isBinary = ref.isBinary, binary = ref.binary;

__webpack_require__(21);

Image = global.Image, HTMLImageElement = global.HTMLImageElement;

module.exports = EncodedImage = (function() {
  var get;

  function EncodedImage() {}


  /*
  IN:
    first arg:
      String: url
      or
      Binary: image data
      or
      HTMLImageElement
    options: options for RestClient.getArrayBuffer
      NOTE: if options is provided, image-data is fetched using
        RestClient.getArrayBuffer
      This seems to work to endrun TAINT.
  
  OUT:
    promise.then (fullyLoadedHtmlImage) ->
    , (htmlImageOnerrorEvent) ->
   */

  EncodedImage.get = get = function(source, options) {
    var complete, image, naturalWidth;
    if (source == null) {
      return Promise.reject();
    }
    if (source.constructor === HTMLImageElement || source.constructor === Image) {
      image = source;
      complete = source.complete, naturalWidth = source.naturalWidth;
      return new Promise(function(resolve, reject) {
        if (complete && (naturalWidth > 0 || isNode)) {
          return resolve(source);
        } else {
          image.onload = function() {
            return resolve(image);
          };
          return image.onerror = function(event) {
            return reject(new ErrorWithInfo("image load error", event));
          };
        }
      });
    } else {
      return Promise.then(function() {
        if (isBinary(source)) {
          if (Neptune.isNode) {
            return binary(source).nodeBuffer;
          } else {
            return toDataUri(source);
          }
        } else if (isString(source)) {
          if (options) {
            return Neptune.Art.RestClient.getArrayBuffer(source, options).then(function(arrayBuffer) {
              return readFileAsDataUrl(new Blob([arrayBuffer]));
            });
          } else {
            return source;
          }
        } else {
          throw new Error("expected arg #1 to be string or binary");
        }
      }).then(function(url) {
        image = new Image;
        image.src = url;

        /*
        crossOrigin = "Anonymous" required to getImageData and avoid this error
          "The canvas has been tainted by cross-origin data."
        
        NOTE:
          file: urls break with crossOrigin in WkWebKit
          data: urls break with crossOrigin in Safari
         */
        if (typeof url.match === "function" ? url.match(/^(file|data)\:/i) : void 0) {
          image.crossOrigin = "Anonymous";
        }
        return get(image);
      });
    }
  };

  EncodedImage.toImage = function(encodedImageData) {
    return toDataUri(encodedImageData).then((function(_this) {
      return function(dataUri) {
        return get(dataUri);
      };
    })(this));
  };

  return EncodedImage;

})();


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, Promise, StandardLib, WriteStream, binary, bound, bufferSize, log, readFileAsArrayBuffer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

binary = __webpack_require__(14).binary;

Promise = StandardLib.Promise, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, bound = StandardLib.bound;

BaseObject = ClassSystem.BaseObject, log = ClassSystem.log;

bufferSize = 1024;

module.exports = WriteStream = (function(superClass) {
  extend(WriteStream, superClass);

  function WriteStream() {
    this._written = [];
    this._writeBuffer = new Uint8Array(bufferSize);
    this._pos = 0;
    this._writtenLength = 0;
  }

  WriteStream.prototype.writeByte = function(byte) {
    if (this._pos === bufferSize) {
      this._commitHead();
    }
    return this._writeBuffer[this._pos++] = byte;
  };

  WriteStream.prototype.writeAsi = function(number) {
    var nextByte, results;
    if (!(number >= 0)) {
      throw new Error("expected number >= 0");
    }
    results = [];
    while (true) {
      nextByte = number & 0x7F;
      number >>= 7;
      if (number > 0) {
        results.push(this.writeByte(nextByte | 0x80));
      } else {
        this.writeByte(nextByte);
        break;
      }
    }
    return results;
  };

  WriteStream.prototype.write = function(string) {
    var binaryString;
    binaryString = binary(string);
    if (this._pos + binaryString.length <= bufferSize) {
      this._writeBuffer.set(binaryString.uint8Array, this._pos);
      return this._pos += binaryString.length;
    } else {
      this._commitHead();
      this._writtenLength += binaryString.length;
      return this._written.push(binaryString.uint8Array);
    }
  };

  WriteStream.prototype.writeAsiString = function(string) {
    var binaryString;
    binaryString = binary(string);
    this.writeAsi(binaryString.length);
    return this.write(binaryString);
  };

  WriteStream.getter({
    arrayBufferPromise: function() {
      return this._compact().then(function(uint8Array) {
        return uint8Array.buffer;
      });
    },
    binaryStringPromise: function() {
      return this.arrayBufferPromise.then(function(ab) {
        return binary(ab);
      });
    },
    length: function() {
      return this._pos + this._writtenLength;
    }
  });


  /*
  Using new Blob is much faster, thus we use Promises since it is async
    http://jsperf.com/appending-arraybuffers
  
  OUT: promise.then (compactedUint8Array) ->
  EFFECT:
    head was committed
    if @_written.length <= 1 then it isn't changed
    else @_written = [compactedUint8Array]
   */

  WriteStream.prototype._compact = function() {
    this._commitHead();
    switch (this._written.length) {
      case 0:
        return new Promise(function(resolve) {
          return resolve(new Uint8Array(0));
        });
      case 1:
        return new Promise((function(_this) {
          return function(resolve) {
            return resolve(_this._written[0]);
          };
        })(this));
      default:
        return readFileAsArrayBuffer(new Blob(this._written)).then((function(_this) {
          return function(ab) {
            _this._written = [new Uint8Array(ab)];
            return _this._written[0];
          };
        })(this));
    }
  };

  WriteStream.prototype._commitHead = function() {
    if (!(this._pos > 0)) {
      return;
    }
    this._writtenLength += this._pos;
    this._written.push(this._writeBuffer.slice(0, this._pos));
    return this._pos = 0;
  };

  return WriteStream;

})(BaseObject);


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Browser, Promise, array, defineModule, hasProperties, log, present, ref;

ref = __webpack_require__(0), hasProperties = ref.hasProperties, defineModule = ref.defineModule, log = ref.log, present = ref.present, array = ref.array, Promise = ref.Promise;

defineModule(module, Browser = (function() {
  var browserIsMobile, encodeMailto, encodeUri, encodeUriQuery, isMobileBrowserRegExp1, isMobileBrowserRegExp2, openLink, stripLeadingSlash, stripTrailingSlash, uriPathJoin;

  function Browser() {}

  isMobileBrowserRegExp1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;

  isMobileBrowserRegExp2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|agent wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|agent|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)agent|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[agent-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(agent|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-agent|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;

  browserIsMobile = null;

  Browser.isMobileBrowser = function() {
    var agent, check;
    if (browserIsMobile != null) {
      return browserIsMobile;
    }
    check = false;
    agent = navigator.userAgent || navigator.vendor || window.opera;
    return browserIsMobile = !!(isMobileBrowserRegExp1.test(agent) || isMobileBrowserRegExp2.test(agent.substr(0, 4)));
  };

  Browser.getDomReadyPromise = function() {
    return new Promise((function(_this) {
      return function(resolve) {
        var document;
        document = global.document;
        if (!document || document.readyState !== "loading") {
          return resolve();
        } else {
          return document.addEventListener("readystatechange", function() {
            if (document.readyState === "interactive") {
              return resolve();
            }
          });
        }
      };
    })(this));
  };

  Browser.openLink = openLink = function(link) {
    return global.open(link, '_blank');
  };

  Browser.encodeUriQuery = encodeUriQuery = function(query) {
    if (!hasProperties(query)) {
      return '';
    }
    return array(query, {
      when: function(v, k) {
        return (v != null) && present(v);
      },
      "with": function(v, k) {
        return k + "=" + (encodeURIComponent(v));
      }
    }).join("&");
  };

  Browser.stripLeadingSlash = stripLeadingSlash = function(a) {
    return a.match(/^\/?(.*)/)[1];
  };

  Browser.stripTrailingSlash = stripTrailingSlash = function(a) {
    return a.match(/(^.*[^\/])\/?$/)[1];
  };

  Browser.uriPathJoin = uriPathJoin = function(a, b) {
    if (!present(a)) {
      a = null;
    }
    if (!present(b)) {
      b = null;
    }
    if (a && b) {
      if (/\:$/.test(a)) {
        return "" + a + (stripLeadingSlash(b));
      } else {
        return (stripTrailingSlash(a)) + "/" + (stripLeadingSlash(b));
      }
    } else if (a) {
      return a;
    } else if (b) {
      return b;
    } else {
      return '';
    }
  };

  Browser.encodeUri = encodeUri = function(options) {
    var host, path, port, protocol, protocolHost, query, uri;
    host = options.host, path = options.path, port = options.port, uri = options.uri, protocol = options.protocol, query = options.query;
    if (!present(uri)) {
      protocol = present(protocol) ? protocol : '';
      host = present(host) ? host : '';
      protocolHost = host ? protocol + "://" + host : protocol ? protocol + ":" : '';
      port = (function() {
        if (present(port)) {
          if (!host) {
            throw new Error("host required when specifying port");
          }
          return ":" + port;
        } else {
          return '';
        }
      })();
      uri = "" + protocolHost + port;
    }
    query = encodeUriQuery(query);
    query = present(query) ? "?" + query : '';
    return "" + (uriPathJoin(uri, path)) + query;
  };

  Browser.encodeMailto = encodeMailto = function(options) {
    var bcc, body, cc, ref1, subject, to;
    cc = options.cc, bcc = options.bcc, subject = options.subject, body = options.body, to = (ref1 = options.to) != null ? ref1 : '';
    return encodeUri({
      protocol: "mailto",
      path: to,
      query: {
        cc: cc,
        bcc: bcc,
        subject: subject,
        body: body
      }
    });
  };

  Browser.sendEmail = function(options) {
    return openLink(encodeMailto(options));
  };

  return Browser;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, Cookie, StandardLib, getCookie, isPlainArray, isPlainObject, isString, log, setCookie,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

log = StandardLib.log, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, isPlainObject = StandardLib.isPlainObject;

BaseObject = ClassSystem.BaseObject;

setCookie = function(cookieName, cookieValue, arg) {
  var cookieString, d, expires, path;
  expires = arg.expires, path = arg.path;
  if (!isString(cookieValue)) {
    if (!(isPlainArray(cookieValue) || isPlainObject(cookieValue))) {
      throw new Error("cookieValue must be a string, array or object");
    }
    cookieValue = JSON.stringify(cookieValue);
  }
  cookieString = cookieName + "=" + cookieValue;
  if (expires) {
    d = new Date();
    d.setTime(d.getTime() + expires * 24 * 60 * 60 * 1000);
    cookieString += "; expires=" + (d.toUTCString());
  }
  if (path) {
    cookieString += "; path=" + path;
  }
  return document.cookie = cookieString;
};

getCookie = function(cookieName) {
  var c, ca, i, len, name, value;
  name = cookieName + "=";
  ca = document.cookie.split(';');
  for (i = 0, len = ca.length; i < len; i++) {
    c = ca[i];
    while (' ' === c.charAt(0)) {
      c = c.substring(1);
    }
    if (0 === c.indexOf(name)) {
      value = c.substring(name.length, c.length);
      if (value.match(/^[{[]/)) {
        value = JSON.parse(value);
      }
      return value;
    }
  }
  return "";
};

module.exports = Cookie = (function(superClass) {
  extend(Cookie, superClass);

  function Cookie() {
    return Cookie.__super__.constructor.apply(this, arguments);
  }

  Cookie.set = function(name, value, options) {
    return setCookie(name, value, options);
  };

  Cookie.get = function(name) {
    return getCookie(name);
  };

  Cookie.remove = function(name, options) {
    return setCookie(name, {
      path: options.path,
      expires: -1
    });
  };

  return Cookie;

})(BaseObject);


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var File, Promise, StandardLib, createElementFromHtml;

StandardLib = __webpack_require__(0);

createElementFromHtml = __webpack_require__(125).createElementFromHtml;

Promise = StandardLib.Promise;

module.exports = File = (function() {
  function File() {}

  File.request = function(options) {
    if (options == null) {
      options = {};
    }
    return new Promise(function(resolve, reject) {
      var accept, body, fileInput, multiple, onChange, ref;
      accept = options.accept, multiple = options.multiple, onChange = options.onChange;
      if ((ref = this.hiddenDivForFileInput) != null) {
        ref.parentNode.removeChild(this.hiddenDivForFileInput);
      }
      this.hiddenDivForFileInput = createElementFromHtml("<div style='height: 0px;width: 0px; overflow:hidden; position:absolute;'/>");
      body = document.body;
      fileInput = createElementFromHtml("<input type='file' " + (accept ? 'accept=' + accept : void 0) + " " + (multiple ? 'multiple=true' : void 0) + "/>");
      this.hiddenDivForFileInput.appendChild(fileInput);
      body.appendChild(this.hiddenDivForFileInput);
      fileInput.onchange = function(e) {
        var file, fileList, fileSizes, fileTypes;
        fileList = (function() {
          var i, len, ref1, results;
          ref1 = fileInput.files;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            file = ref1[i];
            results.push(file);
          }
          return results;
        })();
        fileTypes = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = fileList.length; i < len; i++) {
            file = fileList[i];
            results.push(file.type);
          }
          return results;
        })();
        fileSizes = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = fileList.length; i < len; i++) {
            file = fileList[i];
            results.push(file.size);
          }
          return results;
        })();
        if (fileList.length > 0 && fileList[0]) {
          onChange && onChange(fileList);
          return resolve(fileList);
        } else {
          return reject("no files returned");
        }
      };
      return fileInput.click();
    });
  };

  return File;

})();


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(127);

module.exports.includeInNamespace(__webpack_require__(238)).addModules({
  Cookie: __webpack_require__(239),
  Dom: __webpack_require__(125),
  DomElementFactories: __webpack_require__(126),
  File: __webpack_require__(240)
});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var _package;

module.exports = [
  __webpack_require__(0), __webpack_require__(3), __webpack_require__(33), {
    Epoch: __webpack_require__(97).EpochClass
  }, __webpack_require__(124), __webpack_require__(133), {
    "package": _package = __webpack_require__(164),
    version: _package.version
  }
];


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var Analytics, BaseObject, ClassSystem, StandardLib, inspectLean,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

BaseObject = ClassSystem.BaseObject;

inspectLean = StandardLib.inspectLean;

Analytics = (function(superClass) {
  extend(Analytics, superClass);

  function Analytics() {
    return Analytics.__super__.constructor.apply(this, arguments);
  }

  Analytics.defaultCategory = "Foundation.Analytics";

  Analytics.event = function(options) {
    var action, category, label, noninteraction, value;
    if (options == null) {
      options = {};
    }
    category = options.category || this.defaultCategory;
    action = options.action;
    label = options.label;
    value = options.value;
    noninteraction = !!options.noninteraction;
    if (self._gaq) {
      self._gaq.push(['_trackEvent', category, action, label, value, noninteraction]);
      return this.rawLog("ANALYTICS-EVENT: " + (inspectLean(options)));
    } else {
      return this.rawLog("(no)ANALYTICS-EVENT: " + (inspectLean(options)));
    }
  };

  return Analytics;

})(BaseObject);


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, BatchLoader, ClassSystem, StandardLib, inspect, log, nextTick, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

BaseObject = ClassSystem.BaseObject;

log = StandardLib.log, inspect = StandardLib.inspect, nextTick = StandardLib.nextTick, timeout = StandardLib.timeout;

module.exports = BatchLoader = (function(superClass) {
  extend(BatchLoader, superClass);

  function BatchLoader(loadFunction) {
    this.assets = {};
    this.loadingAssets = {};
    this.loadFunction = loadFunction;
  }

  BatchLoader.prototype.load = function(sources, onLoad) {
    if (typeof sources === "string") {
      sources = [sources];
    }
    return this.loadAssets(sources, onLoad);
  };

  BatchLoader.prototype.addAsset = function(source, asset) {
    var base;
    if (asset == null) {
      throw new Error("not a valid asset: " + (inspect(asset)));
    }
    delete this.loadingAssets[source];
    (base = this.assets)[source] || (base[source] = asset);
    return this.notifyListeners();
  };

  BatchLoader.getter({
    blankInfo: function() {
      return {
        loadedFromCache: 0,
        loadedAsynchronously: 0,
        alreadyLoadingAsynchronously: 0
      };
    }
  });

  BatchLoader.prototype.loadAssets = function(sources, onLoad) {
    var info;
    info = this.blankInfo;
    sources.forEach((function(_this) {
      return function(src) {
        if (_this.assets[src] != null) {
          return info.loadedFromCache++;
        } else if (_this.loadingAssets[src]) {
          info.loadedAsynchronously++;
          return info.alreadyLoadingAsynchronously++;
        } else {
          info.loadedAsynchronously++;
          _this.loadingAssets[src] = true;
          return _this.loadFunction(src, function(src, asset) {
            return _this.addAsset(src, asset);
          });
        }
      };
    })(this));
    this.addLoaderListener(sources, onLoad, info);
    return nextTick((function(_this) {
      return function() {
        return _this.notifyListeners();
      };
    })(this));
  };

  BatchLoader.prototype.addLoaderListener = function(sources, onLoad, info) {
    this.loadingListeners || (this.loadingListeners = []);
    return this.loadingListeners.push({
      sources: sources,
      onLoad: onLoad,
      info: info
    });
  };

  BatchLoader.prototype.notifyListeners = function() {
    var allLoaded, i, j, len, len1, listener, oldloadingListeners, ref, source;
    if (!this.loadingListeners) {
      return;
    }
    oldloadingListeners = this.loadingListeners;
    this.loadingListeners = [];
    for (i = 0, len = oldloadingListeners.length; i < len; i++) {
      listener = oldloadingListeners[i];
      allLoaded = true;
      ref = listener.sources;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        source = ref[j];
        if (!this.assets[source]) {
          allLoaded = false;
        }
      }
      if (allLoaded) {
        listener.onLoad(this.assets, listener.sources, listener.info);
      } else {
        this.loadingListeners.push(listener);
      }
    }
    return this.loadingListeners;
  };

  return BatchLoader;

})(BaseObject);


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var defineModule, fastBind, isFunction, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(0), defineModule = ref.defineModule, isFunction = ref.isFunction, fastBind = ref.fastBind, log = ref.log;

defineModule(module, function() {
  return function(superClass) {
    var InstanceFunctionBindingMixin;
    return InstanceFunctionBindingMixin = (function(superClass1) {
      extend(InstanceFunctionBindingMixin, superClass1);

      function InstanceFunctionBindingMixin() {
        return InstanceFunctionBindingMixin.__super__.constructor.apply(this, arguments);
      }

      InstanceFunctionBindingMixin.getFunctionsToBindList = function() {
        if (this.hasOwnProperty("_functionsToBindList")) {
          return this._functionsToBindList;
        } else {
          return this._functionsToBindList = this.getFunctionsToBindList();
        }
      };

      InstanceFunctionBindingMixin.getFunctionsToBindList = function() {
        var k, ref1, results, v;
        ref1 = this.prototype;
        results = [];
        for (k in ref1) {
          v = ref1[k];
          if (k !== "constructor" && isFunction(v) && this.propertyIsConcrete(k) && (!this.nonBindingFunctions || indexOf.call(this.nonBindingFunctions, k) < 0)) {
            results.push(k);
          }
        }
        return results;
      };

      InstanceFunctionBindingMixin.prototype.getBoundFunctionList = function() {
        return this._boundFunctionList;
      };

      InstanceFunctionBindingMixin.prototype.bindFunctionsToInstance = function() {
        var functionsToBindList, i, j, k, len, len1, prototype, ref1;
        functionsToBindList = this["class"].getFunctionsToBindList();
        if (this._boundFunctionList) {
          ref1 = this._boundFunctionList;
          for (i = 0, len = ref1.length; i < len; i++) {
            k = ref1[i];
            if (indexOf.call(functionsToBindList, k) < 0) {
              delete this[k];
            }
          }
        }
        prototype = this["class"].prototype;
        for (j = 0, len1 = functionsToBindList.length; j < len1; j++) {
          k = functionsToBindList[j];
          this[k] = fastBind(prototype[k], this);
        }
        return this._boundFunctionList = functionsToBindList;
      };

      return InstanceFunctionBindingMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var AsyncLocalStorage, BaseObject, ClassSystem, JsonStore, Promise, isNumber, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), log = ref.log, Promise = ref.Promise, isNumber = ref.isNumber;

ClassSystem = __webpack_require__(3);

AsyncLocalStorage = __webpack_require__(128);

BaseObject = ClassSystem.BaseObject;

module.exports = JsonStore = (function(superClass) {
  extend(JsonStore, superClass);

  function JsonStore(store) {
    if (store == null) {
      store = AsyncLocalStorage;
    }
    this.store = store;
  }

  JsonStore.prototype.setItem = function(k, v) {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.setItem(k, JSON.stringify(v));
      };
    })(this));
  };

  JsonStore.prototype.getItem = function(key) {
    return Promise.resolve(this.store.getItem(key)).then((function(_this) {
      return function(jsonValue) {
        return Promise.then(function() {
          return jsonValue && JSON.parse(jsonValue);
        })["catch"](function(error) {
          log.error({
            JsonStore: {
              key: key,
              jsonValue: jsonValue,
              error: error
            }
          });
          throw error;
        });
      };
    })(this));
  };

  JsonStore.prototype.removeItem = function(k) {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.removeItem(k);
      };
    })(this));
  };

  JsonStore.prototype.clear = function() {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.clear();
      };
    })(this));
  };

  JsonStore.prototype.key = function(i) {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.key(i);
      };
    })(this));
  };

  JsonStore.prototype.getLength = function() {
    return Promise.then((function(_this) {
      return function() {
        if (isNumber(_this.store.length)) {
          return _this.store.length;
        } else {
          return _this.store.getLength();
        }
      };
    })(this));
  };

  return JsonStore;

})(BaseObject);


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, StandardLib, Stat, inspect, max, min, round,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(0);

ClassSystem = __webpack_require__(3);

BaseObject = ClassSystem.BaseObject;

min = StandardLib.min, max = StandardLib.max, round = StandardLib.round, inspect = StandardLib.inspect;

module.exports = Stat = (function(superClass) {
  extend(Stat, superClass);

  function Stat() {
    this.reset();
  }

  Stat.prototype.reset = function() {
    this.values = [];
    this.sum = 0;
    return this.max = this.min = null;
  };

  Stat.getter({
    length: function() {
      return this.values.length;
    },
    average: function() {
      return this.sum / this.values.length;
    },
    median: function() {
      return this.values.slice().sort()[this.length / 2 | 0];
    }
  });

  Stat.prototype.percential = function(zeroToOneHundred) {
    var i, sorted;
    i = ((this.length - 1) * zeroToOneHundred / 100) | 0;
    sorted = this.values.slice().sort(function(v1, v2) {
      return v2 - v1;
    });
    return sorted[i];
  };

  Stat.prototype.histogram = function(divisions, min, max) {
    var bin, delta, hist, j, k, len, mul, ref, ref1, v;
    if (min == null) {
      min = this.min;
    }
    if (max == null) {
      max = this.max;
    }
    delta = max - min;
    mul = divisions / delta;
    hist = {};
    for (v = j = 0, ref = divisions; j < ref; v = j += 1) {
      hist[min + v / mul] = 0;
    }
    ref1 = this.values;
    for (k = 0, len = ref1.length; k < len; k++) {
      v = ref1[k];
      bin = (v - min) * mul | 0;
      if (bin < 0) {
        bin = 0;
      }
      if (bin >= divisions) {
        bin = divisions - 1;
      }
      hist[min + bin / mul]++;
    }
    return hist;
  };

  Stat.prototype.toString = function() {
    return inspect({
      length: this.length,
      average: this.average,
      median: this.median,
      min: this.min,
      max: this.max
    });
  };

  Stat.prototype.toInfoMap = function() {
    return {
      length: this.length,
      average: this.average,
      median: this.median,
      min: this.min,
      max: this.max,
      p90: this.percential(90),
      p95: this.percential(95),
      p99: this.percential(99)
    };
  };

  Stat.prototype.toIntInfoMap = function() {
    return {
      length: this.length,
      average: round(this.average),
      median: round(this.median),
      min: round(this.min),
      max: round(this.max),
      p90: round(this.percential(90)),
      p95: round(this.percential(95)),
      p99: round(this.percential(99))
    };
  };

  Stat.prototype.toIntString = function() {
    return inspect(this.toIntInfoMap());
  };

  Stat.prototype.add = function(v) {
    this.values.push(v);
    this.sum += v;
    if (this.values.length === 1) {
      return this.max = this.min = v;
    } else {
      this.max = max(this.max, v);
      return this.min = min(this.min, v);
    }
  };

  return Stat;

})(BaseObject);


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [
  [__webpack_require__(130), "executePromiseSequence"], __webpack_require__(40), __webpack_require__(129), __webpack_require__(135), {
    CommunicationStatus: __webpack_require__(8),
    RestClient: __webpack_require__(21),
    Validator: __webpack_require__(17).Validator
  }
];


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {


/*
Transaction provides a manual, yet easy way to log the before and after values
of fields over many objects.

It is "manual" in that you must:

  Pre-specify all objects you wish to track.
  Specify the properties you wish to track for all objects and/or uniquely for each object.
  Pass in the "from" values or call saveFromValues
  Pass in the "to" values or call saveToValues

Once you have capture the "from" and "to" values of the transaction, you can:

  rollBack and set all properties to their "from" values
  rollForward and set all properties to their "to" values
  interpolate(p) and set all properties to their linearly interpolated value
    between their saved "from" (p=0) and "to" (p=1) values.
    If you use interpolate:
      to/from values should be pair-wise the same type
      only to/from values of the following types will be interpolated:
        numbers
        objects implementing: a.add(b), a.sub(b) and a.mul(number)
      Non-interpolatable types are handled as follows:
        switch p
          when 0 then set to "from" values
          when 1 then set to "to" values
          else left unchanged

Example initializers:

   * example-a: track obj's "foo" and "bar" properties
  new Transaction obj, properties: ["foo", "bar"]

   * same as example-a, but also initialize obj's from-values as obj.foo=1 and obj.bar=2
  new Transaction obj, from: foo:1, bar:2

   * same as example-a, but also initialize obj's to-values as obj.foo=1 and obj.bar=2
  new Transaction obj, to: foo:1, bar:2

   * track obj1 and obj2's "foo" and "bar" properties
  new Transaction [obj1, obj2], properties: ["foo", "bar"]

   * track:
   *   obj1's foo, bar, noo and mar properties, with both from and to values initialized
   *   obj2's goo, har, noo and mar properties, with both from and to values initialized
  new Transaction [
      [obj1,
        from: foo:1, bar:2
        to:   foo:2, bar:3
      ],
      [obj2,
        from: goo:1, har:2
        to:   goo:2, har:3
      ]
    ],
    from: noo:4, mar:5
    to:   noo:4, mar:5
 */
var BaseClass, Map, SingleObjectTransaction, Transaction, cloneByStructure, eq, inspect, mapToKeysArray, mapToValuesArray, ref, rubyTrue,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), rubyTrue = ref.rubyTrue, eq = ref.eq, inspect = ref.inspect, Map = ref.Map, cloneByStructure = ref.cloneByStructure, mapToKeysArray = ref.mapToKeysArray, mapToValuesArray = ref.mapToValuesArray;

BaseClass = __webpack_require__(3).BaseClass;

SingleObjectTransaction = __webpack_require__(131);

module.exports = Transaction = (function(superClass) {
  extend(Transaction, superClass);

  Transaction.SingleObjectTransaction = SingleObjectTransaction;

  function Transaction(objects, options) {
    if (options == null) {
      options = {};
    }
    Transaction.__super__.constructor.apply(this, arguments);
    this._objects = new Map;
    if (objects.constructor === Array) {
      this.addObjects(objects);
    } else {
      this.addObject(objects);
    }
    if (options.properties) {
      this.addProperties(options.properties);
    }
    if (options.property) {
      this.addProperties([options.property]);
    }
    if (options.from) {
      this.addFromValues(options.from);
    }
    if (options.to) {
      this.addToValues(options.to);
    }
    this.saveFromValues();
  }

  Transaction.prototype.inspect = function(inspector) {
    if (!inspector) {
      return ClassSystem.Inspect.inspect(this);
    }
    inspector.put(this.classPathName + ":");
    return this.inspectParts(inspector);
  };

  Transaction.prototype.inspectParts = function(inspector) {
    return this._objects.each((function(_this) {
      return function(k, v) {
        inspector.put("\n  ");
        return inspector.inspect(v);
      };
    })(this));
  };

  Transaction.getter({
    objects: function() {
      return mapToKeysArray(this._objects);
    }
  });

  Transaction.prototype.properties = function(obj) {
    return this._objects.get(obj).properties;
  };

  Transaction.prototype.from = function(obj) {
    return this._objects.get(obj).from;
  };

  Transaction.prototype.to = function(obj) {
    return this._objects.get(obj).to;
  };

  Transaction.prototype.rollBack = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.rollBack();
      };
    })(this));
  };

  Transaction.prototype.rollForward = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.rollForward();
      };
    })(this));
  };

  Transaction.prototype.interpolate = function(p) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.interpolate(p);
      };
    })(this));
  };

  Transaction.prototype.optimize = function() {
    this.optimizeProperties();
    return this.optimizeObjects();
  };

  Transaction.getter({
    hasToValues: function() {
      var result;
      result = false;
      this._objects.forEach((function(_this) {
        return function(oi) {
          if (oi.hasToValues) {
            return result = true;
          }
        };
      })(this));
      return result;
    },
    valuesChanged: function() {
      var result;
      result = false;
      this._objects.forEach((function(_this) {
        return function(object) {
          if (object.valuesChanged) {
            return result = true;
          }
        };
      })(this));
      return result;
    }
  });

  Transaction.prototype.toString = function() {
    return (this.className + "\n  ") + (this._objects.map(function(obj, single) {
      return single.toString();
    })).join("  \n");
  };

  Transaction.prototype.addFromValues = function(from) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.addFromValues(from);
      };
    })(this));
  };

  Transaction.prototype.addToValues = function(to) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.addToValues(to);
      };
    })(this));
  };

  Transaction.prototype.addProperties = function(properties) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.addProperties(properties);
      };
    })(this));
  };

  Transaction.prototype.addObject = function(obj) {
    var oi;
    oi = new SingleObjectTransaction(obj);
    return this._objects.set(oi.object, oi);
  };

  Transaction.prototype.addObjects = function(objects) {
    var i, len, obj, results;
    results = [];
    for (i = 0, len = objects.length; i < len; i++) {
      obj = objects[i];
      results.push(this.addObject(obj));
    }
    return results;
  };

  Transaction.prototype.saveFromValues = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.saveFromValues();
      };
    })(this));
  };

  Transaction.prototype.saveToValues = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.saveToValues();
      };
    })(this));
  };

  Transaction.prototype.optimizeProperties = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.optimizeProperties();
      };
    })(this));
  };

  Transaction.prototype.optimizeObjects = function() {
    var objs;
    objs = this._objects;
    this._objects = new Map;
    return objs.forEach((function(_this) {
      return function(oi) {
        if (!oi.noChanges) {
          return _this._objects.set(oi.object, oi);
        }
      };
    })(this));
  };

  return Transaction;

})(BaseClass);


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(41);

module.exports.includeInNamespace(__webpack_require__(242)).addModules({
  ArtFoundationConfig: __webpack_require__(234)
});

__webpack_require__(124);

__webpack_require__(241);

__webpack_require__(133);


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var ObjectTreeFactory, compactFlatten, fastBind, isClass, isFunction, isPlainObject, log, mergeIntoBasic, ref, ref1, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(0), compactFlatten = ref.compactFlatten, log = ref.log, upperCamelCase = ref.upperCamelCase, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, isClass = ref.isClass;

mergeIntoBasic = function(into, source) {
  var k, v;
  for (k in source) {
    v = source[k];
    into[k] = v;
  }
  return into;
};

ref1 = __webpack_require__(0), isFunction = ref1.isFunction, fastBind = ref1.fastBind;

module.exports = ObjectTreeFactory = (function() {
  var compactFlattenObjectTreeNodeNames, deepArgsProcessing, nodeNameRegexp, preprocessElementBasic;

  function ObjectTreeFactory() {}

  deepArgsProcessing = function(array, children) {
    var el, i, len;
    for (i = 0, len = array.length; i < len; i++) {
      el = array[i];
      if (el) {
        if (el.constructor === Array) {
          deepArgsProcessing(el, children);
        } else {
          children.push(el);
        }
      }
    }
    return null;
  };


  /*
  IN: any order of args which are:
    plainObject-options: (optional)
      mergePropsInto: (intoProps, fromProps) ->
        function to merge arguments 1 on into props
        default: mergeIntoBasic
  
      inspectedName: string
        for introspection:
          Factory.getName() == inspectedName
  
      class: a class
        if specified, additioanl properties will be set on the Factory function:
          Factory.class = class
          Factory._name = class.getName() + "Factory"
  
          all concrete class-methods are made available in the Factory
          (see BaseObject.abstractClass)
  
      bind: string or array of strings
        NODE: class must be set
        list of method-names to bind from class onto the factory
  
      preprocessElement: (element) -> element
        can do custom preprocssing of each argument to the factory.
  
  
        defualt: preprocessElementBasic (no-op)
  
    function-nodeFactory: (optional) ->
      IN:
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node
  
    class-nodeClass: class Foo extends BaseObject
  
  OUT: objectTreeFactory = ->
    IN:
      Arguments are compacted and flattened
      The resulting list of arguments can be any combination of:
        plainObjects for props (merged in the order they appear)
        other objects which become the 'children'
  
    OUT:
      object-tree-node generated by the nodeFactory
   */

  preprocessElementBasic = function(a) {
    return a;
  };

  ObjectTreeFactory.createObjectTreeFactory = function() {
    var Factory, TreeFactoryNode, a, abstractClass, bindList, i, inspectedName, j, k, klass, len, len1, mergePropsInto, nodeFactory, options, preprocessElement, v;
    for (i = 0, len = arguments.length; i < len; i++) {
      a = arguments[i];
      if (a != null) {
        switch (false) {
          case !isClass(a):
            klass = a;
            break;
          case !isFunction(a):
            nodeFactory = a;
            break;
          case !isPlainObject(a):
            options = a;
        }
      }
    }
    options || (options = {});
    klass || (klass = options["class"]);
    nodeFactory || (nodeFactory = true ? (klass || (klass = TreeFactoryNode = (function(superClass) {
      extend(TreeFactoryNode, superClass);

      function TreeFactoryNode(props1, children1) {
        this.props = props1;
        this.children = children1;
      }

      return TreeFactoryNode;

    })(BaseObject)), function(props, children) {
      return new klass(props, children);
    }) : void 0);
    mergePropsInto = options.mergePropsInto, inspectedName = options.inspectedName, preprocessElement = options.preprocessElement;
    mergePropsInto || (mergePropsInto = mergeIntoBasic);
    preprocessElement || (preprocessElement = preprocessElementBasic);
    Factory = function() {
      var children, el, j, len1, oneProps, props;
      oneProps = null;
      props = null;
      children = [];
      for (j = 0, len1 = arguments.length; j < len1; j++) {
        el = arguments[j];
        if (el = preprocessElement(el)) {
          switch (el.constructor) {
            case Object:
              if (oneProps) {
                props = {};
                mergePropsInto(props, oneProps);
                oneProps = null;
              }
              if (props) {
                mergePropsInto(props, el);
              } else {
                oneProps = el;
              }
              break;
            case Array:
              deepArgsProcessing(el, children);
              break;
            default:
              children.push(el);
          }
        }
      }
      props || (props = oneProps || {});
      return nodeFactory(props, children);
    };
    if (klass) {
      Factory["class"] = klass;
      klass.Factory = Factory;
      abstractClass = (typeof klass.getAbstractClass === "function" ? klass.getAbstractClass() : void 0) || Object;
      bindList = compactFlatten([
        (function() {
          var results;
          results = [];
          for (k in klass) {
            v = klass[k];
            if (!abstractClass[k] && isFunction(v)) {
              results.push(k);
            }
          }
          return results;
        })(), options.bind
      ]);
      inspectedName || (inspectedName = klass.getName() + "Factory");
      for (j = 0, len1 = bindList.length; j < len1; j++) {
        k = bindList[j];
        Factory[k] = fastBind(klass[k], klass);
      }
    }
    if (inspectedName) {
      Factory._name = inspectedName;
    }
    Factory.inspect = function() {
      return "<" + (inspectedName || 'ObjectTreeFactory') + ">";
    };
    return Factory;
  };


  /*
  IN:
    list: a string or abitrary structure of arrays, nulls and strings
      each string is split into tokens and each token is used as the nodeTypeName to create a Tree-factory
    nodeFactory: (nodeTypeName, props, children) -> node
      IN:
        nodeTypeName: node-type name
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node
  OUT:
    map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory
  
  TODO:
    PERFORMANCE TEST:
      createObjectTreeFactoriesFromFactories
      vs
      createObjectTreeFactoriesFromFactoryFactories
  
      The latter is probably faster. It is also more powerful and generally cleaner.
   */

  ObjectTreeFactory.createObjectTreeFactories = function(options, list, nodeFactory) {
    var ref2;
    if (!nodeFactory) {
      ref2 = [options, list], list = ref2[0], nodeFactory = ref2[1];
      options = {};
    }
    if (nodeFactory.length === 1) {
      return ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories(options, list, nodeFactory);
    } else {
      return ObjectTreeFactory._createObjectTreeFactoriesFromFactories(options, list, nodeFactory);
    }
  };

  ObjectTreeFactory._createObjectTreeFactoriesFromFactories = function(options, list, nodeFactory) {
    var fn, i, len, nodeTypeName, out, ref2, suffix;
    suffix = options.suffix || '';
    out = {};
    ref2 = compactFlattenObjectTreeNodeNames(list);
    fn = function(nodeTypeName) {
      options.inspectedName = nodeTypeName;
      return out[upperCamelCase(nodeTypeName) + suffix] = ObjectTreeFactory.createObjectTreeFactory(options, function(props, children) {
        return nodeFactory(nodeTypeName, props, children);
      });
    };
    for (i = 0, len = ref2.length; i < len; i++) {
      nodeTypeName = ref2[i];
      fn(nodeTypeName);
    }
    return out;
  };

  nodeNameRegexp = /[a-z0-9_]+/ig;

  ObjectTreeFactory._compactFlattenObjectTreeNodeNames = compactFlattenObjectTreeNodeNames = function(list) {
    var i, len, out, ref2, str;
    if (typeof list === "string") {
      return list.match(nodeNameRegexp);
    }
    out = [];
    ref2 = compactFlatten(list);
    for (i = 0, len = ref2.length; i < len; i++) {
      str = ref2[i];
      out = out.concat(str.match(nodeNameRegexp));
    }
    return out;
  };

  ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories = function(options, list, nodeFactoryFactory) {
    var i, len, name, nodeFactory, nodeTypeName, out, ref2, suffix;
    suffix = options.suffix || '';
    out = {};
    ref2 = compactFlattenObjectTreeNodeNames(list);
    for (i = 0, len = ref2.length; i < len; i++) {
      nodeTypeName = ref2[i];
      nodeFactory = nodeFactoryFactory(nodeTypeName);
      name = upperCamelCase(nodeTypeName) + suffix;
      options.inspectedName = name;
      out[name] = ObjectTreeFactory.createObjectTreeFactory(options, nodeFactory);
    }
    return out;
  };

  return ObjectTreeFactory;

})();


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(253);

module.exports.includeInNamespace(__webpack_require__(251));


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var ObjectTreeFactory,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.ObjectTreeFactory', ObjectTreeFactory = (function(superClass) {
  extend(ObjectTreeFactory, superClass);

  function ObjectTreeFactory() {
    return ObjectTreeFactory.__super__.constructor.apply(this, arguments);
  }

  ObjectTreeFactory.version = __webpack_require__(294).version;

  return ObjectTreeFactory;

})(Neptune.PackageNamespace));


/***/ }),
/* 254 */
/***/ (function(module, exports) {




/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Promise, RequestError, RestClient, StandardLib, aborted, appendQuery, capitalizedDashCase, decodeHttpStatus, each, failureTypes, formattedInspect, isNumber, log, merge, networkFailure, object, objectKeyCount, objectWithout, present, ref, ref1, serverFailure, success, timeout, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(0);

ref = __webpack_require__(0), objectWithout = ref.objectWithout, formattedInspect = ref.formattedInspect, present = ref.present, Promise = ref.Promise, merge = ref.merge, isNumber = ref.isNumber, timeout = ref.timeout, log = ref.log, objectKeyCount = ref.objectKeyCount, appendQuery = ref.appendQuery, object = ref.object, RequestError = ref.RequestError, object = ref.object, w = ref.w, capitalizedDashCase = ref.capitalizedDashCase, each = ref.each;

ref1 = __webpack_require__(8), networkFailure = ref1.networkFailure, success = ref1.success, serverFailure = ref1.serverFailure, aborted = ref1.aborted, failureTypes = ref1.failureTypes, decodeHttpStatus = ref1.decodeHttpStatus;

BaseClass = __webpack_require__(3).BaseClass;

__webpack_require__(254);

module.exports = RestClient = (function(superClass) {
  var legalVerbs, normalizeHeaders;

  extend(RestClient, superClass);

  function RestClient() {
    return RestClient.__super__.constructor.apply(this, arguments);
  }

  RestClient.singletonClass();

  RestClient.RestClientClass = RestClient;

  RestClient.legalVerbs = legalVerbs = {};

  each(w("get put post delete head"), function(v) {
    var upper;
    upper = v.toUpperCase();
    return legalVerbs[v.toLowerCase()] = legalVerbs[upper] = upper;
  });

  RestClient.get = function(url, options) {
    return RestClient.singleton.get(url, options);
  };

  RestClient.put = function(url, data, options) {
    return RestClient.singleton.put(url, data, options);
  };

  RestClient.post = function(url, data, options) {
    return RestClient.singleton.post(url, data, options);
  };

  RestClient["delete"] = function(url, options) {
    return RestClient.singleton["delete"](url, options);
  };

  RestClient.getArrayBuffer = function(url, options) {
    return RestClient.singleton.getArrayBuffer(url, options);
  };

  RestClient.getJson = function(url, options) {
    return RestClient.singleton.getJson(url, options);
  };

  RestClient.deleteJson = function(url, options) {
    return RestClient.singleton.deleteJson(url, options);
  };

  RestClient.putJson = function(url, data, options) {
    return RestClient.singleton.putJson(url, data, options);
  };

  RestClient.postJson = function(url, data, options) {
    return RestClient.singleton.postJson(url, data, options);
  };

  RestClient.restRequest = function(options) {
    return RestClient.singleton.restRequest(options);
  };

  RestClient.restJsonRequest = function(options) {
    return RestClient.singleton.restJsonRequest(options);
  };


  /*
  get/put/post/delete
  
  IN:
    url: valid url string
  
    data: (only on PUT/POST requests)
      data to send
      NOTE: must be null if using formData
  
    options:
  
      formData: plain object of key-value pairs to submit as form-data
        You can even use this for "get" requests.
        NOTE: "data" must be null if using "formData"
  
      headers: plain object of additional HTTP headers to set
  
      onProgress: (restRequestStatus) -> null
        called each time progress is made
        NOTE: restRequestStatus.progress contains a 0-to-1 number that indicates how much progress has been made.
          progress indicates DOWNLOAD progress for GET requests and UPLOAD progress for all others.
  
      responseType: "arraybuffer", "blob", "document", "json", or "text"
        default: "text"
        NOTE: "json" is handled manually since IE11 and iOS7 don't support the "json" option.
        https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
  
  OUT: Promise:
    resolved: (responseData) ->
    rejected: (restRequestStatus) ->
  
  responseData:
    a String, or the type specified by the responseType option
  
  restRequestStatus:
    event:    # the HTML event object
    request:  # the XMLHttpRequest
    options:  # the restRequest options: verb, url, data, headers, onProgress, responseType, formData
    httpStatus:   # the HTML status code, if the request completed
    response: # responseData
    status:       a valid CommunicationStatus
    error:    # Error object or string-explaination of why the request was rejected
    progress:
      a value between 0 and 1
      If the progress is indeterminant, this is 0
      If this isn't an onProgress event, this is the amount of progress
      that was made up to the point of the event.
   */

  RestClient.prototype.get = function(url, options) {
    return this.restRequest(merge(options, {
      verb: "GET",
      url: url
    }));
  };

  RestClient.prototype.put = function(url, data, options) {
    return this.restRequest(merge(options, {
      verb: "PUT",
      url: url,
      data: data
    }));
  };

  RestClient.prototype.post = function(url, data, options) {
    return this.restRequest(merge(options, {
      verb: "POST",
      url: url,
      data: data
    }));
  };

  RestClient.prototype["delete"] = function(url, options) {
    return this.restRequest(merge(options, {
      verb: "DELETE",
      url: url
    }));
  };

  RestClient.prototype.getArrayBuffer = function(url, options) {
    return this.restRequest(merge(options, {
      verb: "GET",
      url: url,
      responseType: "arraybuffer"
    }));
  };


  /*
  get/put/post/deleteJson
  
  same as get/put/post/delete above
  
  except:
    sent data should be plain objects which are JSON.stringified
    response data is automatically JSON.parsed
  
    additional options are set:
      responseType: "json"
      headers:      Accept: 'application/json'
   */

  RestClient.prototype.getJson = function(url, options) {
    return this.restJsonRequest(merge(options, {
      verb: "get",
      url: url
    }));
  };

  RestClient.prototype.deleteJson = function(url, options) {
    return this.restJsonRequest(merge(options, {
      verb: "delete",
      url: url
    }));
  };

  RestClient.prototype.putJson = function(url, data, options) {
    return this.restJsonRequest(merge(options, {
      verb: "put",
      url: url,
      data: data
    }));
  };

  RestClient.prototype.postJson = function(url, data, options) {
    return this.restJsonRequest(merge(options, {
      verb: "post",
      url: url,
      data: data
    }));
  };


  /*
  IN:
    options:
      verb: "GET", "PUT", "POST"
      method: alias for verb
  
      data: data to restRequest - passed to xmlHttpRequest.restRequest
      body: alias for data
  
      plus all the options for get/put/post listed above
      showProgressAfter: milliseconds (default: 100)
        only show progress after # milliseconds
  
      onProgress: (requestStatus) ->
        see "All callbacks" below for details about inputs.
        Note that onProgress is triggered a little differently than
        the normal XMLHttpRequest progress events:
          - it will only be called after showProgressAfter ms
          - it is guaranteed to be called after showProgressAfter ms if the request hasn't completed
          - if the request completes before showProgressAfter ms, it will never be called
  
  OUT: see get/put/post above
  
  All callbacks look like this: (requestStatus) ->
    requestStatus:
      request:  XMLHttpRequest
      progress: number # between 0 and 1
      options:  options # passed-in options object
      event:    the most recent event
      response: # the processed response data, if ready
      error:    # if any
      httpStatus:   number # HTTP status code, if the request is complete
  
  EFFECT:
   */

  RestClient.prototype.restRequest = function(options) {
    var body, data, formData, headers, k, method, onProgress, query, responseType, showProgressAfter, specifiedVerb, url, v, verb, verbose;
    verb = options.verb, verbose = options.verbose, method = options.method, url = options.url, data = options.data, body = options.body, query = options.query, headers = options.headers, onProgress = options.onProgress, responseType = options.responseType, formData = options.formData, showProgressAfter = options.showProgressAfter;
    if (!isNumber(showProgressAfter)) {
      showProgressAfter = 100;
    }
    method || (method = verb);
    body || (body = data);
    if (!(method = RestClient.legalVerbs[specifiedVerb = method])) {
      throw new Error("invalid method: " + specifiedVerb);
    }
    if (formData) {
      if (body) {
        throw new Error("can't specify both 'body' and 'formData'");
      }
      body = new FormData;
      for (k in formData) {
        v = formData[k];
        body.append(k, v);
      }
    } else {
      body = (body != null ? typeof body.toArrayBuffer === "function" ? body.toArrayBuffer() : void 0 : void 0) || body;
    }
    if (method === "GET" && body) {
      log.error({
        RestClient_restRequest: {
          info: "can't GET with body",
          options: options
        }
      });
      throw new Error("With their ultimate wisdom, the gods decree: NO DATA WITH GET");
    }
    if (query) {
      url = appendQuery(url, query);
    }
    return this._normalizedRestRequest({
      verbose: verbose,
      method: method,
      url: url,
      body: body,
      onProgress: onProgress,
      responseType: responseType,
      showProgressAfter: showProgressAfter,
      headers: normalizeHeaders(headers)
    });
  };

  RestClient.normalizeHeaders = normalizeHeaders = function(headers) {
    return object(headers, {
      key: function(v, k) {
        return capitalizedDashCase(k);
      }
    });
  };

  RestClient.prototype.restJsonRequest = function(options) {
    var data, headers, method, verb;
    verb = options.verb, method = options.method, data = options.data, headers = options.headers;
    verb = RestClient.legalVerbs[verb || method];
    if (data && objectKeyCount(data) === 0) {
      data = null;
    }
    if (verb === "GET" && options.data) {
      options = merge(options, {
        url: appendQuery(options.url, object(data, function(v) {
          return JSON.stringify(v);
        }))
      });
      data = null;
    } else {
      data && (data = JSON.stringify(data));
    }
    return this.restRequest(merge(options, {
      responseType: "json",
      headers: merge({
        Accept: 'application/json',
        "Content-Type": 'application/json'
      }, headers),
      data: data
    }));
  };

  RestClient.prototype._normalizedRestRequest = function(options) {
    var body, headers, method, onProgress, responseType, showProgressAfter, url, verbose;
    method = options.method, url = options.url, body = options.body, headers = options.headers, onProgress = options.onProgress, responseType = options.responseType, showProgressAfter = options.showProgressAfter, verbose = options.verbose;
    return new Promise(function(resolve, reject) {
      var fail, getErrorResponse, getResponse, initialProgressCalled, k, lastProgressEvent, progressCallbackInternal, request, requestResolved, restRequestStatus, v;
      fail = function(props) {
        return reject(new RequestError(merge(props, {
          sourceLib: "ArtRestClient",
          body: body,
          headers: headers,
          responseType: responseType,
          key: url,
          type: method,
          progress: restRequestStatus.progress
        })));
      };
      restRequestStatus = {
        request: request = new XMLHttpRequest,
        progress: 0,
        options: options,
        abort: function() {
          request.abort();
          return fail({
            status: aborted,
            message: "XMLHttpRequest aborted"
          });
        }
      };
      getErrorResponse = function() {
        var error;
        try {
          return getResponse();
        } catch (error1) {
          error = error1;
          return {
            status: serverFailure,
            rawResponse: request.response,
            message: "ArtRestClient: Error parsing server's response: " + error + "\nrawResponse: " + request.response
          };
        }
      };
      getResponse = function() {
        var response;
        response = request.response;
        if (response && responseType === "json") {
          return JSON.parse(response);
        } else {
          return response;
        }
      };
      request.open(method, url, true);
      if (present(responseType) && responseType !== "json") {
        request.responseType = responseType;
      }
      if (headers) {
        for (k in headers) {
          v = headers[k];
          request.setRequestHeader(k, v);
        }
      }
      requestResolved = false;
      request.addEventListener("error", function(event) {
        requestResolved = true;
        return fail({
          status: networkFailure,
          message: "XMLHttpRequest error event triggered",
          data: {
            event: event
          }
        });
      });
      request.addEventListener("load", function(event) {
        var decodedHttpStatus, httpStatus, message;
        requestResolved = true;
        decodedHttpStatus = decodeHttpStatus(httpStatus = request.status);
        if (!((decodedHttpStatus.status === success) && ((function() {
          try {
            resolve(getResponse());
            return true;
          } catch (error1) {}
        })()))) {
          message = decodedHttpStatus.status === success ? (decodedHttpStatus.status = serverFailure, "error processing successful response") : void 0;
          return fail(merge(decodedHttpStatus, {
            message: message,
            event: event,
            data: getErrorResponse()
          }));
        }
      });
      if (onProgress) {
        initialProgressCalled = showProgressAfter <= 0;
        lastProgressEvent = null;
        timeout(showProgressAfter, function() {
          initialProgressCalled = true;
          return progressCallbackInternal(lastProgressEvent || {});
        });
        progressCallbackInternal = function(event) {
          var loaded, ref2, total;
          ref2 = lastProgressEvent = event, total = ref2.total, loaded = ref2.loaded;
          if (initialProgressCalled && !requestResolved) {
            return typeof onProgress === "function" ? onProgress(restRequestStatus = merge(restRequestStatus, {
              event: event,
              progress: total > 0 ? loaded / total : 0
            })) : void 0;
          }
        };
        if (method === "GET") {
          request.addEventListener("progress", progressCallbackInternal);
        } else {
          request.upload.addEventListener("progress", progressCallbackInternal);
        }
      }
      if (verbose) {
        log("ArtRestClient: " + method + " " + url);
      }
      return request.send(body);
    });
  };

  return RestClient;

})(BaseClass);


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(257);

module.exports.includeInNamespace(__webpack_require__(255));


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var RestClient,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.RestClient', RestClient = (function(superClass) {
  extend(RestClient, superClass);

  function RestClient() {
    return RestClient.__super__.constructor.apply(this, arguments);
  }

  RestClient.version = __webpack_require__(295).version;

  return RestClient;

})(Neptune.PackageNamespace));


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var ref, ref1, ref2;

module.exports = (ref = typeof Neptune !== "undefined" && Neptune !== null ? (ref1 = Neptune.Art) != null ? (ref2 = ref1.StandardLib) != null ? ref2.Core : void 0 : void 0 : void 0) != null ? ref : __webpack_require__(7);


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(26);


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [__webpack_require__(43), __webpack_require__(139), __webpack_require__(138), __webpack_require__(26)];


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {


/*
TODO: refactor so nothing in inspect/* uses BaseObject
Then, move into StandardLib.
 */
module.exports = [[__webpack_require__(69), "shallowInspect inspectLean inspect"], __webpack_require__(144), __webpack_require__(68), __webpack_require__(147), __webpack_require__(44)];


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var Array, MinimalBaseObject,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(15);

module.exports = Array = (function(superClass) {
  extend(Array, superClass);

  function Array(inspectedArray) {
    Array.__super__.constructor.apply(this, arguments);
    this.array = inspectedArray;
  }

  Array.getter({
    arrayOfStrings: function() {
      var i, len, ref, results, v;
      ref = this.array;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        results.push(v.toString());
      }
      return results;
    },
    children: function() {
      return this.array.slice();
    }
  });

  Array.prototype.delimitedString = function(delimiter) {
    if (delimiter == null) {
      delimiter = ", ";
    }
    return this.arrayOfStrings.join(", ");
  };

  Array.prototype.toString = function() {
    return "[" + (this.delimitedString()) + "]";
  };

  return Array;

})(MinimalBaseObject);


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

var Core, MinimalBaseObject,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(15);

module.exports = Core = (function(superClass) {
  extend(Core, superClass);

  function Core(value) {
    Core.__super__.constructor.apply(this, arguments);
    this.value = value;
    if (value && value.constructor.name === "HTMLImageElement") {
      this.image = value;
    }
  }

  Core.getter({
    children: function() {
      return null;
    }
  });

  Core.prototype.toString = function() {
    return "" + this.value;
  };

  return Core;

})(MinimalBaseObject);


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var MinimalBaseObject, Object,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(15);

module.exports = Object = (function(superClass) {
  extend(Object, superClass);

  function Object(properties, instanceOf, originalObject) {
    this.properties = properties;
    this.instanceOf = instanceOf;
    this.originalObject = originalObject;
    Object.__super__.constructor.apply(this, arguments);
    this.length = this.properties ? self.Object.keys(this.properties).length : 0;
  }

  Object.getter({
    arrayOfStrings: function() {
      var k, ref, results, v;
      ref = this.properties;
      results = [];
      for (k in ref) {
        v = ref[k];
        results.push(k + ": " + v);
      }
      return results;
    },
    children: function() {
      var k, ref, ret, v;
      ret = {};
      ref = this.properties;
      for (k in ref) {
        v = ref[k];
        ret[k] = v;
      }
      return ret;
    }
  });

  Object.prototype.delimitedString = function(delimiter) {
    if (delimiter == null) {
      delimiter = ", ";
    }
    return this.arrayOfStrings.join(", ");
  };

  Object.prototype.toString = function() {
    if (this.inspected) {
      return this.inspected;
    } else if (this.instanceOf) {
      return "{" + this.instanceOf + " " + (this.delimitedString()) + "}";
    } else {
      return "{" + (this.delimitedString()) + "}";
    }
  };

  return Object;

})(MinimalBaseObject);


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

var MinimalBaseObject, String, escapeJavascriptString,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(15);

escapeJavascriptString = __webpack_require__(16).escapeJavascriptString;

module.exports = String = (function(superClass) {
  extend(String, superClass);

  function String(clonedString) {
    String.__super__.constructor.apply(this, arguments);
    this.string = clonedString;
  }

  String.prototype.toString = function() {
    return escapeJavascriptString(this.string);
  };

  return String;

})(MinimalBaseObject);


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var Inspected, Inspector2, Map, MinimalBaseObject, escapeJavascriptString, isArray, isBrowserObject, isClass, isDate, isFunction, isHTMLImageElement, isObject, isPlainObject, isRegExp, isString, objectName, parentString, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(15);

Map = __webpack_require__(46);

Inspected = __webpack_require__(145);

escapeJavascriptString = __webpack_require__(16).escapeJavascriptString;

ref = __webpack_require__(4), isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isPlainObject = ref.isPlainObject, isClass = ref.isClass, isDate = ref.isDate, isRegExp = ref.isRegExp, objectName = ref.objectName, isBrowserObject = ref.isBrowserObject;

isHTMLImageElement = self.HTMLImageElement ? function(obj) {
  return obj instanceof HTMLImageElement;
} : function() {
  return false;
};

parentString = (function(_this) {
  return function(distance) {
    switch (distance) {
      case 0:
        return "parent";
      case 1:
        return "grandparent";
      case 2:
        return "great grandparent";
      default:
        return "great^" + (distance - 1) + " grandparent";
    }
  };
})(this);

module.exports = Inspector2 = (function(superClass) {
  extend(Inspector2, superClass);

  function Inspector2(options) {
    if (options == null) {
      options = {};
    }
    this.inspectObject = bind(this.inspectObject, this);
    this.inspectWithToImage = bind(this.inspectWithToImage, this);
    this.inspectHTMLImageElement = bind(this.inspectHTMLImageElement, this);
    this.inspectArray = bind(this.inspectArray, this);
    this.withImages = options.withImages;
    this.maxLength = options.maxLength || 1000;
    this.allowCustomInspectors = !options.noCustomInspectors;
    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
    this.outArray = [];
    this.length = 0;
    this.depth = 0;
    this.inspectingMap = new Map;
  }

  Inspector2.prototype.inspectArray = function(array) {
    var a;
    return new Inspected.Array((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = array.length; i < len; i++) {
        a = array[i];
        results.push(this.inspectInternal(a));
      }
      return results;
    }).call(this));
  };

  Inspector2.prototype.inspectHTMLImageElement = function(obj) {
    var res;
    res = new Inspected.Object({}, "HTMLImageElement", obj);
    if (!(res.image = obj).complete) {
      this.addPendingTask();
      obj.onload = (function(_this) {
        return function() {
          return _this.completePendingTask();
        };
      })(this);
    }
    return res;
  };

  Inspector2.prototype.inspectWithToImage = function(obj) {
    var name, res;
    name = objectName(obj);
    if (typeof obj.classPathName === "string") {
      name = obj.classPathName;
    }
    if (name === "Object") {
      name = null;
    }
    res = new Inspected.Object({}, name, obj);
    this.addPendingTask();
    obj.toImage().then((function(_this) {
      return function(image) {
        res.image = image;
        return _this.completePendingTask();
      };
    })(this));
    return res;
  };

  Inspector2.prototype.inspectObject = function(obj, recurse) {
    var attributes, i, k, keys, len, name, res, result;
    if (recurse == null) {
      recurse = true;
    }
    attributes = [];
    keys = Object.keys(obj);
    name = objectName(obj);
    if (isFunction(obj) && keys.length === 0) {
      return new Inspected.Core(name + "()");
    } else {
      if (typeof obj.classPathName === "string") {
        name = obj.classPathName;
      }
      if (name === "Object") {
        name = null;
      }
      result = {};
      if (recurse) {
        for (i = 0, len = keys.length; i < len; i++) {
          k = keys[i];
          result[k] = this.inspectInternal(obj[k]);
        }
      }
      res = new Inspected.Object(result, name, obj);
      if (isFunction(obj.inspect)) {
        res.inspected = obj.inspect();
      }
      return res;
    }
  };

  Inspector2.prototype.addPendingTask = function() {
    return this.pendingTasks++;
  };

  Inspector2.prototype.completePendingTask = function() {
    this.pendingTasks--;
    if (this.pendingTasks === 0) {
      return this.completionCallBack();
    }
  };

  Inspector2.prototype.inspectByType = function(obj) {
    if (isFunction(obj != null ? obj.getInspectedObjects : void 0)) {
      obj = obj.getInspectedObjects();
    }
    if (obj === null || obj === void 0 || obj === true || obj === false || typeof obj === "number") {
      return new Inspected.Core(obj);
    } else if (obj === self) {
      return new Inspected.Core("self");
    } else if (isRegExp(obj)) {
      return new Inspected.Core(obj.toString());
    } else if (isString(obj)) {
      return new Inspected.String(obj);
    } else if (isArray(obj)) {
      return this.inspectArray(obj);
    } else if (isClass(obj)) {
      return new Inspected.Core(objectName(obj));
    } else if (isHTMLImageElement(obj)) {
      return this.inspectHTMLImageElement(obj);
    } else if (isDate(obj)) {
      return new Inspected.Core(obj.toString());
    } else if (isBrowserObject(obj)) {
      return new Inspected.Core(objectName(obj));
    } else if (this.withImages && typeof obj.toImage === "function" && !isFunction(obj)) {
      return this.inspectWithToImage(obj);
    } else if (isPlainObject(obj) || isFunction(obj)) {
      return this.inspectObject(obj);
    } else if (isObject(obj)) {
      return this.inspectObject(obj, false);
    } else {
      return new Inspected.Core(objectName(obj));
    }
  };

  Inspector2.prototype.inspectInternal = function(obj) {
    var objDepth, res;
    if (objDepth = this.inspectingMap.get(obj)) {
      return new Inspected.Core("<" + (parentString(this.depth - objDepth)) + ">");
    } else if (this.depth >= this.maxDepth) {
      return new Inspected.Core("<maxDepth reached: " + this.maxDepth + ">");
    } else {
      this.depth++;
      this.inspectingMap.set(obj, this.depth);
      res = this.inspectByType(obj);
      this.inspectingMap["delete"](obj);
      this.depth--;
      return res;
    }
  };

  Inspector2.prototype.inspect = function(obj, callBack) {
    var res;
    this.pendingTasks = 0;
    if (this.withImages && typeof callBack !== "function") {
      throw new Error("callBack required if withImages requested");
    }
    this.completionCallBack = (function(_this) {
      return function() {
        return callBack && callBack(res);
      };
    })(this);
    res = this.inspectInternal(obj);
    if (this.pendingTasks === 0) {
      this.completionCallBack();
    }
    return res;
  };

  return Inspector2;

})(MinimalBaseObject);


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var RequestError, compactFlatten, defineModule, formattedInspect, isFunction, merge, mergeInto, objectWithout, ref, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defineModule = __webpack_require__(22).defineModule;

formattedInspect = __webpack_require__(23).formattedInspect;

ref = __webpack_require__(7), mergeInto = ref.mergeInto, isFunction = ref.isFunction, upperCamelCase = ref.upperCamelCase, compactFlatten = ref.compactFlatten, merge = ref.merge;

objectWithout = __webpack_require__(28).objectWithout;


/*
TODO:
  Rename: ErrorWithProps
  Rename: @info => @props

  Only
 */

defineModule(module, RequestError = (function(superClass) {
  extend(RequestError, superClass);


  /*
  IN:
    props:
      message:  error-message
      type:     request-type (for REST, the Method/Verb)
      key:      request-key (for REST, the URL)
      status:   string, see: ArtCommunicationStatus for valid strings
      data:     error-response-data, if any
   */

  function RequestError(props) {
    var message, ref1, responseData, responseDataString, sourceLib;
    RequestError.__super__.constructor.apply(this, arguments);
    ref1 = this.props = merge(props), sourceLib = ref1.sourceLib, message = ref1.message, this.requestData = ref1.requestData, this.type = ref1.type, this.key = ref1.key, this.status = ref1.status, this.data = ref1.data, responseData = ref1.responseData;
    this.responseData = this.data || (this.data = responseData);
    this.name = upperCamelCase((sourceLib || "") + " RequestError");
    if (this.props.data) {
      delete this.props.data;
      this.props.data = this.responseData;
    }
    responseDataString = this.data && formattedInspect({
      data: this.data
    });
    this.message = message || compactFlatten([
      (this.status || "failure") + ":", (responseDataString != null ? responseDataString.length : void 0) < 80 && !this.requestData ? [this.type, this.key, responseDataString] : "\n\n" + formattedInspect(merge({
        type: this.type,
        key: this.key,
        requestData: this.requestData,
        responseData: this.responseData
      }))
    ]).join(' ');
    if (this.props.stack) {
      this.stack = this.props.stack;
      this.props = objectWithout(this.props, "stack");
    } else if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = (new Error).stack;
    }
    this.info = this.props;
  }

  RequestError.prototype.toString = function() {
    return [
      this.name + " " + this.message, formattedInspect({
        props: this.props
      }, "")
    ].join("\n\n");
  };

  return RequestError;

})(Error));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [__webpack_require__(7), [__webpack_require__(29), "testPromise", "containsPromises", "deepAll"], __webpack_require__(42), __webpack_require__(136), __webpack_require__(28), __webpack_require__(16), __webpack_require__(67), __webpack_require__(143), __webpack_require__(150), __webpack_require__(149), __webpack_require__(24), __webpack_require__(27), __webpack_require__(47), __webpack_require__(151), __webpack_require__(30), __webpack_require__(152), __webpack_require__(153), __webpack_require__(154), __webpack_require__(4), __webpack_require__(22), __webpack_require__(70), __webpack_require__(23), __webpack_require__(137), __webpack_require__(148), __webpack_require__(66), __webpack_require__(141)];


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(72);

module.exports.includeInNamespace(__webpack_require__(268)).addModules({
  ArrayExtensions: __webpack_require__(42),
  AsyncExtensions: __webpack_require__(136),
  CallStack: __webpack_require__(66),
  Clone: __webpack_require__(137),
  CommonJs: __webpack_require__(22),
  DateExtensions: __webpack_require__(141),
  Environment: __webpack_require__(27),
  Eq: __webpack_require__(67),
  ErrorWithInfo: __webpack_require__(142),
  Function: __webpack_require__(143),
  Iteration: __webpack_require__(70),
  Log: __webpack_require__(148),
  Map: __webpack_require__(46),
  MapExtensions: __webpack_require__(149),
  MathExtensions: __webpack_require__(24),
  MinimalBaseObject: __webpack_require__(15),
  ObjectDiff: __webpack_require__(150),
  ObjectExtensions: __webpack_require__(28),
  ParseUrl: __webpack_require__(47),
  Promise: __webpack_require__(29),
  PromisedFileReader: __webpack_require__(151),
  RegExpExtensions: __webpack_require__(30),
  RequestError: __webpack_require__(267),
  Ruby: __webpack_require__(152),
  ShallowClone: __webpack_require__(153),
  StringExtensions: __webpack_require__(16),
  Time: __webpack_require__(154),
  TypesExtended: __webpack_require__(4),
  Unique: __webpack_require__(71)
});

__webpack_require__(7);

__webpack_require__(23);


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Promise, configure, defineModule, merge, ref;

ref = __webpack_require__(0), defineModule = ref.defineModule, Promise = ref.Promise, merge = ref.merge;

configure = __webpack_require__(33).configure;

defineModule(module, merge(__webpack_require__(155), {
  init: function(options) {
    return Promise.resolve(configure(options));
  }
}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {


/*
Used for buidling the minimal node.js code to deploy for production.
Right now, this is tested with HEROKU, but it should work in other cases.

Example user:

  require 'art-suite-app/Server'
  .start
    loadPipelines: -> require '...'

   * NOTE: loadPipelines is a function so it can get called AFTER: require "art-aws/Server"
 */
var Promise, Server, log, merge, ref;

__webpack_require__(13);

ref = __webpack_require__(0), merge = ref.merge, log = ref.log, Promise = ref.Promise;

module.exports = Server = (function() {
  function Server() {}

  Server.start = function(options) {
    var loadPipelines, postConfigInit;
    loadPipelines = options.loadPipelines, postConfigInit = options.postConfigInit;
    return Promise.then(function() {
      return (__webpack_require__(270)).init(options);
    }).then(loadPipelines).then(postConfigInit).then(function() {
      return (__webpack_require__(179)).start(merge(options, {
        numWorkers: process.env.WEB_CONCURRENCY || 1,
        port: process.env.PORT
      }));
    })["catch"](function(e) {
      return log("Error starting Art.Suite.App server", e);
    });
  };

  return Server;

})();


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var ArtAtomic, ArtClassSystem, ArtRestClient, Atomic, CommunicationStatus, Ery, Foundation, StandardLib, isNode, merge, ref;

ref = __webpack_require__(0), merge = ref.merge, isNode = ref.isNode;

module.exports = merge(Foundation, Foundation = __webpack_require__(2), ArtClassSystem = __webpack_require__(3), Atomic = __webpack_require__(79), Ery = __webpack_require__(13), CommunicationStatus = __webpack_require__(8), ArtRestClient = __webpack_require__(21), ArtAtomic = __webpack_require__(79), StandardLib = __webpack_require__(0), {
  Foundation: Foundation,
  StandardLib: StandardLib,
  Atomic: Atomic,
  Ery: Ery,
  CommunicationStatus: CommunicationStatus,
  ArtRestClient: ArtRestClient,
  ArtAtomic: ArtAtomic
});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var normalizeFieldProps, normalizeFields, ref;

ref = __webpack_require__(157), normalizeFieldProps = ref.normalizeFieldProps, normalizeFields = ref.normalizeFields;

module.exports = {
  normalizeFieldProps: normalizeFieldProps,
  normalizeFields: normalizeFields
};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(275);

module.exports.includeInNamespace(__webpack_require__(273)).addModules({
  DataTypes: __webpack_require__(48),
  FieldTypes: __webpack_require__(156),
  Validator: __webpack_require__(157)
});


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var Validation,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(5)).addNamespace('Art.Validation', Validation = (function(superClass) {
  extend(Validation, superClass);

  function Validation() {
    return Validation.__super__.constructor.apply(this, arguments);
  }

  Validation.version = __webpack_require__(297).version;

  return Validation;

})(Neptune.PackageNamespace));


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(274);


/***/ }),
/* 277 */
/***/ (function(module, exports) {

var g;

g = typeof window !== "undefined" && window !== null ? window : typeof self !== "undefined" && self !== null ? self : global;

g.global = g;


/***/ }),
/* 278 */
/***/ (function(module, exports) {

var arrayIterableTest, each, extendedEach, isNonNegativeInt;

isNonNegativeInt = function(x) {
  return ((x | 0) === x) && x >= 0;
};

arrayIterableTest = function(source) {
  return source && isNonNegativeInt(source.length) && source.constructor !== Object;
};


/*
Notes:

Comprehension loop variables are always going to mask any variables
defined in a higher scope.

With e/ee we put all the when, with and key blocks in the same function,
so they naturally share one loop-scope.
 */

module.exports = {

  /*
  IN:
    source:
      array-like (source.length is a number >= 0)
      null or undefined
      otherwise, properties are iterated
  
    out: the value that will be returned.
      out is initialized to source if out == undefined.
      This is for convenience and code-reduction in the "each-without-into-set" case.
  
    withBlock: (currentIterationValue, currentIterationKey, returning) -> ignored
  
  USE: object, array, each
   */
  each: each = function(source, out, withBlock) {
    var i, k, len, v;
    if (out === "undefined") {
      out = source;
    }
    if (source != null) {
      if (arrayIterableTest(source)) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          withBlock(v, k, out);
        }
      } else {
        for (k in source) {
          v = source[k];
          withBlock(v, k, out);
        }
      }
    }
    return out;
  },
  e: each,

  /*
  enhanced-each
  
  Different from each :
    updating-out:   out is updated with the result of every withBlock call
    break-support:  withBlock is passed a forth argument: setShouldBreak
  
    NOTE: out is only initialized to source, if out == undefined. Any updated out
    could be set to undefined and that would be returned.
  
  setShouldBreak:
    IN: ()
    OUT: the undefined value
    EFFECT: this will be the last call to withBlock &
      the value returned by this last call will be the result
      of ee.
  
  This should be enough for all features:
    - "return" - requires a setShouldReturn function in the enclosing scope, and setShouldBreak
    - "next" - becomes a return-statement in withBlock - this works with the basic "e"
    - "break" - setShouldBreak();return out;
    - "break value" - setShouldBreak();return value;
    - "reduce" iteration - needs updating-out
    - "find" iteration - needs break-with-value
  
  Cons:
    possible performance and code-size hit:
    - ee requires more code in the withBlock: {...; return out;}
    - ee creates a setShouldBreak function every time
  
    But, with testing, we may decided those don't really matter.
  
  EXAMPLES:
  
    find v from o with v > 10
  
    Caf.ee o, null, (v, k, out, brk) ->
      brk v if v > 10
  
  
    reduce v1, v2 from o with f v1, v2
  
     * I think we need to remove the out = source default.
  
    Caf.ee o, undefined, (v2, k, v1, brk) ->
      if v1 == undefined
        v2
      else
        f v1, v2
  
     * example: object v from o with v + 1
    Caf.e(o, {}, function(v, k, into) {
      return into[k] = v + 1;
    });
  
     * example: object v from o when v > 3 with v + 1
    Caf.e(o, {}, function(v, k, into) {
      if( v > 3 ) {
        return into[k] = v + 1;
      };
    });
  
     * example: object o
    Caf.e(o, {}, function(v, k, into) {
      return into[k] = v;
    });
   */
  extendedEach: extendedEach = function(source, out, withBlock) {
    var i, k, len, setShouldBreak, shouldBreak, v;
    if (out === "undefined") {
      out = source;
    }
    if (source != null) {
      shouldBreak = false;
      setShouldBreak = function() {
        shouldBreak = true;
        return void 0;
      };
      if (arrayIterableTest(source)) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          out = withBlock(v, k, out, setShouldBreak);
          if (shouldBreak) {
            break;
          }
        }
      } else {
        for (k in source) {
          v = source[k];
          out = withBlock(v, k, out, setShouldBreak);
          if (shouldBreak) {
            break;
          }
        }
      }
    }
    return out;
  },
  ee: extendedEach
};


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var _import, compactFlatten, getSuper, isDirectPrototypeOf, isFalse, isFunction, isPlainArray, isPlainObject, isTrue, ref,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

ref = __webpack_require__(158), compactFlatten = ref.compactFlatten, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject;

__webpack_require__(277);

global.__definingModule = null;

module.exports = {
  "in": function(a, b) {
    return indexOf.call(b, a) >= 0;
  },
  mod: function(a, b) {
    return modulo(a, b);
  },
  div: function(a, b) {
    return Math.floor(a / b);
  },
  pow: function(a, b) {
    return Math.pow(a, b);
  },
  existsOr: function(a, b) {
    return a != null ? a : b();
  },
  exists: function(a) {
    return (a !== null && a !== void 0) || void 0;
  },
  is: function(a, b) {
    return a === b || ((a != null) && (b != null) && a.constructor === b);
  },

  /*
  Implements the 'import' function.
  
  IN:
    importNames: array of strings of identifiers to import
    libs: array of objects to import from, first has highest priority.
  
  OUT: and object with one property per importName
   */
  "import": _import = function(importNames, libs) {
    var i, importFileName, importFrom, importName, j, k, len, len1, lib, line, notFound, out, ref1, ref2, v;
    out = {};
    notFound = null;
    libs = compactFlatten(libs);
    for (i = 0, len = importNames.length; i < len; i++) {
      importName = importNames[i];
      for (j = libs.length - 1; j >= 0; j += -1) {
        lib = libs[j];
        if ((v = lib[importName]) != null) {
          out[importName] = v;
          break;
        }
      }
      if (out[importName] == null) {
        (notFound || (notFound = [])).push(importName);
      }
    }
    if (notFound != null) {
      importFrom = ((function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = libs.length; k < len1; k++) {
          lib = libs[k];
          if (lib === global) {
            results.push("global");
          } else if (lib != null) {
            results.push(lib.namespacePath || (typeof lib.getName === "function" ? lib.getName() : void 0) || ("{" + (Object.keys(lib).join(', ')) + "}"));
          } else {
            results.push('null');
          }
        }
        return results;
      })()).join('\n  ');
      ref1 = (new Error).stack.split("\n");
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        line = ref1[k];
        if (!(line.match(/^\s/) && !line.match(/caffeine-script-runtime/))) {
          continue;
        }
        importFileName = ((ref2 = line.match(/\(([^()]+)/)) != null ? ref2[1] : void 0) || line;
        break;
      }
      console.warn("CaffineScript imports not found:\n  " + (notFound.join('\n  ')) + "\n\nimporting from:\n  " + importFrom + "\n\nsource:\n  " + importFileName + "\n");
      throw new Error("CaffineScript imports not found: " + (notFound.join(', ')));
    }
    return out;
  },
  isTrue: isTrue = function(a) {
    return (a != null) && a !== false;
  },
  isFalse: isFalse = function(a) {
    return a === false || (a == null);
  },
  isFunction: isFunction = function(a) {
    return typeof a === "function";
  },
  isDirectPrototypeOf: isDirectPrototypeOf = function(o, prototype) {
    return !isFunction(o) && prototype.constructor === o.constructor;
  },
  toString: function(a) {
    if (a != null) {
      if (isPlainArray(a)) {
        return a.join('');
      } else if (isFunction(a != null ? a.toString : void 0)) {
        return a.toString();
      } else {

      }
    } else {
      return '';
    }
  },
  gt: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a > b;
    } else {
      return a.gt(b);
    }
  },
  lt: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a < b;
    } else {
      return a.lt(b);
    }
  },
  lte: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a <= b;
    } else {
      return a.lte(b);
    }
  },
  gte: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a >= b;
    } else {
      return a.gte(b);
    }
  },
  add: function(a, b) {
    if ((typeof a === "number" && typeof b === "number") || (typeof a === "string" && typeof b === "string")) {
      return a + b;
    } else {
      return a.add(b);
    }
  },
  sub: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    } else {
      return a.sub(b);
    }
  },
  mul: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a * b;
    } else {
      return a.mul(b);
    }
  },
  div: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a / b;
    } else {
      return a.div(b);
    }
  },

  /*
  All about getSuper in ES6 land:
  
    class A {}
    class B extends A {}
    class C extends B {}
  
    a = new A
    b = new B
    c = new C
  
    getSuper(B) == A
    getSuper(C) == B
  
    getSuper(A.prototype) == Object.prototype
    getSuper(B.prototype) == A.prototype
    getSuper(C.prototype) == B.prototype
  
    getSuper(b) == A.prototype
    getSuper(c) == B.prototype
  
  prototype map:
  
  KEY:
    <->
       <-- .constructor
       --> .prototype
    ^  Object.prototypeOf
  
  MAP:
    A <-> aPrototype
  
    ^     ^     ^
    |     |     a
    |     |
  
    B <-> bPrototype
  
    ^     ^     ^
    |     |     b
    |     |
  
    C <-> cPrototype
  
                ^
                c
  
  Definition of super:
  
    if instance then prototype's prototype
    else prototype
   */
  getSuper: getSuper = function(o) {
    var _super, out;
    if (!((typeof o === "object") || (typeof o === "function"))) {
      throw new Error("getSuper expecting an object");
    }
    _super = Object.getPrototypeOf(o);
    out = _super === Function.prototype && o.__super__ ? o.__super__.constructor : isDirectPrototypeOf(o, _super) ? Object.getPrototypeOf(_super) : _super;
    return out;
  },

  /*
  IN:
    klass a new class-function object
    init: (klass) -> outKlass
  
  OUT: if isF outKlass.createWithPostCreate
    outKlass.createWithPostCreate outKlass
  OR
    outKlass (from init)
  
  EFFECT:
    outKlass.createWithPostCreate?(outKlass) ? outKlass
   */
  defClass: function(klass, init) {
    var ref1;
    if (init != null) {
      init.call(klass, klass, getSuper(klass), getSuper(klass.prototype));
    }
    return (ref1 = typeof klass.createWithPostCreate === "function" ? klass.createWithPostCreate(klass) : void 0) != null ? ref1 : klass;
  },
  getModuleBeingDefined: function() {
    return global.__definingModule;
  },

  /*
  IN:
    defineFunciton ||
   */
  defMod: function(_module, a) {
    var lastModule, result;
    lastModule = global.__definingModule;
    global.__definingModule = _module;
    result = _module.exports = a();
    global.__definingModule = lastModule;
    return result;
  },
  i: _import,
  t: isTrue,
  f: isFalse,
  isF: isFunction
};


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var k, out, ref, ref1, ref2, v;

module.exports = out = {};

ref = __webpack_require__(158);
for (k in ref) {
  v = ref[k];
  out[k] = v;
}

ref1 = __webpack_require__(278);
for (k in ref1) {
  v = ref1[k];
  out[k] = v;
}

ref2 = __webpack_require__(279);
for (k in ref2) {
  v = ref2[k];
  out[k] = v;
}


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(282);


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

var Namespace, Neptune, version,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

__webpack_require__(285);

__webpack_require__(284);

version = (__webpack_require__(298)).version;

if (global.Neptune) {
  throw new Error("Load NeptuneNamespaces(" + version + ") FAILED. Another version already loaded: " + global.Neptune.version);
}

module.exports = global.Neptune = Neptune = (function(superClass) {
  extend(Neptune, superClass);

  function Neptune() {
    return Neptune.__super__.constructor.apply(this, arguments);
  }

  Namespace.namespace = Namespace.Neptune = Neptune;

  Neptune.Namespace = Namespace;

  Neptune.PackageNamespace = __webpack_require__(283);

  Neptune.namespacePath = "Neptune";

  Neptune.namespace = null;

  Neptune.version = version;

  Neptune.Base = Namespace;

  Neptune.isNode = __webpack_require__(167);

  return Neptune;

})(Namespace = __webpack_require__(159));


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

var PackageNamespace,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = PackageNamespace = (function(superClass) {
  extend(PackageNamespace, superClass);

  function PackageNamespace() {
    return PackageNamespace.__super__.constructor.apply(this, arguments);
  }

  return PackageNamespace;

})(__webpack_require__(159));


/***/ }),
/* 284 */
/***/ (function(module, exports) {

if ((function() {}).name == null) {
  Object.defineProperty(global.Function.prototype, 'name', {
    get: function() {
      var matches, name;
      name = (matches = this.toString().match(/^\s*function\s*([^\s(]+)/)) ? matches[1] : "";
      Object.defineProperty(this, 'name', {
        value: name
      });
      return name;
    }
  });
}

global.Function.prototype.getName = function() {
  if (this._name && this.hasOwnProperty("_name")) {
    return this._name;
  } else {
    return this.name || "anonymousFunction";
  }
};

global.Function.prototype.hasName = function() {
  return !!((this._name && this.hasOwnProperty("_name")) || this.name);
};


/***/ }),
/* 285 */
/***/ (function(module, exports) {

var g;

g = typeof window !== "undefined" && window !== null ? window : typeof self !== "undefined" && self !== null ? self : global;

g.self || (g.self = g);

g.global || (g.global = g);


/***/ }),
/* 286 */
/***/ (function(module, exports) {

module.exports = {"dependencies":{"aws-sdk":"^2.62.0","aws4":"^1.6.0","bluebird":"^3.5.0","colors":"^1.1.2","compress":"^0.99.0","compression":"^1.6.2","detect-node":"^2.0.3","express":"^4.15.3","fs-extra":"^3.0.1","jsonwebtoken":"^7.4.1","mailgun-js":"^0.11.2","morgan":"^1.8.2","newrelic":"^2.2.1","pusher":"^1.5.1","querystring":"*","stripe":"^4.22.0","throng":"^4.0.0","uuid":"^3.0.1","xhr2":"^0.1.4"},"description":"Art.Chat","engines":{"node":"8.x"},"scripts":{"build":"nn -s; webpack --progress","dev":"nn -s; webpack-dev-server --hot --inline --progress","start":"node build/Server.js"}}

/***/ }),
/* 287 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Enhances javascript/coffeescript classes with features of more evolved class-based languages primarily through a new BaseClass.","license":"ISC","name":"art-class-system","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.10.10"}

/***/ }),
/* 288 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Simplified system of statuses for HTTP and any other network protocol","license":"ISC","name":"art-communication-status","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.5.2"}

/***/ }),
/* 289 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-events":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"A powerful yet simple tool for configuring all your libraries consistently.","license":"ISC","name":"art-config","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.7.1"}

/***/ }),
/* 290 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-aws":"git://github.com/imikimi/art-aws.git","art-build-configurator":"*","art-class-system":"*","art-config":"*","art-ery":"git://github.com/imikimi/art-ery.git","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","uuid":"^2.0.3","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"ArtEry for AWS Lambda + DynamoDB","license":"ISC","name":"art-ery-aws","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.27.3"}

/***/ }),
/* 291 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","pusher":"^1.5.1","pusher-js":"^4.0.0","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Art.Ery.Pusher","license":"ISC","name":"art-ery-pusher","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress","testServer":"coffee ./TestServer.coffee"},"version":"0.11.3"}

/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-epoched-state":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Epoched event system","license":"ISC","name":"art-events","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.2.3"}

/***/ }),
/* 293 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","compression":"^1.6.2","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","express":"^4.15.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","jsonwebtoken":"^7.4.1","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","throng":"^4.0.0","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Extensible, Promise-based HTTP Server based on Express","license":"ISC","name":"art-express-server","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress","testServer":"coffee ./TestServer.coffee"},"version":"0.4.2"}

/***/ }),
/* 294 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Create Declarative frameworks that output tree structures with properties (e.g. ArtReact)","license":"ISC","name":"art-object-tree-factory","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.1.3"}

/***/ }),
/* 295 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-communication-status":"^1.0.0","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0","xhr2":"^0.1.4"},"description":"Promise-based rest-client library. Makes HTTP/HTTPS easy in both NODE and BROWSER.","license":"ISC","name":"art-rest-client","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.6.2"}

/***/ }),
/* 296 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"The Standard Library for JavaScript that aught to be.","license":"ISC","name":"art-standard-lib","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.28.2"}

/***/ }),
/* 297 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-communication-status":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Validate object props.","license":"ISC","name":"art-validation","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.6.2"}

/***/ }),
/* 298 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-standard-lib":"*","coffee-script":"*"},"description":"Neptune.Namespaces.Runtime","license":"ISC","name":"neptune-namespaces-runtime","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"3.0.7"}

/***/ }),
/* 299 */
/***/ (function(module, exports) {

module.exports = require("aws4");

/***/ }),
/* 300 */
/***/ (function(module, exports) {

module.exports = require("bluebird/js/browser/bluebird.core.min");

/***/ }),
/* 301 */
/***/ (function(module, exports) {

module.exports = require("colors");

/***/ }),
/* 302 */
/***/ (function(module, exports) {

module.exports = require("compression");

/***/ }),
/* 303 */
/***/ (function(module, exports) {

module.exports = require("jsonwebtoken");

/***/ }),
/* 304 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 305 */
/***/ (function(module, exports) {

module.exports = require("pusher");

/***/ }),
/* 306 */
/***/ (function(module, exports) {

module.exports = require("throng");

/***/ })
/******/ ]);